diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts distributors/contracts/MerkleOrchard.sol distributors/contracts/MerkleOrchard.sol
--- distributors/contracts/MerkleOrchard.sol	2022-10-28 09:21:25.000000000 +0200
+++ distributors/contracts/MerkleOrchard.sol	2022-10-28 09:58:16.000000000 +0200
@@ -14,13 +14,13 @@
 
 pragma experimental ABIEncoderV2;
 
-import "@balancer-labs/v2-interfaces/contracts/solidity-utils/openzeppelin/IERC20.sol";
-import "@balancer-labs/v2-interfaces/contracts/distributors/IDistributorCallback.sol";
-import "@balancer-labs/v2-interfaces/contracts/vault/IVault.sol";
-import "@balancer-labs/v2-interfaces/contracts/vault/IAsset.sol";
+import "../../interfaces/contracts/solidity-utils/openzeppelin/IERC20.sol";
+import "../../interfaces/contracts/distributors/IDistributorCallback.sol";
+import "../../interfaces/contracts/vault/IVault.sol";
+import "../../interfaces/contracts/vault/IAsset.sol";
 
-import "@balancer-labs/v2-solidity-utils/contracts/openzeppelin/MerkleProof.sol";
-import "@balancer-labs/v2-solidity-utils/contracts/openzeppelin/SafeERC20.sol";
+import "../../solidity-utils/contracts/openzeppelin/MerkleProof.sol";
+import "../../solidity-utils/contracts/openzeppelin/SafeERC20.sol";
 
 pragma solidity ^0.7.0;
 
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts distributors/contracts/MerkleRedeem.sol distributors/contracts/MerkleRedeem.sol
--- distributors/contracts/MerkleRedeem.sol	2022-10-28 09:21:25.000000000 +0200
+++ distributors/contracts/MerkleRedeem.sol	2022-10-28 09:58:16.000000000 +0200
@@ -14,15 +14,15 @@
 
 pragma experimental ABIEncoderV2;
 
-import "@balancer-labs/v2-interfaces/contracts/solidity-utils/openzeppelin/IERC20.sol";
-import "@balancer-labs/v2-interfaces/contracts/distributors/IDistributorCallback.sol";
-import "@balancer-labs/v2-interfaces/contracts/vault/IVault.sol";
-import "@balancer-labs/v2-interfaces/contracts/vault/IAsset.sol";
-
-import "@balancer-labs/v2-solidity-utils/contracts/openzeppelin/MerkleProof.sol";
-import "@balancer-labs/v2-solidity-utils/contracts/openzeppelin/SafeERC20.sol";
-import "@balancer-labs/v2-solidity-utils/contracts/openzeppelin/Ownable.sol";
-import "@balancer-labs/v2-solidity-utils/contracts/math/FixedPoint.sol";
+import "../../interfaces/contracts/solidity-utils/openzeppelin/IERC20.sol";
+import "../../interfaces/contracts/distributors/IDistributorCallback.sol";
+import "../../interfaces/contracts/vault/IVault.sol";
+import "../../interfaces/contracts/vault/IAsset.sol";
+
+import "../../solidity-utils/contracts/openzeppelin/MerkleProof.sol";
+import "../../solidity-utils/contracts/openzeppelin/SafeERC20.sol";
+import "../../solidity-utils/contracts/openzeppelin/Ownable.sol";
+import "../../solidity-utils/contracts/math/FixedPoint.sol";
 
 pragma solidity ^0.7.0;
 
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts distributors/contracts/test/MockRewardCallback.sol distributors/contracts/test/MockRewardCallback.sol
--- distributors/contracts/test/MockRewardCallback.sol	2022-10-03 09:35:45.000000000 +0200
+++ distributors/contracts/test/MockRewardCallback.sol	2022-10-28 09:58:16.000000000 +0200
@@ -15,7 +15,7 @@
 pragma solidity ^0.7.0;
 pragma experimental ABIEncoderV2;
 
-import "@balancer-labs/v2-interfaces/contracts/distributors/IDistributorCallback.sol";
+import "../../interfaces/contracts/distributors/IDistributorCallback.sol";
 
 contract MockRewardCallback is IDistributorCallback {
     event CallbackReceived();
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts liquidity-mining/contracts/BalancerMinter.sol liquidity-mining/contracts/BalancerMinter.sol
--- liquidity-mining/contracts/BalancerMinter.sol	2022-10-03 09:35:45.000000000 +0200
+++ liquidity-mining/contracts/BalancerMinter.sol	2022-10-28 09:58:16.000000000 +0200
@@ -14,15 +14,15 @@
 
 pragma solidity ^0.7.0;
 
-import "@balancer-labs/v2-interfaces/contracts/liquidity-mining/IBalancerMinter.sol";
-import "@balancer-labs/v2-interfaces/contracts/liquidity-mining/IBalancerTokenAdmin.sol";
-import "@balancer-labs/v2-interfaces/contracts/liquidity-mining/IGaugeController.sol";
-import "@balancer-labs/v2-interfaces/contracts/liquidity-mining/ILiquidityGauge.sol";
-
-import "@balancer-labs/v2-solidity-utils/contracts/openzeppelin/ReentrancyGuard.sol";
-import "@balancer-labs/v2-solidity-utils/contracts/openzeppelin/SafeMath.sol";
-import "@balancer-labs/v2-solidity-utils/contracts/openzeppelin/EIP712.sol";
-import "@balancer-labs/v2-solidity-utils/contracts/helpers/EOASignaturesValidator.sol";
+import "../../interfaces/contracts/liquidity-mining/IBalancerMinter.sol";
+import "../../interfaces/contracts/liquidity-mining/IBalancerTokenAdmin.sol";
+import "../../interfaces/contracts/liquidity-mining/IGaugeController.sol";
+import "../../interfaces/contracts/liquidity-mining/ILiquidityGauge.sol";
+
+import "../../solidity-utils/contracts/openzeppelin/ReentrancyGuard.sol";
+import "../../solidity-utils/contracts/openzeppelin/SafeMath.sol";
+import "../../solidity-utils/contracts/openzeppelin/EIP712.sol";
+import "../../solidity-utils/contracts/helpers/EOASignaturesValidator.sol";
 
 contract BalancerMinter is IBalancerMinter, ReentrancyGuard, EOASignaturesValidator {
     using SafeMath for uint256;
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts liquidity-mining/contracts/BalancerTokenAdmin.sol liquidity-mining/contracts/BalancerTokenAdmin.sol
--- liquidity-mining/contracts/BalancerTokenAdmin.sol	2022-10-03 09:35:45.000000000 +0200
+++ liquidity-mining/contracts/BalancerTokenAdmin.sol	2022-10-28 09:58:16.000000000 +0200
@@ -14,12 +14,12 @@
 
 pragma solidity ^0.7.0;
 
-import "@balancer-labs/v2-interfaces/contracts/liquidity-mining/IBalancerTokenAdmin.sol";
+import "../../interfaces/contracts/liquidity-mining/IBalancerTokenAdmin.sol";
 
-import "@balancer-labs/v2-solidity-utils/contracts/helpers/SingletonAuthentication.sol";
-import "@balancer-labs/v2-solidity-utils/contracts/openzeppelin/ReentrancyGuard.sol";
-import "@balancer-labs/v2-solidity-utils/contracts/helpers/Authentication.sol";
-import "@balancer-labs/v2-solidity-utils/contracts/math/Math.sol";
+import "../../solidity-utils/contracts/helpers/SingletonAuthentication.sol";
+import "../../solidity-utils/contracts/openzeppelin/ReentrancyGuard.sol";
+import "../../solidity-utils/contracts/helpers/Authentication.sol";
+import "../../solidity-utils/contracts/math/Math.sol";
 
 // solhint-disable not-rely-on-time
 
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts liquidity-mining/contracts/SmartWalletChecker.sol liquidity-mining/contracts/SmartWalletChecker.sol
--- liquidity-mining/contracts/SmartWalletChecker.sol	2022-10-03 09:35:45.000000000 +0200
+++ liquidity-mining/contracts/SmartWalletChecker.sol	2022-10-28 09:58:16.000000000 +0200
@@ -14,11 +14,11 @@
 
 pragma solidity ^0.7.0;
 
-import "@balancer-labs/v2-interfaces/contracts/liquidity-mining/ISmartWalletChecker.sol";
-import "@balancer-labs/v2-interfaces/contracts/vault/IVault.sol";
+import "../../interfaces/contracts/liquidity-mining/ISmartWalletChecker.sol";
+import "../../interfaces/contracts/vault/IVault.sol";
 
-import "@balancer-labs/v2-solidity-utils/contracts/helpers/SingletonAuthentication.sol";
-import "@balancer-labs/v2-solidity-utils/contracts/openzeppelin/EnumerableSet.sol";
+import "../../solidity-utils/contracts/helpers/SingletonAuthentication.sol";
+import "../../solidity-utils/contracts/openzeppelin/EnumerableSet.sol";
 
 contract SmartWalletChecker is ISmartWalletChecker, SingletonAuthentication {
     using EnumerableSet for EnumerableSet.AddressSet;
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts liquidity-mining/contracts/VotingEscrowDelegationProxy.sol liquidity-mining/contracts/VotingEscrowDelegationProxy.sol
--- liquidity-mining/contracts/VotingEscrowDelegationProxy.sol	2022-10-03 09:35:45.000000000 +0200
+++ liquidity-mining/contracts/VotingEscrowDelegationProxy.sol	2022-10-28 09:58:16.000000000 +0200
@@ -14,10 +14,10 @@
 
 pragma solidity ^0.7.0;
 
-import "@balancer-labs/v2-interfaces/contracts/liquidity-mining/IVeDelegation.sol";
-import "@balancer-labs/v2-interfaces/contracts/vault/IVault.sol";
+import "../../interfaces/contracts/liquidity-mining/IVeDelegation.sol";
+import "../../interfaces/contracts/vault/IVault.sol";
 
-import "@balancer-labs/v2-solidity-utils/contracts/helpers/SingletonAuthentication.sol";
+import "../../solidity-utils/contracts/helpers/SingletonAuthentication.sol";
 
 contract VotingEscrowDelegationProxy is SingletonAuthentication {
     IERC20 private immutable _votingEscrow;
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts liquidity-mining/contracts/admin/AuthorizerAdaptor.sol liquidity-mining/contracts/admin/AuthorizerAdaptor.sol
--- liquidity-mining/contracts/admin/AuthorizerAdaptor.sol	2022-10-03 09:35:45.000000000 +0200
+++ liquidity-mining/contracts/admin/AuthorizerAdaptor.sol	2022-10-28 09:58:16.000000000 +0200
@@ -14,12 +14,12 @@
 
 pragma solidity ^0.7.0;
 
-import "@balancer-labs/v2-interfaces/contracts/liquidity-mining/IAuthorizerAdaptor.sol";
-import "@balancer-labs/v2-interfaces/contracts/vault/IAuthorizer.sol";
-import "@balancer-labs/v2-interfaces/contracts/vault/IVault.sol";
+import "../../interfaces/contracts/liquidity-mining/IAuthorizerAdaptor.sol";
+import "../../interfaces/contracts/vault/IAuthorizer.sol";
+import "../../interfaces/contracts/vault/IVault.sol";
 
-import "@balancer-labs/v2-solidity-utils/contracts/openzeppelin/ReentrancyGuard.sol";
-import "@balancer-labs/v2-solidity-utils/contracts/openzeppelin/Address.sol";
+import "../../solidity-utils/contracts/openzeppelin/ReentrancyGuard.sol";
+import "../../solidity-utils/contracts/openzeppelin/Address.sol";
 
 /**
  * @title Authorizer Adaptor
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts liquidity-mining/contracts/admin/ChildChainGaugeTokenAdder.sol liquidity-mining/contracts/admin/ChildChainGaugeTokenAdder.sol
--- liquidity-mining/contracts/admin/ChildChainGaugeTokenAdder.sol	2022-10-03 09:35:45.000000000 +0200
+++ liquidity-mining/contracts/admin/ChildChainGaugeTokenAdder.sol	2022-10-28 09:58:16.000000000 +0200
@@ -15,10 +15,10 @@
 pragma solidity ^0.7.0;
 pragma experimental ABIEncoderV2;
 
-import "@balancer-labs/v2-interfaces/contracts/liquidity-mining/IChildChainLiquidityGaugeFactory.sol";
-import "@balancer-labs/v2-interfaces/contracts/liquidity-mining/IAuthorizerAdaptor.sol";
+import "../../interfaces/contracts/liquidity-mining/IChildChainLiquidityGaugeFactory.sol";
+import "../../interfaces/contracts/liquidity-mining/IAuthorizerAdaptor.sol";
 
-import "@balancer-labs/v2-solidity-utils/contracts/helpers/SingletonAuthentication.sol";
+import "../../solidity-utils/contracts/helpers/SingletonAuthentication.sol";
 
 /**
  * @title ChildChainGaugeTokenAdder
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts liquidity-mining/contracts/admin/DistributionScheduler.sol liquidity-mining/contracts/admin/DistributionScheduler.sol
--- liquidity-mining/contracts/admin/DistributionScheduler.sol	2022-10-28 09:21:25.000000000 +0200
+++ liquidity-mining/contracts/admin/DistributionScheduler.sol	2022-10-28 09:58:16.000000000 +0200
@@ -15,9 +15,9 @@
 pragma solidity ^0.7.0;
 pragma experimental ABIEncoderV2;
 
-import "@balancer-labs/v2-interfaces/contracts/liquidity-mining/IRewardTokenDistributor.sol";
+import "../../interfaces/contracts/liquidity-mining/IRewardTokenDistributor.sol";
 
-import "@balancer-labs/v2-solidity-utils/contracts/openzeppelin/SafeERC20.sol";
+import "../../solidity-utils/contracts/openzeppelin/SafeERC20.sol";
 
 // solhint-disable not-rely-on-time
 
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts liquidity-mining/contracts/admin/GaugeAdder.sol liquidity-mining/contracts/admin/GaugeAdder.sol
--- liquidity-mining/contracts/admin/GaugeAdder.sol	2022-10-03 09:35:45.000000000 +0200
+++ liquidity-mining/contracts/admin/GaugeAdder.sol	2022-10-28 09:58:16.000000000 +0200
@@ -14,14 +14,14 @@
 
 pragma solidity ^0.7.0;
 
-import "@balancer-labs/v2-interfaces/contracts/liquidity-mining/IGaugeAdder.sol";
-import "@balancer-labs/v2-interfaces/contracts/liquidity-mining/IStakingLiquidityGauge.sol";
-import "@balancer-labs/v2-interfaces/contracts/vault/IVault.sol";
-
-import "@balancer-labs/v2-solidity-utils/contracts/helpers/SingletonAuthentication.sol";
-import "@balancer-labs/v2-solidity-utils/contracts/openzeppelin/ReentrancyGuard.sol";
-import "@balancer-labs/v2-solidity-utils/contracts/openzeppelin/EnumerableSet.sol";
-import "@balancer-labs/v2-solidity-utils/contracts/helpers/Authentication.sol";
+import "../../interfaces/contracts/liquidity-mining/IGaugeAdder.sol";
+import "../../interfaces/contracts/liquidity-mining/IStakingLiquidityGauge.sol";
+import "../../interfaces/contracts/vault/IVault.sol";
+
+import "../../solidity-utils/contracts/helpers/SingletonAuthentication.sol";
+import "../../solidity-utils/contracts/openzeppelin/ReentrancyGuard.sol";
+import "../../solidity-utils/contracts/openzeppelin/EnumerableSet.sol";
+import "../../solidity-utils/contracts/helpers/Authentication.sol";
 
 contract GaugeAdder is IGaugeAdder, SingletonAuthentication, ReentrancyGuard {
     using EnumerableSet for EnumerableSet.AddressSet;
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts liquidity-mining/contracts/fee-distribution/FeeDistributor.sol liquidity-mining/contracts/fee-distribution/FeeDistributor.sol
--- liquidity-mining/contracts/fee-distribution/FeeDistributor.sol	2022-10-03 09:35:45.000000000 +0200
+++ liquidity-mining/contracts/fee-distribution/FeeDistributor.sol	2022-10-28 09:58:16.000000000 +0200
@@ -15,16 +15,16 @@
 pragma solidity ^0.7.0;
 pragma experimental ABIEncoderV2;
 
-import "@balancer-labs/v2-interfaces/contracts/solidity-utils/helpers/IAuthentication.sol";
-import "@balancer-labs/v2-interfaces/contracts/liquidity-mining/IFeeDistributor.sol";
-import "@balancer-labs/v2-interfaces/contracts/liquidity-mining/IVotingEscrow.sol";
-
-import "@balancer-labs/v2-solidity-utils/contracts/openzeppelin/ReentrancyGuard.sol";
-import "@balancer-labs/v2-solidity-utils/contracts/helpers/OptionalOnlyCaller.sol";
-import "@balancer-labs/v2-solidity-utils/contracts/helpers/InputHelpers.sol";
-import "@balancer-labs/v2-solidity-utils/contracts/openzeppelin/SafeERC20.sol";
-import "@balancer-labs/v2-solidity-utils/contracts/openzeppelin/SafeMath.sol";
-import "@balancer-labs/v2-solidity-utils/contracts/math/Math.sol";
+import "../../interfaces/contracts/solidity-utils/helpers/IAuthentication.sol";
+import "../../interfaces/contracts/liquidity-mining/IFeeDistributor.sol";
+import "../../interfaces/contracts/liquidity-mining/IVotingEscrow.sol";
+
+import "../../solidity-utils/contracts/openzeppelin/ReentrancyGuard.sol";
+import "../../solidity-utils/contracts/helpers/OptionalOnlyCaller.sol";
+import "../../solidity-utils/contracts/helpers/InputHelpers.sol";
+import "../../solidity-utils/contracts/openzeppelin/SafeERC20.sol";
+import "../../solidity-utils/contracts/openzeppelin/SafeMath.sol";
+import "../../solidity-utils/contracts/math/Math.sol";
 
 // solhint-disable not-rely-on-time
 
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts liquidity-mining/contracts/gauges/ChildChainGaugeRewardHelper.sol liquidity-mining/contracts/gauges/ChildChainGaugeRewardHelper.sol
--- liquidity-mining/contracts/gauges/ChildChainGaugeRewardHelper.sol	2022-10-03 09:35:45.000000000 +0200
+++ liquidity-mining/contracts/gauges/ChildChainGaugeRewardHelper.sol	2022-10-28 09:58:16.000000000 +0200
@@ -15,8 +15,8 @@
 pragma solidity ^0.7.0;
 pragma experimental ABIEncoderV2;
 
-import "@balancer-labs/v2-interfaces/contracts/liquidity-mining/IRewardsOnlyGauge.sol";
-import "@balancer-labs/v2-interfaces/contracts/liquidity-mining/IChildChainStreamer.sol";
+import "../../interfaces/contracts/liquidity-mining/IRewardsOnlyGauge.sol";
+import "../../interfaces/contracts/liquidity-mining/IChildChainStreamer.sol";
 
 /**
  * @title ChildChainGaugeRewardHelper
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts liquidity-mining/contracts/gauges/ChildChainLiquidityGaugeFactory.sol liquidity-mining/contracts/gauges/ChildChainLiquidityGaugeFactory.sol
--- liquidity-mining/contracts/gauges/ChildChainLiquidityGaugeFactory.sol	2022-10-28 09:21:25.000000000 +0200
+++ liquidity-mining/contracts/gauges/ChildChainLiquidityGaugeFactory.sol	2022-10-28 09:58:16.000000000 +0200
@@ -15,11 +15,11 @@
 pragma solidity ^0.7.0;
 pragma experimental ABIEncoderV2;
 
-import "@balancer-labs/v2-interfaces/contracts/liquidity-mining/IChildChainLiquidityGaugeFactory.sol";
-import "@balancer-labs/v2-interfaces/contracts/liquidity-mining/ILiquidityGauge.sol";
-import "@balancer-labs/v2-interfaces/contracts/vault/IVault.sol";
+import "../../interfaces/contracts/liquidity-mining/IChildChainLiquidityGaugeFactory.sol";
+import "../../interfaces/contracts/liquidity-mining/ILiquidityGauge.sol";
+import "../../interfaces/contracts/vault/IVault.sol";
 
-import "@balancer-labs/v2-solidity-utils/contracts/openzeppelin/Clones.sol";
+import "../../solidity-utils/contracts/openzeppelin/Clones.sol";
 
 contract ChildChainLiquidityGaugeFactory is IChildChainLiquidityGaugeFactory {
     // RewardsOnlyGauge expects the claim function selector to be left padded with zeros.
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts liquidity-mining/contracts/gauges/StakelessGauge.sol.orig liquidity-mining/contracts/gauges/StakelessGauge.sol.orig
--- liquidity-mining/contracts/gauges/StakelessGauge.sol.orig	1970-01-01 01:00:00.000000000 +0100
+++ liquidity-mining/contracts/gauges/StakelessGauge.sol.orig	2022-10-28 09:58:14.000000000 +0200
@@ -0,0 +1,195 @@
+// SPDX-License-Identifier: GPL-3.0-or-later
+// This program is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation, either version 3 of the License, or
+// (at your option) any later version.
+
+// This program is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License
+// along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+pragma solidity ^0.7.0;
+
+import "@balancer-labs/v2-interfaces/contracts/solidity-utils/openzeppelin/IERC20.sol";
+import "@balancer-labs/v2-interfaces/contracts/liquidity-mining/IBalancerMinter.sol";
+import "@balancer-labs/v2-interfaces/contracts/liquidity-mining/IBalancerTokenAdmin.sol";
+import "@balancer-labs/v2-interfaces/contracts/liquidity-mining/IGaugeController.sol";
+import "@balancer-labs/v2-interfaces/contracts/liquidity-mining/IStakelessGauge.sol";
+
+import "@balancer-labs/v2-solidity-utils/contracts/math/Math.sol";
+import "@balancer-labs/v2-solidity-utils/contracts/openzeppelin/ReentrancyGuard.sol";
+
+abstract contract StakelessGauge is IStakelessGauge, ReentrancyGuard {
+    uint256 public constant MAX_RELATIVE_WEIGHT_CAP = 1e18;
+
+    IERC20 internal immutable _balToken;
+    IBalancerTokenAdmin private immutable _tokenAdmin;
+    IBalancerMinter private immutable _minter;
+    IGaugeController private immutable _gaugeController;
+    IAuthorizerAdaptor private immutable _authorizerAdaptor;
+
+    event Checkpoint(uint256 indexed periodTime, uint256 periodEmissions);
+
+    // solhint-disable var-name-mixedcase
+    uint256 private immutable _RATE_REDUCTION_TIME;
+    uint256 private immutable _RATE_REDUCTION_COEFFICIENT;
+    uint256 private immutable _RATE_DENOMINATOR;
+    // solhint-enable var-name-mixedcase
+
+    uint256 private _rate;
+    uint256 private _period;
+    uint256 private _startEpochTime;
+
+    uint256 private _emissions;
+    bool private _isKilled;
+
+    uint256 private _relativeWeightCap;
+
+    constructor(IBalancerMinter minter) {
+        IBalancerTokenAdmin tokenAdmin = IBalancerTokenAdmin(minter.getBalancerTokenAdmin());
+        IERC20 balToken = tokenAdmin.getBalancerToken();
+        IGaugeController gaugeController = minter.getGaugeController();
+
+        _balToken = balToken;
+        _tokenAdmin = tokenAdmin;
+        _minter = minter;
+        _gaugeController = gaugeController;
+        _authorizerAdaptor = gaugeController.admin();
+
+        _RATE_REDUCTION_TIME = tokenAdmin.RATE_REDUCTION_TIME();
+        _RATE_REDUCTION_COEFFICIENT = tokenAdmin.RATE_REDUCTION_COEFFICIENT();
+        _RATE_DENOMINATOR = tokenAdmin.RATE_DENOMINATOR();
+
+        // Prevent initialisation of implementation contract
+        // Choice of `type(uint256).max` prevents implementation from being checkpointed
+        _period = type(uint256).max;
+    }
+
+    // solhint-disable-next-line func-name-mixedcase
+    function __StakelessGauge_init(uint256 relativeWeightCap) internal {
+        require(_period == 0, "Already initialized");
+
+        // Because we calculate the rate locally, this gauge cannot
+        // be used prior to the start of the first emission period
+        uint256 rate = _tokenAdmin.rate();
+        require(rate != 0, "BalancerTokenAdmin not yet activated");
+
+        _rate = rate;
+        _period = _currentPeriod();
+        _startEpochTime = _tokenAdmin.startEpochTimeWrite();
+        _setRelativeWeightCap(relativeWeightCap);
+    }
+
+    function checkpoint() external payable override nonReentrant returns (bool) {
+        require(msg.sender == address(_authorizerAdaptor), "SENDER_NOT_ALLOWED");
+        uint256 lastPeriod = _period;
+        uint256 currentPeriod = _currentPeriod();
+
+        if (lastPeriod < currentPeriod) {
+            _gaugeController.checkpoint_gauge(address(this));
+
+            uint256 rate = _rate;
+            uint256 newEmissions = 0;
+            lastPeriod += 1;
+            uint256 nextEpochTime = _startEpochTime + _RATE_REDUCTION_TIME;
+            for (uint256 i = lastPeriod; i < lastPeriod + 255; ++i) {
+                if (i > currentPeriod) break;
+
+                uint256 periodTime = i * 1 weeks;
+                uint256 periodEmission = 0;
+                uint256 gaugeWeight = getCappedRelativeWeight(periodTime);
+
+                if (nextEpochTime >= periodTime && nextEpochTime < periodTime + 1 weeks) {
+                    // If the period crosses an epoch, we calculate a reduction in the rate
+                    // using the same formula as used in `BalancerTokenAdmin`. We perform the calculation
+                    // locally instead of calling to `BalancerTokenAdmin.rate()` because we are generating
+                    // the emissions for the upcoming week, so there is a possibility the new
+                    // rate has not yet been applied.
+
+                    // Calculate emission up until the epoch change
+                    uint256 durationInCurrentEpoch = nextEpochTime - periodTime;
+                    periodEmission = (gaugeWeight * rate * durationInCurrentEpoch) / 10**18;
+                    // Action the decrease in rate
+                    rate = (rate * _RATE_DENOMINATOR) / _RATE_REDUCTION_COEFFICIENT;
+                    // Calculate emission from epoch change to end of period
+                    uint256 durationInNewEpoch = 1 weeks - durationInCurrentEpoch;
+                    periodEmission += (gaugeWeight * rate * durationInNewEpoch) / 10**18;
+
+                    _rate = rate;
+                    _startEpochTime = nextEpochTime;
+                    nextEpochTime += _RATE_REDUCTION_TIME;
+                } else {
+                    periodEmission = (gaugeWeight * rate * 1 weeks) / 10**18;
+                }
+
+                emit Checkpoint(periodTime, periodEmission);
+                newEmissions += periodEmission;
+            }
+
+            _period = currentPeriod;
+            _emissions += newEmissions;
+
+            if (newEmissions > 0 && !_isKilled) {
+                _minter.mint(address(this));
+                _postMintAction(newEmissions);
+            }
+        }
+
+        return true;
+    }
+
+    function _currentPeriod() internal view returns (uint256) {
+        // solhint-disable-next-line not-rely-on-time
+        return (block.timestamp / 1 weeks) - 1;
+    }
+
+    function _postMintAction(uint256 mintAmount) internal virtual;
+
+    // solhint-disable func-name-mixedcase
+
+    function user_checkpoint(address) external pure override returns (bool) {
+        return true;
+    }
+
+    function integrate_fraction(address user) external view override returns (uint256) {
+        require(user == address(this), "Gauge can only mint for itself");
+        return _emissions;
+    }
+
+    function is_killed() external view override returns (bool) {
+        return _isKilled;
+    }
+
+    function killGauge() external override {
+        require(msg.sender == address(_authorizerAdaptor), "SENDER_NOT_ALLOWED");
+        _isKilled = true;
+    }
+
+    function unkillGauge() external override {
+        require(msg.sender == address(_authorizerAdaptor), "SENDER_NOT_ALLOWED");
+        _isKilled = false;
+    }
+
+    function setRelativeWeightCap(uint256 relativeWeightCap) external override {
+        require(msg.sender == address(_authorizerAdaptor), "SENDER_NOT_ALLOWED");
+        _setRelativeWeightCap(relativeWeightCap);
+    }
+
+    function _setRelativeWeightCap(uint256 relativeWeightCap) internal {
+        require(relativeWeightCap <= MAX_RELATIVE_WEIGHT_CAP, "Relative weight cap exceeds allowed absolute maximum");
+        _relativeWeightCap = relativeWeightCap;
+        emit RelativeWeightCapChanged(relativeWeightCap);
+    }
+
+    function getRelativeWeightCap() external view override returns (uint256) {
+        return _relativeWeightCap;
+    }
+
+    function getCappedRelativeWeight(uint256 time) public view override returns (uint256) {
+        return Math.min(_gaugeController.gauge_relative_weight(address(this), time), _relativeWeightCap);
+    }
+}
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts liquidity-mining/contracts/gauges/StakelessGauge.sol.rej liquidity-mining/contracts/gauges/StakelessGauge.sol.rej
--- liquidity-mining/contracts/gauges/StakelessGauge.sol.rej	1970-01-01 01:00:00.000000000 +0100
+++ liquidity-mining/contracts/gauges/StakelessGauge.sol.rej	2022-10-28 09:58:16.000000000 +0200
@@ -0,0 +1,29 @@
+***************
+*** 14,26 ****
+  
+  pragma solidity ^0.7.0;
+  
+- import "@balancer-labs/v2-interfaces/contracts/solidity-utils/openzeppelin/IERC20.sol";
+- import "@balancer-labs/v2-interfaces/contracts/liquidity-mining/IBalancerMinter.sol";
+- import "@balancer-labs/v2-interfaces/contracts/liquidity-mining/IBalancerTokenAdmin.sol";
+- import "@balancer-labs/v2-interfaces/contracts/liquidity-mining/IGaugeController.sol";
+- import "@balancer-labs/v2-interfaces/contracts/liquidity-mining/IStakelessGauge.sol";
+  
+- import "@balancer-labs/v2-solidity-utils/contracts/openzeppelin/ReentrancyGuard.sol";
+  
+  abstract contract StakelessGauge is IStakelessGauge, ReentrancyGuard {
+      IERC20 internal immutable _balToken;
+--- 14,26 ----
+  
+  pragma solidity ^0.7.0;
+  
++ import "../../interfaces/contracts/solidity-utils/openzeppelin/IERC20.sol";
++ import "../../interfaces/contracts/liquidity-mining/IBalancerMinter.sol";
++ import "../../interfaces/contracts/liquidity-mining/IBalancerTokenAdmin.sol";
++ import "../../interfaces/contracts/liquidity-mining/IGaugeController.sol";
++ import "../../interfaces/contracts/liquidity-mining/IStakelessGauge.sol";
+  
++ import "../../solidity-utils/contracts/openzeppelin/ReentrancyGuard.sol";
+  
+  abstract contract StakelessGauge is IStakelessGauge, ReentrancyGuard {
+      IERC20 internal immutable _balToken;
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts liquidity-mining/contracts/gauges/arbitrum/ArbitrumRootGauge.sol.orig liquidity-mining/contracts/gauges/arbitrum/ArbitrumRootGauge.sol.orig
--- liquidity-mining/contracts/gauges/arbitrum/ArbitrumRootGauge.sol.orig	1970-01-01 01:00:00.000000000 +0100
+++ liquidity-mining/contracts/gauges/arbitrum/ArbitrumRootGauge.sol.orig	2022-10-28 09:58:14.000000000 +0200
@@ -0,0 +1,87 @@
+// SPDX-License-Identifier: GPL-3.0-or-later
+// This program is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation, either version 3 of the License, or
+// (at your option) any later version.
+
+// This program is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License
+// along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+pragma solidity ^0.7.0;
+
+import "@balancer-labs/v2-interfaces/contracts/liquidity-mining/IArbitrumFeeProvider.sol";
+import "@balancer-labs/v2-solidity-utils/contracts/openzeppelin/SafeERC20.sol";
+
+import "../StakelessGauge.sol";
+import "./IGatewayRouter.sol";
+
+contract ArbitrumRootGauge is StakelessGauge {
+    using SafeERC20 for IERC20;
+
+    address private immutable _gateway;
+    IGatewayRouter private immutable _gatewayRouter;
+    IArbitrumFeeProvider private immutable _factory;
+
+    address private _recipient;
+
+    constructor(IBalancerMinter minter, IGatewayRouter gatewayRouter) StakelessGauge(minter) {
+        _gateway = gatewayRouter.getGateway(address(minter.getBalancerToken()));
+        _gatewayRouter = gatewayRouter;
+        _factory = IArbitrumFeeProvider(msg.sender);
+    }
+
+    function initialize(address recipient, uint256 relativeWeightCap) external {
+        // This will revert in all calls except the first one
+        __StakelessGauge_init(relativeWeightCap);
+
+        _recipient = recipient;
+    }
+
+    function getRecipient() external view override returns (address) {
+        return _recipient;
+    }
+
+    function _postMintAction(uint256 mintAmount) internal override {
+        // Token needs to be approved on the gateway NOT the gateway router
+        _balToken.safeApprove(_gateway, mintAmount);
+
+        (uint256 gasLimit, uint256 gasPrice, uint256 maxSubmissionCost) = _factory.getArbitrumFees();
+        uint256 totalBridgeCost = _getTotalBridgeCost(gasLimit, gasPrice, maxSubmissionCost);
+        require(msg.value == totalBridgeCost, "Incorrect msg.value passed");
+
+        // After bridging, the BAL should arrive on Arbitrum within 10 minutes. If it
+        // does not, the L2 transaction may have failed due to an insufficient amount
+        // within `max_submission_cost + (gas_limit * gas_price)`
+        // In this case, the transaction can be manually broadcasted on Arbitrum by calling
+        // `ArbRetryableTicket(0x000000000000000000000000000000000000006e).redeem(redemption-TxID)`
+        // The calldata for this manual transaction is easily obtained by finding the reverted
+        // transaction in the tx history for 0x000000000000000000000000000000000000006e on Arbiscan.
+        // https://developer.offchainlabs.com/docs/l1_l2_messages#retryable-transaction-lifecycle
+        _gatewayRouter.outboundTransfer{ value: totalBridgeCost }(
+            _balToken,
+            _recipient,
+            mintAmount,
+            gasLimit,
+            gasPrice,
+            abi.encode(maxSubmissionCost, "")
+        );
+    }
+
+    function getTotalBridgeCost() external view returns (uint256) {
+        (uint256 gasLimit, uint256 gasPrice, uint256 maxSubmissionCost) = _factory.getArbitrumFees();
+        return _getTotalBridgeCost(gasLimit, gasPrice, maxSubmissionCost);
+    }
+
+    function _getTotalBridgeCost(
+        uint256 gasLimit,
+        uint256 gasPrice,
+        uint256 maxSubmissionCost
+    ) internal pure returns (uint256) {
+        return gasLimit * gasPrice + maxSubmissionCost;
+    }
+}
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts liquidity-mining/contracts/gauges/arbitrum/ArbitrumRootGauge.sol.rej liquidity-mining/contracts/gauges/arbitrum/ArbitrumRootGauge.sol.rej
--- liquidity-mining/contracts/gauges/arbitrum/ArbitrumRootGauge.sol.rej	1970-01-01 01:00:00.000000000 +0100
+++ liquidity-mining/contracts/gauges/arbitrum/ArbitrumRootGauge.sol.rej	2022-10-28 09:58:16.000000000 +0200
@@ -0,0 +1,19 @@
+***************
+*** 14,21 ****
+  
+  pragma solidity ^0.7.0;
+  
+- import "@balancer-labs/v2-interfaces/contracts/liquidity-mining/IArbitrumFeeProvider.sol";
+- import "@balancer-labs/v2-interfaces/contracts/liquidity-mining/ISingleRecipientGauge.sol";
+  
+  import "../StakelessGauge.sol";
+  import "./IGatewayRouter.sol";
+--- 14,21 ----
+  
+  pragma solidity ^0.7.0;
+  
++ import "../../interfaces/contracts/liquidity-mining/IArbitrumFeeProvider.sol";
++ import "../../interfaces/contracts/liquidity-mining/ISingleRecipientGauge.sol";
+  
+  import "../StakelessGauge.sol";
+  import "./IGatewayRouter.sol";
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts liquidity-mining/contracts/gauges/arbitrum/ArbitrumRootGaugeFactory.sol.orig liquidity-mining/contracts/gauges/arbitrum/ArbitrumRootGaugeFactory.sol.orig
--- liquidity-mining/contracts/gauges/arbitrum/ArbitrumRootGaugeFactory.sol.orig	1970-01-01 01:00:00.000000000 +0100
+++ liquidity-mining/contracts/gauges/arbitrum/ArbitrumRootGaugeFactory.sol.orig	2022-10-28 09:58:14.000000000 +0200
@@ -0,0 +1,91 @@
+// SPDX-License-Identifier: GPL-3.0-or-later
+// This program is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation, either version 3 of the License, or
+// (at your option) any later version.
+
+// This program is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License
+// along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+pragma solidity ^0.7.0;
+pragma experimental ABIEncoderV2;
+
+import "@balancer-labs/v2-interfaces/contracts/vault/IVault.sol";
+
+import "@balancer-labs/v2-solidity-utils/contracts/helpers/SingletonAuthentication.sol";
+import "@balancer-labs/v2-solidity-utils/contracts/openzeppelin/Clones.sol";
+
+import "../BaseGaugeFactory.sol";
+import "./ArbitrumRootGauge.sol";
+
+contract ArbitrumRootGaugeFactory is IArbitrumFeeProvider, BaseGaugeFactory, SingletonAuthentication {
+    uint64 private _gasLimit;
+    uint64 private _gasPrice;
+    uint64 private _maxSubmissionCost;
+
+    event ArbitrumFeesModified(uint256 gasLimit, uint256 gasPrice, uint256 maxSubmissionCost);
+
+    constructor(
+        IVault vault,
+        IBalancerMinter minter,
+        IGatewayRouter gatewayRouter,
+        uint64 gasLimit,
+        uint64 gasPrice,
+        uint64 maxSubmissionCost
+    ) BaseGaugeFactory(new ArbitrumRootGauge(minter, gatewayRouter)) SingletonAuthentication(vault) {
+        _gasLimit = gasLimit;
+        _gasPrice = gasPrice;
+        _maxSubmissionCost = maxSubmissionCost;
+    }
+
+    /**
+     * @notice Set the fees for the Arbitrum side of the bridging transaction
+     */
+    function getArbitrumFees()
+        external
+        view
+        override
+        returns (
+            uint256 gasLimit,
+            uint256 gasPrice,
+            uint256 maxSubmissionCost
+        )
+    {
+        gasLimit = _gasLimit;
+        gasPrice = _gasPrice;
+        maxSubmissionCost = _maxSubmissionCost;
+    }
+
+    /**
+     * @notice Deploys a new gauge which bridges all of its BAL allowance to a single recipient on Arbitrum.
+     * @dev Care must be taken to ensure that gauges deployed from this factory are
+     * suitable before they are added to the GaugeController.
+     * @param recipient The address to receive BAL minted from the gauge
+     * @param relativeWeightCap The relative weight cap for the created gauge
+     * @return The address of the deployed gauge
+     */
+    function create(address recipient, uint256 relativeWeightCap) external override returns (address) {
+        address gauge = _create();
+        ArbitrumRootGauge(gauge).initialize(recipient, relativeWeightCap);
+        return gauge;
+    }
+
+    /**
+     * @notice Set the fees for the Arbitrum side of the bridging transaction
+     */
+    function setArbitrumFees(
+        uint64 gasLimit,
+        uint64 gasPrice,
+        uint64 maxSubmissionCost
+    ) external override authenticate {
+        _gasLimit = gasLimit;
+        _gasPrice = gasPrice;
+        _maxSubmissionCost = maxSubmissionCost;
+        emit ArbitrumFeesModified(gasLimit, gasPrice, maxSubmissionCost);
+    }
+}
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts liquidity-mining/contracts/gauges/arbitrum/ArbitrumRootGaugeFactory.sol.rej liquidity-mining/contracts/gauges/arbitrum/ArbitrumRootGaugeFactory.sol.rej
--- liquidity-mining/contracts/gauges/arbitrum/ArbitrumRootGaugeFactory.sol.rej	1970-01-01 01:00:00.000000000 +0100
+++ liquidity-mining/contracts/gauges/arbitrum/ArbitrumRootGaugeFactory.sol.rej	2022-10-28 09:58:16.000000000 +0200
@@ -0,0 +1,25 @@
+***************
+*** 15,25 ****
+  pragma solidity ^0.7.0;
+  pragma experimental ABIEncoderV2;
+  
+- import "@balancer-labs/v2-interfaces/contracts/liquidity-mining/ILiquidityGaugeFactory.sol";
+- import "@balancer-labs/v2-interfaces/contracts/vault/IVault.sol";
+  
+- import "@balancer-labs/v2-solidity-utils/contracts/helpers/SingletonAuthentication.sol";
+- import "@balancer-labs/v2-solidity-utils/contracts/openzeppelin/Clones.sol";
+  
+  import "./ArbitrumRootGauge.sol";
+  
+--- 15,25 ----
+  pragma solidity ^0.7.0;
+  pragma experimental ABIEncoderV2;
+  
++ import "../../interfaces/contracts/liquidity-mining/ILiquidityGaugeFactory.sol";
++ import "../../interfaces/contracts/vault/IVault.sol";
+  
++ import "../../solidity-utils/contracts/helpers/SingletonAuthentication.sol";
++ import "../../solidity-utils/contracts/openzeppelin/Clones.sol";
+  
+  import "./ArbitrumRootGauge.sol";
+  
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts liquidity-mining/contracts/gauges/arbitrum/IGatewayRouter.sol liquidity-mining/contracts/gauges/arbitrum/IGatewayRouter.sol
--- liquidity-mining/contracts/gauges/arbitrum/IGatewayRouter.sol	2022-10-03 09:35:45.000000000 +0200
+++ liquidity-mining/contracts/gauges/arbitrum/IGatewayRouter.sol	2022-10-28 09:58:16.000000000 +0200
@@ -14,7 +14,7 @@
 
 pragma solidity ^0.7.0;
 
-import "@balancer-labs/v2-interfaces/contracts/solidity-utils/openzeppelin/IERC20.sol";
+import "../../interfaces/contracts/solidity-utils/openzeppelin/IERC20.sol";
 
 interface IGatewayRouter {
     function outboundTransfer(
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts liquidity-mining/contracts/gauges/ethereum/LiquidityGaugeFactory.sol.orig liquidity-mining/contracts/gauges/ethereum/LiquidityGaugeFactory.sol.orig
--- liquidity-mining/contracts/gauges/ethereum/LiquidityGaugeFactory.sol.orig	1970-01-01 01:00:00.000000000 +0100
+++ liquidity-mining/contracts/gauges/ethereum/LiquidityGaugeFactory.sol.orig	2022-10-28 09:58:14.000000000 +0200
@@ -0,0 +1,48 @@
+// SPDX-License-Identifier: GPL-3.0-or-later
+// This program is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation, either version 3 of the License, or
+// (at your option) any later version.
+
+// This program is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License
+// along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+pragma solidity ^0.7.0;
+pragma experimental ABIEncoderV2;
+
+import "@balancer-labs/v2-interfaces/contracts/liquidity-mining/IBaseGaugeFactory.sol";
+import "@balancer-labs/v2-interfaces/contracts/liquidity-mining/IStakingLiquidityGauge.sol";
+
+import "@balancer-labs/v2-solidity-utils/contracts/openzeppelin/Clones.sol";
+
+import "../BaseGaugeFactory.sol";
+
+contract LiquidityGaugeFactory is BaseGaugeFactory {
+    constructor(IStakingLiquidityGauge gauge) BaseGaugeFactory(gauge) {
+        // solhint-disable-previous-line no-empty-blocks
+    }
+
+    /**
+     * @notice Deploys a new gauge for a Balancer pool.
+     * @dev As anyone can register arbitrary Balancer pools with the Vault,
+     * it's impossible to prove onchain that `pool` is a "valid" deployment.
+     *
+     * Care must be taken to ensure that gauges deployed from this factory are
+     * suitable before they are added to the GaugeController.
+     *
+     * It is possible to deploy multiple gauges for a single pool.
+     * @param pool The address of the pool for which to deploy a gauge
+     * @param relativeWeightCap The relative weight cap for the created gauge
+     * @return The address of the deployed gauge
+     */
+    function create(address pool, uint256 relativeWeightCap) external override returns (address) {
+        address gauge = _create();
+        IStakingLiquidityGauge(gauge).initialize(pool, relativeWeightCap);
+        return gauge;
+    }
+}
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts liquidity-mining/contracts/gauges/ethereum/LiquidityGaugeFactory.sol.rej liquidity-mining/contracts/gauges/ethereum/LiquidityGaugeFactory.sol.rej
--- liquidity-mining/contracts/gauges/ethereum/LiquidityGaugeFactory.sol.rej	1970-01-01 01:00:00.000000000 +0100
+++ liquidity-mining/contracts/gauges/ethereum/LiquidityGaugeFactory.sol.rej	2022-10-28 09:58:16.000000000 +0200
@@ -0,0 +1,23 @@
+***************
+*** 15,24 ****
+  pragma solidity ^0.7.0;
+  pragma experimental ABIEncoderV2;
+  
+- import "@balancer-labs/v2-interfaces/contracts/liquidity-mining/IStakingLiquidityGauge.sol";
+- import "@balancer-labs/v2-interfaces/contracts/liquidity-mining/ILiquidityGaugeFactory.sol";
+  
+- import "@balancer-labs/v2-solidity-utils/contracts/openzeppelin/Clones.sol";
+  
+  contract LiquidityGaugeFactory is ILiquidityGaugeFactory {
+      ILiquidityGauge private immutable _gaugeImplementation;
+--- 15,24 ----
+  pragma solidity ^0.7.0;
+  pragma experimental ABIEncoderV2;
+  
++ import "../../interfaces/contracts/liquidity-mining/IStakingLiquidityGauge.sol";
++ import "../../interfaces/contracts/liquidity-mining/ILiquidityGaugeFactory.sol";
+  
++ import "../../solidity-utils/contracts/openzeppelin/Clones.sol";
+  
+  contract LiquidityGaugeFactory is ILiquidityGaugeFactory {
+      ILiquidityGauge private immutable _gaugeImplementation;
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts liquidity-mining/contracts/gauges/ethereum/SingleRecipientGauge.sol.orig liquidity-mining/contracts/gauges/ethereum/SingleRecipientGauge.sol.orig
--- liquidity-mining/contracts/gauges/ethereum/SingleRecipientGauge.sol.orig	1970-01-01 01:00:00.000000000 +0100
+++ liquidity-mining/contracts/gauges/ethereum/SingleRecipientGauge.sol.orig	2022-10-28 09:58:14.000000000 +0200
@@ -0,0 +1,44 @@
+// SPDX-License-Identifier: GPL-3.0-or-later
+// This program is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation, either version 3 of the License, or
+// (at your option) any later version.
+
+// This program is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License
+// along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+pragma solidity ^0.7.0;
+
+import "@balancer-labs/v2-solidity-utils/contracts/openzeppelin/SafeERC20.sol";
+
+import "../StakelessGauge.sol";
+
+contract SingleRecipientGauge is StakelessGauge {
+    using SafeERC20 for IERC20;
+
+    address private _recipient;
+
+    constructor(IBalancerMinter minter) StakelessGauge(minter) {
+        // solhint-disable-previous-line no-empty-blocks
+    }
+
+    function initialize(address recipient, uint256 relativeWeightCap) external {
+        // This will revert in all calls except the first one
+        __StakelessGauge_init(relativeWeightCap);
+
+        _recipient = recipient;
+    }
+
+    function getRecipient() external view override returns (address) {
+        return _recipient;
+    }
+
+    function _postMintAction(uint256 mintAmount) internal override {
+        _balToken.safeTransfer(_recipient, mintAmount);
+    }
+}
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts liquidity-mining/contracts/gauges/ethereum/SingleRecipientGauge.sol.rej liquidity-mining/contracts/gauges/ethereum/SingleRecipientGauge.sol.rej
--- liquidity-mining/contracts/gauges/ethereum/SingleRecipientGauge.sol.rej	1970-01-01 01:00:00.000000000 +0100
+++ liquidity-mining/contracts/gauges/ethereum/SingleRecipientGauge.sol.rej	2022-10-28 09:58:16.000000000 +0200
@@ -0,0 +1,21 @@
+***************
+*** 14,22 ****
+  
+  pragma solidity ^0.7.0;
+  
+- import "@balancer-labs/v2-interfaces/contracts/liquidity-mining/ISingleRecipientGauge.sol";
+  
+- import "@balancer-labs/v2-solidity-utils/contracts/openzeppelin/SafeERC20.sol";
+  
+  import "../StakelessGauge.sol";
+  
+--- 14,22 ----
+  
+  pragma solidity ^0.7.0;
+  
++ import "../../interfaces/contracts/liquidity-mining/ISingleRecipientGauge.sol";
+  
++ import "../../solidity-utils/contracts/openzeppelin/SafeERC20.sol";
+  
+  import "../StakelessGauge.sol";
+  
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts liquidity-mining/contracts/gauges/ethereum/SingleRecipientGaugeFactory.sol.orig liquidity-mining/contracts/gauges/ethereum/SingleRecipientGaugeFactory.sol.orig
--- liquidity-mining/contracts/gauges/ethereum/SingleRecipientGaugeFactory.sol.orig	1970-01-01 01:00:00.000000000 +0100
+++ liquidity-mining/contracts/gauges/ethereum/SingleRecipientGaugeFactory.sol.orig	2022-10-28 09:58:14.000000000 +0200
@@ -0,0 +1,43 @@
+// SPDX-License-Identifier: GPL-3.0-or-later
+// This program is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation, either version 3 of the License, or
+// (at your option) any later version.
+
+// This program is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License
+// along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+pragma solidity ^0.7.0;
+pragma experimental ABIEncoderV2;
+
+import "@balancer-labs/v2-interfaces/contracts/liquidity-mining/IStakelessGauge.sol";
+
+import "@balancer-labs/v2-solidity-utils/contracts/openzeppelin/Clones.sol";
+
+import "../BaseGaugeFactory.sol";
+import "./SingleRecipientGauge.sol";
+
+contract SingleRecipientGaugeFactory is BaseGaugeFactory {
+    constructor(IBalancerMinter minter) BaseGaugeFactory(new SingleRecipientGauge(minter)) {
+        // solhint-disable-previous-line no-empty-blocks
+    }
+
+    /**
+     * @notice Deploys a new gauge which sends all of its BAL allowance to a single recipient.
+     * @dev Care must be taken to ensure that gauges deployed from this factory are
+     * suitable before they are added to the GaugeController.
+     * @param recipient The address to receive BAL minted from the gauge
+     * @param relativeWeightCap The relative weight cap for the created gauge
+     * @return The address of the deployed gauge
+     */
+    function create(address recipient, uint256 relativeWeightCap) external override returns (address) {
+        address gauge = _create();
+        SingleRecipientGauge(gauge).initialize(recipient, relativeWeightCap);
+        return gauge;
+    }
+}
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts liquidity-mining/contracts/gauges/ethereum/SingleRecipientGaugeFactory.sol.rej liquidity-mining/contracts/gauges/ethereum/SingleRecipientGaugeFactory.sol.rej
--- liquidity-mining/contracts/gauges/ethereum/SingleRecipientGaugeFactory.sol.rej	1970-01-01 01:00:00.000000000 +0100
+++ liquidity-mining/contracts/gauges/ethereum/SingleRecipientGaugeFactory.sol.rej	2022-10-28 09:58:16.000000000 +0200
@@ -0,0 +1,21 @@
+***************
+*** 15,23 ****
+  pragma solidity ^0.7.0;
+  pragma experimental ABIEncoderV2;
+  
+- import "@balancer-labs/v2-interfaces/contracts/liquidity-mining/ISingleRecipientGaugeFactory.sol";
+  
+- import "@balancer-labs/v2-solidity-utils/contracts/openzeppelin/Clones.sol";
+  
+  import "./SingleRecipientGauge.sol";
+  
+--- 15,23 ----
+  pragma solidity ^0.7.0;
+  pragma experimental ABIEncoderV2;
+  
++ import "../../interfaces/contracts/liquidity-mining/ISingleRecipientGaugeFactory.sol";
+  
++ import "../../solidity-utils/contracts/openzeppelin/Clones.sol";
+  
+  import "./SingleRecipientGauge.sol";
+  
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts liquidity-mining/contracts/gauges/optimism/OptimismRootGauge.sol.orig liquidity-mining/contracts/gauges/optimism/OptimismRootGauge.sol.orig
--- liquidity-mining/contracts/gauges/optimism/OptimismRootGauge.sol.orig	1970-01-01 01:00:00.000000000 +0100
+++ liquidity-mining/contracts/gauges/optimism/OptimismRootGauge.sol.orig	2022-10-28 09:58:14.000000000 +0200
@@ -0,0 +1,85 @@
+// SPDX-License-Identifier: GPL-3.0-or-later
+// This program is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation, either version 3 of the License, or
+// (at your option) any later version.
+
+// This program is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License
+// along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+pragma solidity ^0.7.0;
+
+import "@balancer-labs/v2-interfaces/contracts/liquidity-mining/IOptimismGasLimitProvider.sol";
+import "@balancer-labs/v2-solidity-utils/contracts/openzeppelin/SafeERC20.sol";
+
+import "../StakelessGauge.sol";
+
+interface IL1StandardBridge {
+    function depositERC20To(
+        address _l1Token,
+        address _l2Token,
+        address _to,
+        uint256 _amount,
+        uint32 _l2Gas,
+        bytes calldata _data
+    ) external;
+}
+
+contract OptimismRootGauge is StakelessGauge {
+    using SafeERC20 for IERC20;
+
+    IL1StandardBridge private immutable _optimismL1StandardBridge;
+    address private immutable _optimismBal;
+    IOptimismGasLimitProvider private immutable _factory;
+
+    // This value is kept in storage and not made immutable to allow for this contract to be proxyable
+    address private _recipient;
+
+    constructor(
+        IBalancerMinter minter,
+        IL1StandardBridge optimismL1StandardBridge,
+        address optimismBal
+    ) StakelessGauge(minter) {
+        _optimismL1StandardBridge = optimismL1StandardBridge;
+        _optimismBal = optimismBal;
+        _factory = IOptimismGasLimitProvider(msg.sender);
+    }
+
+    function initialize(address recipient, uint256 relativeWeightCap) external {
+        // This will revert in all calls except the first one
+        __StakelessGauge_init(relativeWeightCap);
+
+        _recipient = recipient;
+    }
+
+    function getRecipient() external view override returns (address) {
+        return _recipient;
+    }
+
+    function getOptimismBridge() external view returns (IL1StandardBridge) {
+        return _optimismL1StandardBridge;
+    }
+
+    function getOptimismBal() external view returns (address) {
+        return _optimismBal;
+    }
+
+    function _postMintAction(uint256 mintAmount) internal override {
+        _balToken.safeApprove(address(_optimismL1StandardBridge), mintAmount);
+
+        // This will transfer BAL to `_recipient` on the Optimism chain
+        _optimismL1StandardBridge.depositERC20To(
+            address(_balToken),
+            _optimismBal,
+            _recipient,
+            mintAmount,
+            _factory.getOptimismGasLimit(),
+            "0x"
+        );
+    }
+}
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts liquidity-mining/contracts/gauges/optimism/OptimismRootGauge.sol.rej liquidity-mining/contracts/gauges/optimism/OptimismRootGauge.sol.rej
--- liquidity-mining/contracts/gauges/optimism/OptimismRootGauge.sol.rej	1970-01-01 01:00:00.000000000 +0100
+++ liquidity-mining/contracts/gauges/optimism/OptimismRootGauge.sol.rej	2022-10-28 09:58:16.000000000 +0200
@@ -0,0 +1,19 @@
+***************
+*** 14,21 ****
+  
+  pragma solidity ^0.7.0;
+  
+- import "@balancer-labs/v2-interfaces/contracts/liquidity-mining/IOptimismGasLimitProvider.sol";
+- import "@balancer-labs/v2-interfaces/contracts/liquidity-mining/ISingleRecipientGauge.sol";
+  
+  import "../StakelessGauge.sol";
+  
+--- 14,21 ----
+  
+  pragma solidity ^0.7.0;
+  
++ import "../../interfaces/contracts/liquidity-mining/IOptimismGasLimitProvider.sol";
++ import "../../interfaces/contracts/liquidity-mining/ISingleRecipientGauge.sol";
+  
+  import "../StakelessGauge.sol";
+  
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts liquidity-mining/contracts/gauges/optimism/OptimismRootGaugeFactory.sol.orig liquidity-mining/contracts/gauges/optimism/OptimismRootGaugeFactory.sol.orig
--- liquidity-mining/contracts/gauges/optimism/OptimismRootGaugeFactory.sol.orig	1970-01-01 01:00:00.000000000 +0100
+++ liquidity-mining/contracts/gauges/optimism/OptimismRootGaugeFactory.sol.orig	2022-10-28 09:58:14.000000000 +0200
@@ -0,0 +1,70 @@
+// SPDX-License-Identifier: GPL-3.0-or-later
+// This program is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation, either version 3 of the License, or
+// (at your option) any later version.
+
+// This program is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License
+// along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+pragma solidity ^0.7.0;
+pragma experimental ABIEncoderV2;
+
+import "@balancer-labs/v2-solidity-utils/contracts/helpers/SingletonAuthentication.sol";
+import "@balancer-labs/v2-solidity-utils/contracts/openzeppelin/Clones.sol";
+
+import "../BaseGaugeFactory.sol";
+import "./OptimismRootGauge.sol";
+
+contract OptimismRootGaugeFactory is IOptimismGasLimitProvider, BaseGaugeFactory, SingletonAuthentication {
+    uint32 private _gasLimit;
+
+    event OptimismGasLimitModified(uint256 gasLimit);
+
+    constructor(
+        IVault vault,
+        IBalancerMinter minter,
+        IL1StandardBridge optimismL1StandardBridge,
+        address optimismBal,
+        uint32 gasLimit
+    )
+        BaseGaugeFactory(new OptimismRootGauge(minter, optimismL1StandardBridge, optimismBal))
+        SingletonAuthentication(vault)
+    {
+        _gasLimit = gasLimit;
+    }
+
+    /**
+     * @notice Returns the gas limit for the Optimism side of the bridging transaction
+     */
+    function getOptimismGasLimit() external view override returns (uint32) {
+        return _gasLimit;
+    }
+
+    /**
+     * @notice Deploys a new gauge which bridges all of its BAL allowance to a single recipient on Optimism.
+     * @dev Care must be taken to ensure that gauges deployed from this factory are
+     * suitable before they are added to the GaugeController.
+     * @param recipient The address to receive BAL minted from the gauge
+     * @param relativeWeightCap The relative weight cap for the created gauge
+     * @return The address of the deployed gauge
+     */
+    function create(address recipient, uint256 relativeWeightCap) external override returns (address) {
+        address gauge = _create();
+        OptimismRootGauge(gauge).initialize(recipient, relativeWeightCap);
+        return gauge;
+    }
+
+    /**
+     * @notice Set the gas limit for the Optimism side of the bridging transaction
+     */
+    function setOptimismGasLimit(uint32 gasLimit) external override authenticate {
+        _gasLimit = gasLimit;
+        emit OptimismGasLimitModified(gasLimit);
+    }
+}
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts liquidity-mining/contracts/gauges/optimism/OptimismRootGaugeFactory.sol.rej liquidity-mining/contracts/gauges/optimism/OptimismRootGaugeFactory.sol.rej
--- liquidity-mining/contracts/gauges/optimism/OptimismRootGaugeFactory.sol.rej	1970-01-01 01:00:00.000000000 +0100
+++ liquidity-mining/contracts/gauges/optimism/OptimismRootGaugeFactory.sol.rej	2022-10-28 09:58:16.000000000 +0200
@@ -0,0 +1,23 @@
+***************
+*** 15,24 ****
+  pragma solidity ^0.7.0;
+  pragma experimental ABIEncoderV2;
+  
+- import "@balancer-labs/v2-interfaces/contracts/liquidity-mining/ISingleRecipientGaugeFactory.sol";
+  
+- import "@balancer-labs/v2-solidity-utils/contracts/helpers/SingletonAuthentication.sol";
+- import "@balancer-labs/v2-solidity-utils/contracts/openzeppelin/Clones.sol";
+  
+  import "./OptimismRootGauge.sol";
+  
+--- 15,24 ----
+  pragma solidity ^0.7.0;
+  pragma experimental ABIEncoderV2;
+  
++ import "../../interfaces/contracts/liquidity-mining/ISingleRecipientGaugeFactory.sol";
+  
++ import "../../solidity-utils/contracts/helpers/SingletonAuthentication.sol";
++ import "../../solidity-utils/contracts/openzeppelin/Clones.sol";
+  
+  import "./OptimismRootGauge.sol";
+  
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts liquidity-mining/contracts/gauges/polygon/PolygonRootGauge.sol.orig liquidity-mining/contracts/gauges/polygon/PolygonRootGauge.sol.orig
--- liquidity-mining/contracts/gauges/polygon/PolygonRootGauge.sol.orig	1970-01-01 01:00:00.000000000 +0100
+++ liquidity-mining/contracts/gauges/polygon/PolygonRootGauge.sol.orig	2022-10-28 09:58:14.000000000 +0200
@@ -0,0 +1,73 @@
+// SPDX-License-Identifier: GPL-3.0-or-later
+// This program is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation, either version 3 of the License, or
+// (at your option) any later version.
+
+// This program is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License
+// along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+pragma solidity ^0.7.0;
+
+import "@balancer-labs/v2-solidity-utils/contracts/openzeppelin/SafeERC20.sol";
+
+import "../StakelessGauge.sol";
+
+interface IPolygonRootChainManager {
+    function depositFor(
+        address user,
+        IERC20 token,
+        bytes calldata depositData
+    ) external;
+}
+
+contract PolygonRootGauge is StakelessGauge {
+    using SafeERC20 for IERC20;
+
+    IPolygonRootChainManager private immutable _polygonRootChainManager;
+    address private immutable _polygonERC20Predicate;
+
+    // This value is kept in storage and not made immutable to allow for this contract to be proxyable
+    address private _recipient;
+
+    constructor(
+        IBalancerMinter minter,
+        IPolygonRootChainManager polygonRootChainManager,
+        address polygonERC20Predicate
+    ) StakelessGauge(minter) {
+        _polygonRootChainManager = polygonRootChainManager;
+        _polygonERC20Predicate = polygonERC20Predicate;
+    }
+
+    function initialize(address recipient, uint256 relativeWeightCap) external {
+        // This will revert in all calls except the first one
+        __StakelessGauge_init(relativeWeightCap);
+
+        _recipient = recipient;
+    }
+
+    function getRecipient() external view override returns (address) {
+        return _recipient;
+    }
+
+    function getPolygonBridge() external view returns (IPolygonRootChainManager) {
+        return _polygonRootChainManager;
+    }
+
+    function getPolygonERC20Predicate() external view returns (address) {
+        return _polygonERC20Predicate;
+    }
+
+    function _postMintAction(uint256 mintAmount) internal override {
+        // Token needs to be approved on the predicate NOT the main bridge contract
+        _balToken.safeApprove(_polygonERC20Predicate, mintAmount);
+
+        // This will transfer BAL to `_recipient` on the Polygon chain
+        _polygonRootChainManager.depositFor(_recipient, _balToken, abi.encode(mintAmount));
+    }
+}
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts liquidity-mining/contracts/gauges/polygon/PolygonRootGauge.sol.rej liquidity-mining/contracts/gauges/polygon/PolygonRootGauge.sol.rej
--- liquidity-mining/contracts/gauges/polygon/PolygonRootGauge.sol.rej	1970-01-01 01:00:00.000000000 +0100
+++ liquidity-mining/contracts/gauges/polygon/PolygonRootGauge.sol.rej	2022-10-28 09:58:16.000000000 +0200
@@ -0,0 +1,17 @@
+***************
+*** 14,20 ****
+  
+  pragma solidity ^0.7.0;
+  
+- import "@balancer-labs/v2-interfaces/contracts/liquidity-mining/ISingleRecipientGauge.sol";
+  
+  import "../StakelessGauge.sol";
+  
+--- 14,20 ----
+  
+  pragma solidity ^0.7.0;
+  
++ import "../../interfaces/contracts/liquidity-mining/ISingleRecipientGauge.sol";
+  
+  import "../StakelessGauge.sol";
+  
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts liquidity-mining/contracts/gauges/polygon/PolygonRootGaugeFactory.sol.orig liquidity-mining/contracts/gauges/polygon/PolygonRootGaugeFactory.sol.orig
--- liquidity-mining/contracts/gauges/polygon/PolygonRootGaugeFactory.sol.orig	1970-01-01 01:00:00.000000000 +0100
+++ liquidity-mining/contracts/gauges/polygon/PolygonRootGaugeFactory.sol.orig	2022-10-28 09:58:14.000000000 +0200
@@ -0,0 +1,45 @@
+// SPDX-License-Identifier: GPL-3.0-or-later
+// This program is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation, either version 3 of the License, or
+// (at your option) any later version.
+
+// This program is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License
+// along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+pragma solidity ^0.7.0;
+pragma experimental ABIEncoderV2;
+
+import "@balancer-labs/v2-solidity-utils/contracts/openzeppelin/Clones.sol";
+
+import "../BaseGaugeFactory.sol";
+import "./PolygonRootGauge.sol";
+
+contract PolygonRootGaugeFactory is BaseGaugeFactory {
+    constructor(
+        IBalancerMinter minter,
+        IPolygonRootChainManager polygonRootChainManager,
+        address polygonERC20Predicate
+    ) BaseGaugeFactory(new PolygonRootGauge(minter, polygonRootChainManager, polygonERC20Predicate)) {
+        // solhint-disable-previous-line no-empty-blocks
+    }
+
+    /**
+     * @notice Deploys a new gauge which bridges all of its BAL allowance to a single recipient on Polygon.
+     * @dev Care must be taken to ensure that gauges deployed from this factory are
+     * suitable before they are added to the GaugeController.
+     * @param recipient The address to receive BAL minted from the gauge
+     * @param relativeWeightCap The relative weight cap for the created gauge
+     * @return The address of the deployed gauge
+     */
+    function create(address recipient, uint256 relativeWeightCap) external override returns (address) {
+        address gauge = _create();
+        PolygonRootGauge(gauge).initialize(recipient, relativeWeightCap);
+        return gauge;
+    }
+}
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts liquidity-mining/contracts/gauges/polygon/PolygonRootGaugeFactory.sol.rej liquidity-mining/contracts/gauges/polygon/PolygonRootGaugeFactory.sol.rej
--- liquidity-mining/contracts/gauges/polygon/PolygonRootGaugeFactory.sol.rej	1970-01-01 01:00:00.000000000 +0100
+++ liquidity-mining/contracts/gauges/polygon/PolygonRootGaugeFactory.sol.rej	2022-10-28 09:58:16.000000000 +0200
@@ -0,0 +1,21 @@
+***************
+*** 15,23 ****
+  pragma solidity ^0.7.0;
+  pragma experimental ABIEncoderV2;
+  
+- import "@balancer-labs/v2-interfaces/contracts/liquidity-mining/ISingleRecipientGaugeFactory.sol";
+  
+- import "@balancer-labs/v2-solidity-utils/contracts/openzeppelin/Clones.sol";
+  
+  import "./PolygonRootGauge.sol";
+  
+--- 15,23 ----
+  pragma solidity ^0.7.0;
+  pragma experimental ABIEncoderV2;
+  
++ import "../../interfaces/contracts/liquidity-mining/ISingleRecipientGaugeFactory.sol";
+  
++ import "../../solidity-utils/contracts/openzeppelin/Clones.sol";
+  
+  import "./PolygonRootGauge.sol";
+  
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts liquidity-mining/contracts/test/MockGaugeController.sol liquidity-mining/contracts/test/MockGaugeController.sol
--- liquidity-mining/contracts/test/MockGaugeController.sol	2022-10-28 09:21:26.000000000 +0200
+++ liquidity-mining/contracts/test/MockGaugeController.sol	2022-10-28 09:58:16.000000000 +0200
@@ -14,7 +14,7 @@
 
 pragma solidity ^0.7.0;
 
-import "@balancer-labs/v2-interfaces/contracts/liquidity-mining/IGaugeController.sol";
+import "../../interfaces/contracts/liquidity-mining/IGaugeController.sol";
 
 // For compatibility, we're keeping the same function names as in the original Curve code, including the mixed-case
 // naming convention.
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts liquidity-mining/contracts/test/MockLiquidityGaugeFactory.sol.orig liquidity-mining/contracts/test/MockLiquidityGaugeFactory.sol.orig
--- liquidity-mining/contracts/test/MockLiquidityGaugeFactory.sol.orig	1970-01-01 01:00:00.000000000 +0100
+++ liquidity-mining/contracts/test/MockLiquidityGaugeFactory.sol.orig	2022-10-28 09:58:14.000000000 +0200
@@ -0,0 +1,35 @@
+// SPDX-License-Identifier: GPL-3.0-or-later
+// This program is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation, either version 3 of the License, or
+// (at your option) any later version.
+
+// This program is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License
+// along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+pragma solidity ^0.7.0;
+pragma experimental ABIEncoderV2;
+
+import "@balancer-labs/v2-solidity-utils/contracts/openzeppelin/Clones.sol";
+
+import "../gauges/BaseGaugeFactory.sol";
+import "./MockLiquidityGauge.sol";
+
+contract MockLiquidityGaugeFactory is BaseGaugeFactory {
+    constructor(MockLiquidityGauge gaugeImplementation) BaseGaugeFactory(gaugeImplementation) {
+        // solhint-disable-previous-line no-empty-blocks
+    }
+
+    function create(address pool, uint256 relativeWeightCap) external override returns (address) {
+        address gauge = _create();
+
+        MockLiquidityGauge(gauge).initialize(pool, relativeWeightCap);
+
+        return gauge;
+    }
+}
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts liquidity-mining/contracts/test/MockLiquidityGaugeFactory.sol.rej liquidity-mining/contracts/test/MockLiquidityGaugeFactory.sol.rej
--- liquidity-mining/contracts/test/MockLiquidityGaugeFactory.sol.rej	1970-01-01 01:00:00.000000000 +0100
+++ liquidity-mining/contracts/test/MockLiquidityGaugeFactory.sol.rej	2022-10-28 09:58:16.000000000 +0200
@@ -0,0 +1,25 @@
+***************
+*** 15,25 ****
+  pragma solidity ^0.7.0;
+  pragma experimental ABIEncoderV2;
+  
+- import "@balancer-labs/v2-interfaces/contracts/liquidity-mining/ILiquidityGaugeFactory.sol";
+- import "@balancer-labs/v2-interfaces/contracts/vault/IVault.sol";
+  
+- import "@balancer-labs/v2-solidity-utils/contracts/helpers/Authentication.sol";
+- import "@balancer-labs/v2-solidity-utils/contracts/openzeppelin/Clones.sol";
+  
+  import "./MockLiquidityGauge.sol";
+  
+--- 15,25 ----
+  pragma solidity ^0.7.0;
+  pragma experimental ABIEncoderV2;
+  
++ import "../../interfaces/contracts/liquidity-mining/ILiquidityGaugeFactory.sol";
++ import "../../interfaces/contracts/vault/IVault.sol";
+  
++ import "../../solidity-utils/contracts/helpers/Authentication.sol";
++ import "../../solidity-utils/contracts/openzeppelin/Clones.sol";
+  
+  import "./MockLiquidityGauge.sol";
+  
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts liquidity-mining/contracts/test/MockRewardTokenDistributor.sol liquidity-mining/contracts/test/MockRewardTokenDistributor.sol
--- liquidity-mining/contracts/test/MockRewardTokenDistributor.sol	2022-10-28 09:21:26.000000000 +0200
+++ liquidity-mining/contracts/test/MockRewardTokenDistributor.sol	2022-10-28 09:58:16.000000000 +0200
@@ -17,8 +17,8 @@
 
 import "@balancer-labs/v2-solidity-utils/contracts/openzeppelin/SafeERC20.sol";
 
-import "@balancer-labs/v2-interfaces/contracts/solidity-utils/openzeppelin/IERC20.sol";
-import "@balancer-labs/v2-interfaces/contracts/liquidity-mining/IRewardTokenDistributor.sol";
+import "../../interfaces/contracts/solidity-utils/openzeppelin/IERC20.sol";
+import "../../interfaces/contracts/liquidity-mining/IRewardTokenDistributor.sol";
 
 // solhint-disable func-name-mixedcase, var-name-mixedcase, not-rely-on-time
 
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts liquidity-mining/contracts/test/MockRewardTokenDistributor.sol.orig liquidity-mining/contracts/test/MockRewardTokenDistributor.sol.orig
--- liquidity-mining/contracts/test/MockRewardTokenDistributor.sol.orig	1970-01-01 01:00:00.000000000 +0100
+++ liquidity-mining/contracts/test/MockRewardTokenDistributor.sol.orig	2022-10-28 09:58:14.000000000 +0200
@@ -0,0 +1,80 @@
+// SPDX-License-Identifier: GPL-3.0-or-later
+// This program is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation, either version 3 of the License, or
+// (at your option) any later version.
+
+// This program is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License
+// along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+pragma solidity ^0.7.0;
+pragma experimental ABIEncoderV2;
+
+import "@balancer-labs/v2-solidity-utils/contracts/openzeppelin/SafeERC20.sol";
+
+import "@balancer-labs/v2-interfaces/contracts/solidity-utils/openzeppelin/IERC20.sol";
+import "@balancer-labs/v2-interfaces/contracts/liquidity-mining/IRewardTokenDistributor.sol";
+
+// solhint-disable func-name-mixedcase, var-name-mixedcase, not-rely-on-time
+
+/**
+ * @dev This contract is designed to mock LiquidityGaugeV5's interface for distributing external tokens.
+ */
+contract MockRewardTokenDistributor is IRewardTokenDistributor {
+    using SafeERC20 for IERC20;
+
+    uint256 private _rewardCount;
+    IERC20[8] private _rewardTokens;
+    mapping(IERC20 => Reward) private _rewardData;
+
+    function reward_tokens(uint256 index) external view override returns (IERC20) {
+        return _rewardTokens[index];
+    }
+
+    function reward_data(IERC20 token) external view override returns (Reward memory) {
+        return _rewardData[token];
+    }
+
+    function add_reward(IERC20 rewardToken, address distributor) external override {
+        _rewardTokens[_rewardCount] = rewardToken;
+        _rewardData[rewardToken] = Reward({
+            token: rewardToken,
+            distributor: distributor,
+            period_finish: 0,
+            rate: 0,
+            last_update: block.timestamp,
+            integral: 0
+        });
+
+        _rewardCount += 1;
+        require(_rewardCount < 8, "Too many reward tokens");
+    }
+
+    function set_reward_distributor(IERC20 rewardToken, address distributor) external override {
+        _rewardData[rewardToken].distributor = distributor;
+    }
+
+    function deposit_reward_token(IERC20 rewardToken, uint256 amount) external override {
+        require(_rewardData[rewardToken].distributor == msg.sender, "Only callable by reward distributor");
+        rewardToken.safeTransferFrom(msg.sender, address(this), amount);
+
+        // We don't care about the rest of the update.
+    }
+
+    function claim_rewards(address user) external override {
+        // solhint-disable-previous-line no-empty-blocks
+    }
+
+    function claimable_reward(address, address) external pure override returns (uint256) {
+        return 0;
+    }
+
+    function claimable_reward_write(address, address) external pure override returns (uint256) {
+        return 0;
+    }
+}
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts liquidity-mining/contracts/test/TestAccessControl.sol liquidity-mining/contracts/test/TestAccessControl.sol
--- liquidity-mining/contracts/test/TestAccessControl.sol	2022-10-03 09:35:45.000000000 +0200
+++ liquidity-mining/contracts/test/TestAccessControl.sol	2022-10-28 09:58:16.000000000 +0200
@@ -2,8 +2,8 @@
 
 pragma solidity ^0.7.0;
 
-import "@balancer-labs/v2-solidity-utils/contracts/openzeppelin/EnumerableSet.sol";
-import "@balancer-labs/v2-solidity-utils/contracts/openzeppelin/Address.sol";
+import "../../solidity-utils/contracts/openzeppelin/EnumerableSet.sol";
+import "../../solidity-utils/contracts/openzeppelin/Address.sol";
 
 // This contract maintains the old AccessControl behaviour which is used by BalancerGovernanceToken in production
 
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts liquidity-mining/contracts/test/TestBalancerToken.sol liquidity-mining/contracts/test/TestBalancerToken.sol
--- liquidity-mining/contracts/test/TestBalancerToken.sol	2022-10-03 09:35:45.000000000 +0200
+++ liquidity-mining/contracts/test/TestBalancerToken.sol	2022-10-28 09:58:16.000000000 +0200
@@ -14,9 +14,9 @@
 
 pragma solidity ^0.7.0;
 
-import "@balancer-labs/v2-solidity-utils/contracts/openzeppelin/ERC20.sol";
-import "@balancer-labs/v2-solidity-utils/contracts/openzeppelin/ERC20Burnable.sol";
-import "@balancer-labs/v2-solidity-utils/contracts/openzeppelin/ERC20Permit.sol";
+import "../../solidity-utils/contracts/openzeppelin/ERC20.sol";
+import "../../solidity-utils/contracts/openzeppelin/ERC20Burnable.sol";
+import "../../solidity-utils/contracts/openzeppelin/ERC20Permit.sol";
 
 import "./TestAccessControl.sol";
 
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts pool-linear/contracts/LinearMath.sol pool-linear/contracts/LinearMath.sol
--- pool-linear/contracts/LinearMath.sol	2022-10-03 09:35:45.000000000 +0200
+++ pool-linear/contracts/LinearMath.sol	2022-10-28 09:58:16.000000000 +0200
@@ -14,8 +14,8 @@
 
 pragma solidity ^0.7.0;
 
-import "@balancer-labs/v2-solidity-utils/contracts/math/FixedPoint.sol";
-import "@balancer-labs/v2-solidity-utils/contracts/math/Math.sol";
+import "../../solidity-utils/contracts/math/FixedPoint.sol";
+import "../../solidity-utils/contracts/math/Math.sol";
 
 // These functions start with an underscore, as if they were part of a contract and not a library. At some point this
 // should be fixed.
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts pool-linear/contracts/LinearPool.sol.orig pool-linear/contracts/LinearPool.sol.orig
--- pool-linear/contracts/LinearPool.sol.orig	1970-01-01 01:00:00.000000000 +0100
+++ pool-linear/contracts/LinearPool.sol.orig	2022-10-28 09:58:13.000000000 +0200
@@ -0,0 +1,708 @@
+// SPDX-License-Identifier: GPL-3.0-or-later
+// This program is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation, either version 3 of the License, or
+// (at your option) any later version.
+
+// This program is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License
+// along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+pragma solidity ^0.7.0;
+pragma experimental ABIEncoderV2;
+
+import "@balancer-labs/v2-interfaces/contracts/solidity-utils/helpers/BalancerErrors.sol";
+import "@balancer-labs/v2-interfaces/contracts/pool-utils/BasePoolUserData.sol";
+import "@balancer-labs/v2-interfaces/contracts/pool-utils/IRateProvider.sol";
+import "@balancer-labs/v2-interfaces/contracts/pool-linear/ILinearPool.sol";
+import "@balancer-labs/v2-interfaces/contracts/vault/IGeneralPool.sol";
+
+import "@balancer-labs/v2-pool-utils/contracts/BasePool.sol";
+import "@balancer-labs/v2-pool-utils/contracts/rates/PriceRateCache.sol";
+
+import "@balancer-labs/v2-solidity-utils/contracts/helpers/ERC20Helpers.sol";
+import "@balancer-labs/v2-solidity-utils/contracts/math/FixedPoint.sol";
+
+import "./LinearMath.sol";
+
+/**
+ * @dev Linear Pools are designed to hold two assets: "main" and "wrapped" tokens that have an equal value underlying
+ * token (e.g., DAI and waDAI). There must be an external feed available to provide an exact, non-manipulable exchange
+ * rate between the tokens. In particular, any reversible manipulation (e.g. causing the rate to increase and then
+ * decrease) can lead to severe issues and loss of funds.
+ *
+ * The Pool will register three tokens in the Vault however: the two assets and the BPT itself,
+ * so that BPT can be exchanged (effectively joining and exiting) via swaps.
+ *
+ * Despite inheriting from BasePool, much of the basic behavior changes. This Pool does not support regular joins and
+ * exits, as the initial BPT supply is 'preminted' during initialization. No further BPT can be minted, and BPT can
+ * only be burned if governance enables Recovery Mode and LPs use it to exit proportionally.
+ *
+ * Unlike most other Pools, this one does not attempt to create revenue by charging fees: value is derived by holding
+ * the wrapped, yield-bearing asset. However, the 'swap fee percentage' value is still used, albeit with a different
+ * meaning. This Pool attempts to hold a certain amount of "main" tokens, between a lower and upper target value.
+ * The pool charges fees on trades that move the balance outside that range, which are then paid back as incentives to
+ * traders whose swaps return the balance to the desired region.
+ *
+ * The net revenue via fees is expected to be zero: all collected fees are used to pay for this 'rebalancing'.
+ * Accordingly, this Pool does not pay any protocol fees.
+ */
+abstract contract LinearPool is ILinearPool, IGeneralPool, IRateProvider, BasePool {
+    using WordCodec for bytes32;
+    using FixedPoint for uint256;
+    using PriceRateCache for bytes32;
+    using BasePoolUserData for bytes;
+
+    uint256 private constant _TOTAL_TOKENS = 3; // Main token, wrapped token, BPT
+
+    // This is the maximum token amount the Vault can hold. In regular operation, the total BPT supply remains constant
+    // and equal to _INITIAL_BPT_SUPPLY, but most of it remains in the Pool, waiting to be exchanged for tokens. The
+    // actual amount of BPT in circulation is the total supply minus the amount held by the Pool, and is known as the
+    // 'virtual supply'.
+    // The total supply can only change if recovery mode is enabled and recovery mode exits are processed, resulting in
+    // BPT being burned. This BPT can never be minted again, so it is technically possible for the preminted supply to
+    // run out, but a) this process is controlled by Governance via enabling and disabling recovery mode, and b) the
+    // initial supply is so large that it would take a huge number of interactions to acquire sufficient tokens to join
+    // the Pool, and then burn the acquired BPT, resulting in prohibitively large gas costs.
+    uint256 private constant _INITIAL_BPT_SUPPLY = 2**(112) - 1;
+
+    IERC20 private immutable _mainToken;
+    IERC20 private immutable _wrappedToken;
+
+    // The indices of each token when registered, which can then be used to access the balances array.
+    uint256 private immutable _bptIndex;
+    uint256 private immutable _mainIndex;
+    uint256 private immutable _wrappedIndex;
+
+    // Both BPT and the main token have a regular, constant scaling factor (equal to FixedPoint.ONE for BPT, and
+    // dependent on the number of decimals for the main token). However, the wrapped token's scaling factor has two
+    // components: the usual token decimal scaling factor, and an externally provided rate used to convert wrapped
+    // tokens to an equivalent main token amount. This external rate is expected to be ever increasing, reflecting the
+    // fact that the wrapped token appreciates in value over time (e.g. because it is accruing interest).
+    uint256 private immutable _scalingFactorMainToken;
+    uint256 private immutable _scalingFactorWrappedToken;
+
+    // The lower and upper targets are in BasePool's misc data field, which has 192 bits available (as it shares the
+    // same storage slot as the swap fee percentage and recovery mode flag, which together take up 64 bits).
+    // We use 64 of these 192 for the targets (32 for each).
+    //
+    // The targets are already scaled by the main token's scaling factor (which makes the token behave as if it had 18
+    // decimals), but we only store the integer part: the targets must be multiplied by 1e18 before being used.
+    // This means the targets' resolution does not include decimal places in the main token (so e.g. a target of 500.1
+    // DAI is impossible). Since targets are expected to be relatively large, this is a non-issue. With 32 bits per
+    // target, we can represent values as high as ~4 billion (2^32).
+    // [        64 bits       |    32 bits   |    32 bits    | 128 bits ]
+    // [       reserved       | upper target |  lower target | reserved ]
+    // [  base pool swap fee  |                  misc data              ]
+    // [ MSB                                                        LSB ]
+
+    uint256 private constant _TARGET_SCALING = 1e18;
+
+    uint256 private constant _TARGET_BITS = 32;
+
+    uint256 private constant _LOWER_TARGET_OFFSET = 32;
+    uint256 private constant _UPPER_TARGET_OFFSET = 64;
+
+    uint256 private constant _MAX_UPPER_TARGET = (2**(32) - 1) * _TARGET_SCALING;
+
+    event TargetsSet(IERC20 indexed token, uint256 lowerTarget, uint256 upperTarget);
+
+    constructor(
+        IVault vault,
+        string memory name,
+        string memory symbol,
+        IERC20 mainToken,
+        IERC20 wrappedToken,
+        uint256 upperTarget,
+        address[] memory assetManagers,
+        uint256 swapFeePercentage,
+        uint256 pauseWindowDuration,
+        uint256 bufferPeriodDuration,
+        address owner
+    )
+        BasePool(
+            vault,
+            IVault.PoolSpecialization.GENERAL,
+            name,
+            symbol,
+            _sortTokens(mainToken, wrappedToken, this),
+            _insertNullBptAssetManager(mainToken, wrappedToken, assetManagers),
+            swapFeePercentage,
+            pauseWindowDuration,
+            bufferPeriodDuration,
+            owner
+        )
+    {
+        // Set tokens
+        _mainToken = mainToken;
+        _wrappedToken = wrappedToken;
+
+        // Set token indexes
+        (uint256 mainIndex, uint256 wrappedIndex, uint256 bptIndex) = _getSortedTokenIndexes(
+            mainToken,
+            wrappedToken,
+            this
+        );
+        _bptIndex = bptIndex;
+        _mainIndex = mainIndex;
+        _wrappedIndex = wrappedIndex;
+
+        // Set scaling factors
+        _scalingFactorMainToken = _computeScalingFactor(mainToken);
+        _scalingFactorWrappedToken = _computeScalingFactor(wrappedToken);
+
+        // Set initial targets. The lower target must be set to zero because initially there are no accumulated fees.
+        // Otherwise the pool would owe fees from the start, which would make the rate manipulable.
+        uint256 lowerTarget = 0;
+        _setTargets(mainToken, lowerTarget, upperTarget);
+    }
+
+    /**
+     * @dev Inserts a zero-valued entry in the `assetManagers` array at the BPT token index, ensuring that BPT is not
+     * managed even if the main or wrapped tokens are.
+     */
+    function _insertNullBptAssetManager(
+        IERC20 mainToken,
+        IERC20 wrappedToken,
+        address[] memory assetManagers
+    ) private view returns (address[] memory) {
+        (, , uint256 bptIndex) = _getSortedTokenIndexes(mainToken, wrappedToken, this);
+
+        address[] memory extendedAssetManagers = new address[](assetManagers.length + 1);
+        for (uint256 i = 0; i < extendedAssetManagers.length; ++i) {
+            if (i < bptIndex) {
+                extendedAssetManagers[i] = assetManagers[i];
+            } else if (i > bptIndex) {
+                extendedAssetManagers[i] = assetManagers[i - 1];
+            } else {
+                extendedAssetManagers[i] = address(0);
+            }
+        }
+
+        return extendedAssetManagers;
+    }
+
+    /**
+     * @notice Return the main token address as an IERC20.
+     */
+    function getMainToken() public view override returns (IERC20) {
+        return _mainToken;
+    }
+
+    /**
+     * @notice Return the wrapped token address as an IERC20.
+     */
+    function getWrappedToken() public view override returns (IERC20) {
+        return _wrappedToken;
+    }
+
+    /**
+     * @notice Return the index of the BPT token.
+     * @dev Note that this is an index into the registered token list (with 3 tokens).
+     */
+    function getBptIndex() public view override returns (uint256) {
+        return _bptIndex;
+    }
+
+    /**
+     * @notice Return the index of the main token.
+     * @dev Note that this is an index into the registered token list, which includes the BPT token.
+     */
+    function getMainIndex() external view override returns (uint256) {
+        return _mainIndex;
+    }
+
+    /**
+     * @notice Return the index of the wrapped token.
+     * @dev Note that this is an index into the registered token list, which includes the BPT token.
+     */
+    function getWrappedIndex() external view override returns (uint256) {
+        return _wrappedIndex;
+    }
+
+    /**
+     * @dev Finishes initialization of the Linear Pool: it is unusable before calling this function as no BPT will have
+     * been minted.
+     *
+     * Since Linear Pools have preminted BPT stored in the Vault, they require an initial join to deposit said BPT as
+     * their balance. Unfortunately, this cannot be performed during construction, as a join involves calling the
+     * `onJoinPool` function on the Pool, and the Pool will not have any code until construction finishes. Therefore,
+     * this must happen in a separate call.
+     *
+     * It is highly recommended to create Linear pools using the LinearPoolFactory, which calls `initialize`
+     * automatically.
+     */
+    function initialize() external {
+        bytes32 poolId = getPoolId();
+        (IERC20[] memory tokens, , ) = getVault().getPoolTokens(poolId);
+
+        // Joins typically involve the Pool receiving tokens in exchange for newly-minted BPT. In this case however, the
+        // Pool will mint the entire BPT supply to itself, and join itself with it.
+        uint256[] memory maxAmountsIn = new uint256[](_TOTAL_TOKENS);
+        maxAmountsIn[_bptIndex] = _INITIAL_BPT_SUPPLY;
+
+        // The first time this executes, it will call `_onInitializePool` (as the BPT supply will be zero). Future calls
+        // will be routed to `_onJoinPool`, which always reverts, meaning `initialize` will only execute once.
+        IVault.JoinPoolRequest memory request = IVault.JoinPoolRequest({
+            assets: _asIAsset(tokens),
+            maxAmountsIn: maxAmountsIn,
+            userData: "",
+            fromInternalBalance: false
+        });
+
+        getVault().joinPool(poolId, address(this), address(this), request);
+    }
+
+    /**
+     * @dev Implementation of onSwap, from IGeneralPool.
+     */
+    function onSwap(
+        SwapRequest memory request,
+        uint256[] memory balances,
+        uint256 indexIn,
+        uint256 indexOut
+    ) external override onlyVault(request.poolId) returns (uint256) {
+        _beforeSwapJoinExit();
+
+        // In most Pools, swaps involve exchanging one token held by the Pool for another. In this case however, since
+        // one of the three tokens is the BPT itself, a swap might also be a join (main/wrapped for BPT) or an exit
+        // (BPT for main/wrapped).
+        // All three swap types (swaps, joins and exits) are fully disabled if the emergency pause is enabled. Under
+        // these circumstances, the Pool should be exited using the regular Vault.exitPool function.
+
+        // Sanity check: this is not entirely necessary as the Vault's interface enforces the indices to be valid, but
+        // the check is cheap to perform.
+        _require(indexIn < _TOTAL_TOKENS && indexOut < _TOTAL_TOKENS, Errors.OUT_OF_BOUNDS);
+
+        // Note that we already know the indices of the main token, wrapped token and BPT, so there is no need to pass
+        // these indices to the inner functions.
+
+        // Upscale balances by the scaling factors (taking into account the wrapped token rate)
+        uint256[] memory scalingFactors = _scalingFactors();
+        _upscaleArray(balances, scalingFactors);
+
+        (uint256 lowerTarget, uint256 upperTarget) = getTargets();
+        LinearMath.Params memory params = LinearMath.Params({
+            fee: getSwapFeePercentage(),
+            lowerTarget: lowerTarget,
+            upperTarget: upperTarget
+        });
+
+        if (request.kind == IVault.SwapKind.GIVEN_IN) {
+            // The amount given is for token in, the amount calculated is for token out
+            request.amount = _upscale(request.amount, scalingFactors[indexIn]);
+            uint256 amountOut = _onSwapGivenIn(request, balances, params);
+
+            // amountOut tokens are exiting the Pool, so we round down.
+            return _downscaleDown(amountOut, scalingFactors[indexOut]);
+        } else {
+            // The amount given is for token out, the amount calculated is for token in
+            request.amount = _upscale(request.amount, scalingFactors[indexOut]);
+            uint256 amountIn = _onSwapGivenOut(request, balances, params);
+
+            // amountIn tokens are entering the Pool, so we round up.
+            return _downscaleUp(amountIn, scalingFactors[indexIn]);
+        }
+    }
+
+    function _onSwapGivenIn(
+        SwapRequest memory request,
+        uint256[] memory balances,
+        LinearMath.Params memory params
+    ) internal view returns (uint256) {
+        if (request.tokenIn == this) {
+            return _swapGivenBptIn(request, balances, params);
+        } else if (request.tokenIn == _mainToken) {
+            return _swapGivenMainIn(request, balances, params);
+        } else if (request.tokenIn == _wrappedToken) {
+            return _swapGivenWrappedIn(request, balances, params);
+        } else {
+            _revert(Errors.INVALID_TOKEN);
+        }
+    }
+
+    function _swapGivenBptIn(
+        SwapRequest memory request,
+        uint256[] memory balances,
+        LinearMath.Params memory params
+    ) internal view returns (uint256) {
+        _require(request.tokenOut == _mainToken || request.tokenOut == _wrappedToken, Errors.INVALID_TOKEN);
+        return
+            (request.tokenOut == _mainToken ? LinearMath._calcMainOutPerBptIn : LinearMath._calcWrappedOutPerBptIn)(
+                request.amount,
+                balances[_mainIndex],
+                balances[_wrappedIndex],
+                _getVirtualSupply(balances[_bptIndex]),
+                params
+            );
+    }
+
+    function _swapGivenMainIn(
+        SwapRequest memory request,
+        uint256[] memory balances,
+        LinearMath.Params memory params
+    ) internal view returns (uint256) {
+        _require(request.tokenOut == _wrappedToken || request.tokenOut == this, Errors.INVALID_TOKEN);
+        return
+            request.tokenOut == this
+                ? LinearMath._calcBptOutPerMainIn(
+                    request.amount,
+                    balances[_mainIndex],
+                    balances[_wrappedIndex],
+                    _getVirtualSupply(balances[_bptIndex]),
+                    params
+                )
+                : LinearMath._calcWrappedOutPerMainIn(request.amount, balances[_mainIndex], params);
+    }
+
+    function _swapGivenWrappedIn(
+        SwapRequest memory request,
+        uint256[] memory balances,
+        LinearMath.Params memory params
+    ) internal view returns (uint256) {
+        _require(request.tokenOut == _mainToken || request.tokenOut == this, Errors.INVALID_TOKEN);
+        return
+            request.tokenOut == this
+                ? LinearMath._calcBptOutPerWrappedIn(
+                    request.amount,
+                    balances[_mainIndex],
+                    balances[_wrappedIndex],
+                    _getVirtualSupply(balances[_bptIndex]),
+                    params
+                )
+                : LinearMath._calcMainOutPerWrappedIn(request.amount, balances[_mainIndex], params);
+    }
+
+    function _onSwapGivenOut(
+        SwapRequest memory request,
+        uint256[] memory balances,
+        LinearMath.Params memory params
+    ) internal view returns (uint256) {
+        if (request.tokenOut == this) {
+            return _swapGivenBptOut(request, balances, params);
+        } else if (request.tokenOut == _mainToken) {
+            return _swapGivenMainOut(request, balances, params);
+        } else if (request.tokenOut == _wrappedToken) {
+            return _swapGivenWrappedOut(request, balances, params);
+        } else {
+            _revert(Errors.INVALID_TOKEN);
+        }
+    }
+
+    function _swapGivenBptOut(
+        SwapRequest memory request,
+        uint256[] memory balances,
+        LinearMath.Params memory params
+    ) internal view returns (uint256) {
+        _require(request.tokenIn == _mainToken || request.tokenIn == _wrappedToken, Errors.INVALID_TOKEN);
+        return
+            (request.tokenIn == _mainToken ? LinearMath._calcMainInPerBptOut : LinearMath._calcWrappedInPerBptOut)(
+                request.amount,
+                balances[_mainIndex],
+                balances[_wrappedIndex],
+                _getVirtualSupply(balances[_bptIndex]),
+                params
+            );
+    }
+
+    function _swapGivenMainOut(
+        SwapRequest memory request,
+        uint256[] memory balances,
+        LinearMath.Params memory params
+    ) internal view returns (uint256) {
+        _require(request.tokenIn == _wrappedToken || request.tokenIn == this, Errors.INVALID_TOKEN);
+        return
+            request.tokenIn == this
+                ? LinearMath._calcBptInPerMainOut(
+                    request.amount,
+                    balances[_mainIndex],
+                    balances[_wrappedIndex],
+                    _getVirtualSupply(balances[_bptIndex]),
+                    params
+                )
+                : LinearMath._calcWrappedInPerMainOut(request.amount, balances[_mainIndex], params);
+    }
+
+    function _swapGivenWrappedOut(
+        SwapRequest memory request,
+        uint256[] memory balances,
+        LinearMath.Params memory params
+    ) internal view returns (uint256) {
+        _require(request.tokenIn == _mainToken || request.tokenIn == this, Errors.INVALID_TOKEN);
+        return
+            request.tokenIn == this
+                ? LinearMath._calcBptInPerWrappedOut(
+                    request.amount,
+                    balances[_mainIndex],
+                    balances[_wrappedIndex],
+                    _getVirtualSupply(balances[_bptIndex]),
+                    params
+                )
+                : LinearMath._calcMainInPerWrappedOut(request.amount, balances[_mainIndex], params);
+    }
+
+    function _onInitializePool(
+        bytes32,
+        address sender,
+        address recipient,
+        uint256[] memory,
+        bytes memory
+    ) internal view override returns (uint256, uint256[] memory) {
+        // Linear Pools can only be initialized by the Pool performing the initial join via the `initialize` function.
+        _require(sender == address(this), Errors.INVALID_INITIALIZATION);
+        _require(recipient == address(this), Errors.INVALID_INITIALIZATION);
+
+        // The full BPT supply will be minted and deposited in the Pool. Note that there is no need to approve the Vault
+        // as it already has infinite BPT allowance.
+        uint256 bptAmountOut = _INITIAL_BPT_SUPPLY;
+
+        uint256[] memory amountsIn = new uint256[](_TOTAL_TOKENS);
+        amountsIn[_bptIndex] = _INITIAL_BPT_SUPPLY;
+
+        return (bptAmountOut, amountsIn);
+    }
+
+    function _onJoinPool(
+        bytes32,
+        address,
+        address,
+        uint256[] memory,
+        uint256,
+        uint256,
+        uint256[] memory,
+        bytes memory
+    ) internal pure override returns (uint256, uint256[] memory) {
+        _revert(Errors.UNHANDLED_BY_LINEAR_POOL);
+    }
+
+    function _onExitPool(
+        bytes32,
+        address,
+        address,
+        uint256[] memory,
+        uint256,
+        uint256,
+        uint256[] memory,
+        bytes memory
+    ) internal pure override returns (uint256, uint256[] memory) {
+        _revert(Errors.UNHANDLED_BY_LINEAR_POOL);
+    }
+
+    function _doRecoveryModeExit(
+        uint256[] memory registeredBalances,
+        uint256,
+        bytes memory userData
+    ) internal view override returns (uint256, uint256[] memory) {
+        uint256 bptAmountIn = userData.recoveryModeExit();
+        uint256[] memory amountsOut = new uint256[](registeredBalances.length);
+
+        uint256 bptIndex = getBptIndex();
+
+        uint256 virtualSupply = _getVirtualSupply(registeredBalances[bptIndex]);
+        uint256 bptRatio = bptAmountIn.divDown(virtualSupply);
+
+        for (uint256 i = 0; i < registeredBalances.length; i++) {
+            amountsOut[i] = i != bptIndex ? registeredBalances[i].mulDown(bptRatio) : 0;
+        }
+
+        return (bptAmountIn, amountsOut);
+    }
+
+    function _getMaxTokens() internal pure override returns (uint256) {
+        return _TOTAL_TOKENS;
+    }
+
+    function _getMinimumBpt() internal pure override returns (uint256) {
+        // Linear Pools don't lock any BPT, as the total supply will already be forever non-zero due to the preminting
+        // mechanism, ensuring initialization only occurs once.
+        return 0;
+    }
+
+    function _getTotalTokens() internal view virtual override returns (uint256) {
+        return _TOTAL_TOKENS;
+    }
+
+    function _scalingFactor(IERC20 token) internal view virtual override returns (uint256) {
+        if (token == _mainToken) {
+            return _scalingFactorMainToken;
+        } else if (token == _wrappedToken) {
+            // The wrapped token's scaling factor is not constant, but increases over time as the wrapped token
+            // increases in value.
+            return _scalingFactorWrappedToken.mulDown(_getWrappedTokenRate());
+        } else if (token == this) {
+            return FixedPoint.ONE;
+        } else {
+            _revert(Errors.INVALID_TOKEN);
+        }
+    }
+
+    function _scalingFactors() internal view virtual override returns (uint256[] memory) {
+        uint256[] memory scalingFactors = new uint256[](_TOTAL_TOKENS);
+
+        // The wrapped token's scaling factor is not constant, but increases over time as the wrapped token increases in
+        // value.
+        scalingFactors[_mainIndex] = _scalingFactorMainToken;
+        scalingFactors[_wrappedIndex] = _scalingFactorWrappedToken.mulDown(_getWrappedTokenRate());
+        scalingFactors[_bptIndex] = FixedPoint.ONE;
+
+        return scalingFactors;
+    }
+
+    // Price rates
+
+    /**
+     * @dev For a Linear Pool, the rate represents the appreciation of BPT with respect to the underlying tokens. This
+     * rate increases slowly as the wrapped token appreciates in value.
+     */
+    function getRate() external view override returns (uint256) {
+        bytes32 poolId = getPoolId();
+        (, uint256[] memory balances, ) = getVault().getPoolTokens(poolId);
+        _upscaleArray(balances, _scalingFactors());
+
+        (uint256 lowerTarget, uint256 upperTarget) = getTargets();
+        LinearMath.Params memory params = LinearMath.Params({
+            fee: getSwapFeePercentage(),
+            lowerTarget: lowerTarget,
+            upperTarget: upperTarget
+        });
+
+        uint256 totalBalance = LinearMath._calcInvariant(
+            LinearMath._toNominal(balances[_mainIndex], params),
+            balances[_wrappedIndex]
+        );
+
+        // Note that we're dividing by the virtual supply, which may be zero (causing this call to revert). However, the
+        // only way for that to happen would be for all LPs to exit the Pool, and nothing prevents new LPs from
+        // joining it later on.
+        return totalBalance.divUp(_getVirtualSupply(balances[_bptIndex]));
+    }
+
+    /**
+     * @notice Return the conversion rate between the wrapped and main tokens.
+     * @dev This is an 18-decimal fixed point value.
+     */
+    function getWrappedTokenRate() external view returns (uint256) {
+        return _getWrappedTokenRate();
+    }
+
+    /**
+     * @dev Should be an 18-decimal fixed point value that represents the value of the wrapped token in terms of the
+     * main token. The final wrapped token scaling factor is this value multiplied by the wrapped token's decimal
+     * scaling factor.
+     */
+    function _getWrappedTokenRate() internal view virtual returns (uint256);
+
+    /**
+     * @notice Return the lower and upper bounds of the zero-fee trading range for the main token balance.
+     */
+    function getTargets() public view override returns (uint256 lowerTarget, uint256 upperTarget) {
+        bytes32 miscData = _getMiscData();
+
+        // Since targets are stored downscaled by _TARGET_SCALING, we undo that when reading them.
+        lowerTarget = miscData.decodeUint(_LOWER_TARGET_OFFSET, _TARGET_BITS) * _TARGET_SCALING;
+        upperTarget = miscData.decodeUint(_UPPER_TARGET_OFFSET, _TARGET_BITS) * _TARGET_SCALING;
+    }
+
+    function _setTargets(
+        IERC20 mainToken,
+        uint256 lowerTarget,
+        uint256 upperTarget
+    ) private {
+        _require(lowerTarget <= upperTarget, Errors.LOWER_GREATER_THAN_UPPER_TARGET);
+        _require(upperTarget <= _MAX_UPPER_TARGET, Errors.UPPER_TARGET_TOO_HIGH);
+
+        // Targets are stored downscaled by _TARGET_SCALING to make them fit in _TARGET_BITS at the cost of some
+        // resolution. We check that said resolution is not being used before downscaling.
+
+        _require(upperTarget % _TARGET_SCALING == 0, Errors.FRACTIONAL_TARGET);
+        _require(lowerTarget % _TARGET_SCALING == 0, Errors.FRACTIONAL_TARGET);
+
+        _setMiscData(
+            WordCodec.encodeUint(lowerTarget / _TARGET_SCALING, _LOWER_TARGET_OFFSET, _TARGET_BITS) |
+                WordCodec.encodeUint(upperTarget / _TARGET_SCALING, _UPPER_TARGET_OFFSET, _TARGET_BITS)
+        );
+
+        emit TargetsSet(mainToken, lowerTarget, upperTarget);
+    }
+
+    /**
+     * @notice Set the lower and upper bounds of the zero-fee trading range for the main token balance.
+     * @dev For a new target range to be valid:
+     *      - the current balance must be between the current targets (meaning no fees are currently pending)
+     *      - the current balance must be between the new targets (meaning setting them does not create pending fees)
+     *
+     * The first requirement could be relaxed, as the LPs actually benefit from the pending fees not being paid out,
+     * but being stricter makes analysis easier at little expense.
+     */
+    function setTargets(uint256 newLowerTarget, uint256 newUpperTarget) external authenticate {
+        (uint256 currentLowerTarget, uint256 currentUpperTarget) = getTargets();
+        _require(_isMainBalanceWithinTargets(currentLowerTarget, currentUpperTarget), Errors.OUT_OF_TARGET_RANGE);
+        _require(_isMainBalanceWithinTargets(newLowerTarget, newUpperTarget), Errors.OUT_OF_NEW_TARGET_RANGE);
+
+        _setTargets(_mainToken, newLowerTarget, newUpperTarget);
+    }
+
+    /**
+     * @notice Set the swap fee percentage.
+     * @dev This is a permissioned function, and disabled if the pool is paused.
+     * Note that we override the public version of setSwapFeePercentage instead of the internal one
+     * (_setSwapFeePercentage) as the internal one is called during construction, and therefore cannot access immutable
+     * state variables, which we use below.
+     */
+    function setSwapFeePercentage(uint256 swapFeePercentage) public override {
+        // For the swap fee percentage to be changeable:
+        //  - the pool must currently be between the current targets (meaning no fees are currently pending)
+        //
+        // As the amount of accrued fees is not explicitly stored but rather derived from the main token balance and the
+        // current swap fee percentage, requiring for no fees to be pending prevents the fee setter from changing the
+        // amount of pending fees, which they could use to e.g. drain Pool funds in the form of inflated fees.
+
+        (uint256 lowerTarget, uint256 upperTarget) = getTargets();
+        _require(_isMainBalanceWithinTargets(lowerTarget, upperTarget), Errors.OUT_OF_TARGET_RANGE);
+
+        super.setSwapFeePercentage(swapFeePercentage);
+    }
+
+    function _isMainBalanceWithinTargets(uint256 lowerTarget, uint256 upperTarget) private view returns (bool) {
+        (uint256 cash, uint256 managed, , ) = getVault().getPoolTokenInfo(getPoolId(), _mainToken);
+
+        uint256 mainTokenBalance = _upscale(cash + managed, _scalingFactor(_mainToken));
+
+        return mainTokenBalance >= lowerTarget && mainTokenBalance <= upperTarget;
+    }
+
+    function _isOwnerOnlyAction(bytes32 actionId) internal view virtual override returns (bool) {
+        return actionId == getActionId(this.setTargets.selector) || super._isOwnerOnlyAction(actionId);
+    }
+
+    /**
+     * @notice Returns the number of tokens in circulation.
+     *
+     * @dev In other pools, this would be the same as `totalSupply`, but since this pool pre-mints BPT and holds it in
+     * the Vault as a token, we need to subtract the Vault's balance to get the total "circulating supply". Both the
+     * totalSupply and Vault balance can change. If users join or exit using swaps, some of the preminted BPT are
+     * exchanged, so the Vault's balance increases after joins and decreases after exits. If users call the recovery
+     * mode exit function, the totalSupply can change as BPT are burned.
+     */
+    function getVirtualSupply() external view returns (uint256) {
+        // For a 3 token General Pool, it is cheaper to query the balance for a single token than to read all balances,
+        // as getPoolTokenInfo will check for token existence, token balance and Asset Manager (3 reads), while
+        // getPoolTokens will read the number of tokens, their addresses and balances (7 reads).
+        (uint256 cash, uint256 managed, , ) = getVault().getPoolTokenInfo(getPoolId(), IERC20(this));
+
+        // Note that unlike all other balances, the Vault's BPT balance does not need scaling as its scaling factor is
+        // ONE. This addition cannot overflow due to the Vault's balance limits.
+        return _getVirtualSupply(cash + managed);
+    }
+
+    // The initial amount of BPT pre-minted is _PREMINTED_TOKEN_BALANCE, and it goes entirely to the pool balance in the
+    // vault. So the virtualSupply (the actual supply in circulation) is defined as:
+    // virtualSupply = totalSupply() - _balances[_bptIndex]
+    function _getVirtualSupply(uint256 bptBalance) internal view returns (uint256) {
+        return totalSupply().sub(bptBalance);
+    }
+}
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts pool-linear/contracts/LinearPool.sol.rej pool-linear/contracts/LinearPool.sol.rej
--- pool-linear/contracts/LinearPool.sol.rej	1970-01-01 01:00:00.000000000 +0100
+++ pool-linear/contracts/LinearPool.sol.rej	2022-10-28 09:58:16.000000000 +0200
@@ -0,0 +1,37 @@
+***************
+*** 15,31 ****
+  pragma solidity ^0.7.0;
+  pragma experimental ABIEncoderV2;
+  
+- import "@balancer-labs/v2-interfaces/contracts/solidity-utils/helpers/BalancerErrors.sol";
+- import "@balancer-labs/v2-interfaces/contracts/pool-linear/LinearPoolUserData.sol";
+- import "@balancer-labs/v2-interfaces/contracts/pool-utils/IRateProvider.sol";
+- import "@balancer-labs/v2-interfaces/contracts/pool-linear/ILinearPool.sol";
+- import "@balancer-labs/v2-interfaces/contracts/vault/IGeneralPool.sol";
+  
+- import "@balancer-labs/v2-pool-utils/contracts/BasePool.sol";
+- import "@balancer-labs/v2-pool-utils/contracts/rates/PriceRateCache.sol";
+  
+- import "@balancer-labs/v2-solidity-utils/contracts/helpers/ERC20Helpers.sol";
+- import "@balancer-labs/v2-solidity-utils/contracts/math/FixedPoint.sol";
+  
+  import "./LinearMath.sol";
+  
+--- 15,31 ----
+  pragma solidity ^0.7.0;
+  pragma experimental ABIEncoderV2;
+  
++ import "../../interfaces/contracts/solidity-utils/helpers/BalancerErrors.sol";
++ import "../../interfaces/contracts/pool-linear/LinearPoolUserData.sol";
++ import "../../interfaces/contracts/pool-utils/IRateProvider.sol";
++ import "../../interfaces/contracts/pool-linear/ILinearPool.sol";
++ import "../../interfaces/contracts/vault/IGeneralPool.sol";
+  
++ import "../../pool-utils/contracts/BasePool.sol";
++ import "../../pool-utils/contracts/rates/PriceRateCache.sol";
+  
++ import "../../solidity-utils/contracts/helpers/ERC20Helpers.sol";
++ import "../../solidity-utils/contracts/math/FixedPoint.sol";
+  
+  import "./LinearMath.sol";
+  
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts pool-linear/contracts/LinearPoolRebalancer.sol pool-linear/contracts/LinearPoolRebalancer.sol
--- pool-linear/contracts/LinearPoolRebalancer.sol	2022-10-28 09:21:26.000000000 +0200
+++ pool-linear/contracts/LinearPoolRebalancer.sol	2022-10-28 09:58:16.000000000 +0200
@@ -15,14 +15,14 @@
 pragma solidity ^0.7.0;
 pragma experimental ABIEncoderV2;
 
-import "@balancer-labs/v2-interfaces/contracts/solidity-utils/helpers/BalancerErrors.sol";
+import "../../interfaces/contracts/solidity-utils/helpers/BalancerErrors.sol";
 
-import "@balancer-labs/v2-interfaces/contracts/vault/IVault.sol";
-import "@balancer-labs/v2-interfaces/contracts/standalone-utils/IBalancerQueries.sol";
-import "@balancer-labs/v2-interfaces/contracts/pool-linear/ILinearPool.sol";
+import "../../interfaces/contracts/vault/IVault.sol";
+import "../../interfaces/contracts/standalone-utils/IBalancerQueries.sol";
+import "../../interfaces/contracts/pool-linear/ILinearPool.sol";
 
-import "@balancer-labs/v2-solidity-utils/contracts/math/FixedPoint.sol";
-import "@balancer-labs/v2-solidity-utils/contracts/openzeppelin/SafeERC20.sol";
+import "../../solidity-utils/contracts/math/FixedPoint.sol";
+import "../../solidity-utils/contracts/openzeppelin/SafeERC20.sol";
 
 abstract contract LinearPoolRebalancer {
     using SafeERC20 for IERC20;
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts pool-linear/contracts/aave/AaveLinearPool.sol pool-linear/contracts/aave/AaveLinearPool.sol
--- pool-linear/contracts/aave/AaveLinearPool.sol	2022-10-28 09:21:26.000000000 +0200
+++ pool-linear/contracts/aave/AaveLinearPool.sol	2022-10-28 09:58:16.000000000 +0200
@@ -15,7 +15,7 @@
 pragma solidity ^0.7.0;
 pragma experimental ABIEncoderV2;
 
-import "@balancer-labs/v2-interfaces/contracts/pool-linear/IStaticAToken.sol";
+import "../../interfaces/contracts/pool-linear/IStaticAToken.sol";
 
 import "../LinearPool.sol";
 
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts pool-linear/contracts/aave/AaveLinearPoolFactory.sol.orig pool-linear/contracts/aave/AaveLinearPoolFactory.sol.orig
--- pool-linear/contracts/aave/AaveLinearPoolFactory.sol.orig	1970-01-01 01:00:00.000000000 +0100
+++ pool-linear/contracts/aave/AaveLinearPoolFactory.sol.orig	2022-10-28 09:58:13.000000000 +0200
@@ -0,0 +1,123 @@
+// SPDX-License-Identifier: GPL-3.0-or-later
+// This program is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation, either version 3 of the License, or
+// (at your option) any later version.
+
+// This program is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License
+// along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+pragma solidity ^0.7.0;
+pragma experimental ABIEncoderV2;
+
+import "@balancer-labs/v2-interfaces/contracts/vault/IVault.sol";
+import "@balancer-labs/v2-interfaces/contracts/standalone-utils/IBalancerQueries.sol";
+import "@balancer-labs/v2-interfaces/contracts/pool-utils/ILastCreatedPoolFactory.sol";
+
+import "@balancer-labs/v2-pool-utils/contracts/factories/BasePoolFactory.sol";
+import "@balancer-labs/v2-pool-utils/contracts/factories/FactoryWidePauseWindow.sol";
+
+import "@balancer-labs/v2-solidity-utils/contracts/openzeppelin/Create2.sol";
+import "@balancer-labs/v2-solidity-utils/contracts/openzeppelin/ReentrancyGuard.sol";
+
+import "./AaveLinearPool.sol";
+import "./AaveLinearPoolRebalancer.sol";
+
+contract AaveLinearPoolFactory is ILastCreatedPoolFactory, BasePoolFactory, ReentrancyGuard, FactoryWidePauseWindow {
+    // Used for create2 deployments
+    uint256 private _nextRebalancerSalt;
+
+    IBalancerQueries private immutable _queries;
+
+    address private _lastCreatedPool;
+
+    constructor(
+        IVault vault,
+        IProtocolFeePercentagesProvider protocolFeeProvider,
+        IBalancerQueries queries
+    ) BasePoolFactory(vault, protocolFeeProvider, type(AaveLinearPool).creationCode) {
+        _queries = queries;
+    }
+
+    function getLastCreatedPool() external view override returns (address) {
+        return _lastCreatedPool;
+    }
+
+    function _create(bytes memory constructorArgs) internal virtual override returns (address) {
+        address pool = super._create(constructorArgs);
+        _lastCreatedPool = pool;
+
+        return pool;
+    }
+
+    /**
+     * @dev Deploys a new `AaveLinearPool`.
+     */
+    function create(
+        string memory name,
+        string memory symbol,
+        IERC20 mainToken,
+        IERC20 wrappedToken,
+        uint256 upperTarget,
+        uint256 swapFeePercentage,
+        address owner
+    ) external nonReentrant returns (AaveLinearPool) {
+        // We are going to deploy both an AaveLinearPool and an AaveLinearPoolRebalancer set as its Asset Manager, but
+        // this creates a circular dependency problem: the Pool must know the Asset Manager's address in order to call
+        // `IVault.registerTokens` with it, and the Asset Manager must know about the Pool in order to store its Pool
+        // ID, wrapped and main tokens, etc., as immutable variables.
+        // We could forego immutable storage in the Rebalancer and simply have a two-step initialization process that
+        // uses storage, but we can keep those gas savings by instead making the deployment a bit more complicated.
+        //
+        // Note that the Pool does not interact with the Asset Manager: it only needs to know about its address.
+        // We therefore use create2 to deploy the Asset Manager, first computing the address where it will be deployed.
+        // With that knowledge, we can then create the Pool, and finally the Asset Manager. The only issue with this
+        // approach is that create2 requires the full creation code, including constructor arguments, and among those is
+        // the Pool's address. To work around this, we have the Rebalancer fetch this address from `getLastCreatedPool`,
+        // which will hold the Pool's address after we call `_create`.
+
+        bytes32 rebalancerSalt = bytes32(_nextRebalancerSalt);
+        _nextRebalancerSalt += 1;
+
+        bytes memory rebalancerCreationCode = abi.encodePacked(
+            type(AaveLinearPoolRebalancer).creationCode,
+            abi.encode(getVault(), _queries)
+        );
+        address expectedRebalancerAddress = Create2.computeAddress(rebalancerSalt, keccak256(rebalancerCreationCode));
+
+        (uint256 pauseWindowDuration, uint256 bufferPeriodDuration) = getPauseConfiguration();
+
+        AaveLinearPool.ConstructorArgs memory args = AaveLinearPool.ConstructorArgs({
+            vault: getVault(),
+            name: name,
+            symbol: symbol,
+            mainToken: mainToken,
+            wrappedToken: wrappedToken,
+            assetManager: expectedRebalancerAddress,
+            upperTarget: upperTarget,
+            swapFeePercentage: swapFeePercentage,
+            pauseWindowDuration: pauseWindowDuration,
+            bufferPeriodDuration: bufferPeriodDuration,
+            owner: owner
+        });
+
+        AaveLinearPool pool = AaveLinearPool(_create(abi.encode(args)));
+
+        // LinearPools have a separate post-construction initialization step: we perform it here to
+        // ensure deployment and initialization are atomic.
+        pool.initialize();
+
+        // Not that the Linear Pool's deployment is complete, we can deploy the Rebalancer, verifying that we correctly
+        // predicted its deployment address.
+        address actualRebalancerAddress = Create2.deploy(0, rebalancerSalt, rebalancerCreationCode);
+        require(expectedRebalancerAddress == actualRebalancerAddress, "Rebalancer deployment failed");
+
+        // We don't return the Rebalancer's address, but that can be queried in the Vault by calling `getPoolTokenInfo`.
+        return pool;
+    }
+}
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts pool-linear/contracts/aave/AaveLinearPoolFactory.sol.rej pool-linear/contracts/aave/AaveLinearPoolFactory.sol.rej
--- pool-linear/contracts/aave/AaveLinearPoolFactory.sol.rej	1970-01-01 01:00:00.000000000 +0100
+++ pool-linear/contracts/aave/AaveLinearPoolFactory.sol.rej	2022-10-28 09:58:16.000000000 +0200
@@ -0,0 +1,23 @@
+***************
+*** 15,24 ****
+  pragma solidity ^0.7.0;
+  pragma experimental ABIEncoderV2;
+  
+- import "@balancer-labs/v2-interfaces/contracts/vault/IVault.sol";
+  
+- import "@balancer-labs/v2-pool-utils/contracts/factories/BasePoolSplitCodeFactory.sol";
+- import "@balancer-labs/v2-pool-utils/contracts/factories/FactoryWidePauseWindow.sol";
+  
+  import "./AaveLinearPool.sol";
+  
+--- 15,24 ----
+  pragma solidity ^0.7.0;
+  pragma experimental ABIEncoderV2;
+  
++ import "../../interfaces/contracts/vault/IVault.sol";
+  
++ import "../../pool-utils/contracts/factories/BasePoolSplitCodeFactory.sol";
++ import "../../pool-utils/contracts/factories/FactoryWidePauseWindow.sol";
+  
+  import "./AaveLinearPool.sol";
+  
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts pool-linear/contracts/aave/AaveLinearPoolRebalancer.sol.orig pool-linear/contracts/aave/AaveLinearPoolRebalancer.sol.orig
--- pool-linear/contracts/aave/AaveLinearPoolRebalancer.sol.orig	1970-01-01 01:00:00.000000000 +0100
+++ pool-linear/contracts/aave/AaveLinearPoolRebalancer.sol.orig	2022-10-28 09:58:13.000000000 +0200
@@ -0,0 +1,56 @@
+// SPDX-License-Identifier: GPL-3.0-or-later
+// This program is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation, either version 3 of the License, or
+// (at your option) any later version.
+
+// This program is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License
+// along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+pragma solidity ^0.7.0;
+pragma experimental ABIEncoderV2;
+
+import "@balancer-labs/v2-interfaces/contracts/pool-linear/IStaticAToken.sol";
+import "@balancer-labs/v2-interfaces/contracts/pool-utils/ILastCreatedPoolFactory.sol";
+import "@balancer-labs/v2-solidity-utils/contracts/openzeppelin/SafeERC20.sol";
+
+import "../LinearPoolRebalancer.sol";
+
+contract AaveLinearPoolRebalancer is LinearPoolRebalancer {
+    using SafeERC20 for IERC20;
+
+    // These Rebalancers can only be deployed from a factory to work around a circular dependency: the Pool must know
+    // the address of the Rebalancer in order to register it, and the Rebalancer must know the address of the Pool
+    // during construction.
+    constructor(IVault vault, IBalancerQueries queries)
+        LinearPoolRebalancer(ILinearPool(ILastCreatedPoolFactory(msg.sender).getLastCreatedPool()), vault, queries)
+    {
+        // solhint-disable-previous-line no-empty-blocks
+    }
+
+    function _wrapTokens(uint256 amount) internal override {
+        // No referral code, depositing from underlying (i.e. DAI, USDC, etc. instead of aDAI or aUSDC). Before we can
+        // deposit however, we need to approve the wrapper in the underlying token.
+        _mainToken.safeApprove(address(_wrappedToken), amount);
+        IStaticAToken(address(_wrappedToken)).deposit(address(this), amount, 0, true);
+    }
+
+    function _unwrapTokens(uint256 amount) internal override {
+        // Withdrawing into underlying (i.e. DAI, USDC, etc. instead of aDAI or aUSDC). Approvals are not necessary here
+        // as the wrapped token is simply burnt.
+        IStaticAToken(address(_wrappedToken)).withdraw(address(this), amount, true);
+    }
+
+    function _getRequiredTokensToWrap(uint256 wrappedAmount) internal view override returns (uint256) {
+        // staticToDynamic returns how many main tokens will be returned when unwrapping. Since there's fixed point
+        // divisions and multiplications with rounding involved, this value might be off by one. We add one to ensure
+        // the returned value will always be enough to get `wrappedAmount` when unwrapping. This might result in some
+        // dust being left in the Rebalancer.
+        return IStaticAToken(address(_wrappedToken)).staticToDynamicAmount(wrappedAmount) + 1;
+    }
+}
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts pool-linear/contracts/aave/AaveLinearPoolRebalancer.sol.rej pool-linear/contracts/aave/AaveLinearPoolRebalancer.sol.rej
--- pool-linear/contracts/aave/AaveLinearPoolRebalancer.sol.rej	1970-01-01 01:00:00.000000000 +0100
+++ pool-linear/contracts/aave/AaveLinearPoolRebalancer.sol.rej	2022-10-28 09:58:16.000000000 +0200
@@ -0,0 +1,17 @@
+***************
+*** 15,21 ****
+  pragma solidity ^0.7.0;
+  pragma experimental ABIEncoderV2;
+  
+- import "@balancer-labs/v2-interfaces/contracts/pool-linear/IStaticAToken.sol";
+  
+  import "../LinearPoolRebalancer.sol";
+  
+--- 15,21 ----
+  pragma solidity ^0.7.0;
+  pragma experimental ABIEncoderV2;
+  
++ import "../../interfaces/contracts/pool-linear/IStaticAToken.sol";
+  
+  import "../LinearPoolRebalancer.sol";
+  
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts pool-linear/contracts/button-wood/UnbuttonAaveLinearPool.sol pool-linear/contracts/button-wood/UnbuttonAaveLinearPool.sol
--- pool-linear/contracts/button-wood/UnbuttonAaveLinearPool.sol	2022-10-03 09:35:45.000000000 +0200
+++ pool-linear/contracts/button-wood/UnbuttonAaveLinearPool.sol	2022-10-28 09:58:16.000000000 +0200
@@ -15,8 +15,8 @@
 pragma solidity ^0.7.0;
 pragma experimental ABIEncoderV2;
 
-import "@balancer-labs/v2-interfaces/contracts/pool-linear/IUnbuttonToken.sol";
-import "@balancer-labs/v2-interfaces/contracts/pool-linear/IAToken.sol";
+import "../../interfaces/contracts/pool-linear/IUnbuttonToken.sol";
+import "../../interfaces/contracts/pool-linear/IAToken.sol";
 
 import "../LinearPool.sol";
 
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts pool-linear/contracts/button-wood/UnbuttonAaveLinearPoolFactory.sol.orig pool-linear/contracts/button-wood/UnbuttonAaveLinearPoolFactory.sol.orig
--- pool-linear/contracts/button-wood/UnbuttonAaveLinearPoolFactory.sol.orig	1970-01-01 01:00:00.000000000 +0100
+++ pool-linear/contracts/button-wood/UnbuttonAaveLinearPoolFactory.sol.orig	2022-10-28 09:58:13.000000000 +0200
@@ -0,0 +1,69 @@
+// SPDX-License-Identifier: GPL-3.0-or-later
+// This program is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation, either version 3 of the License, or
+// (at your option) any later version.
+
+// This program is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License
+// along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+pragma solidity ^0.7.0;
+pragma experimental ABIEncoderV2;
+
+import "@balancer-labs/v2-interfaces/contracts/vault/IVault.sol";
+
+import "@balancer-labs/v2-pool-utils/contracts/factories/BasePoolFactory.sol";
+import "@balancer-labs/v2-pool-utils/contracts/factories/FactoryWidePauseWindow.sol";
+
+import "./UnbuttonAaveLinearPool.sol";
+
+contract UnbuttonAaveLinearPoolFactory is BasePoolFactory, FactoryWidePauseWindow {
+    constructor(IVault vault, IProtocolFeePercentagesProvider protocolFeeProvider)
+        BasePoolFactory(vault, protocolFeeProvider, type(UnbuttonAaveLinearPool).creationCode)
+    {
+        // solhint-disable-previous-line no-empty-blocks
+    }
+
+    /**
+     * @dev Deploys a new `UnbuttonAaveLinearPool`.
+     */
+    function create(
+        string memory name,
+        string memory symbol,
+        IUnbuttonToken mainToken,
+        IUnbuttonToken wrappedToken,
+        uint256 upperTarget,
+        uint256 swapFeePercentage,
+        address owner
+    ) external returns (LinearPool) {
+        (uint256 pauseWindowDuration, uint256 bufferPeriodDuration) = getPauseConfiguration();
+
+        LinearPool pool = UnbuttonAaveLinearPool(
+            _create(
+                abi.encode(
+                    getVault(),
+                    name,
+                    symbol,
+                    mainToken,
+                    wrappedToken,
+                    upperTarget,
+                    swapFeePercentage,
+                    pauseWindowDuration,
+                    bufferPeriodDuration,
+                    owner
+                )
+            )
+        );
+
+        // LinearPools have a separate post-construction initialization step: we perform it here to
+        // ensure deployment and initialization are atomic.
+        pool.initialize();
+
+        return pool;
+    }
+}
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts pool-linear/contracts/button-wood/UnbuttonAaveLinearPoolFactory.sol.rej pool-linear/contracts/button-wood/UnbuttonAaveLinearPoolFactory.sol.rej
--- pool-linear/contracts/button-wood/UnbuttonAaveLinearPoolFactory.sol.rej	1970-01-01 01:00:00.000000000 +0100
+++ pool-linear/contracts/button-wood/UnbuttonAaveLinearPoolFactory.sol.rej	2022-10-28 09:58:16.000000000 +0200
@@ -0,0 +1,23 @@
+***************
+*** 15,24 ****
+  pragma solidity ^0.7.0;
+  pragma experimental ABIEncoderV2;
+  
+- import "@balancer-labs/v2-interfaces/contracts/vault/IVault.sol";
+  
+- import "@balancer-labs/v2-pool-utils/contracts/factories/BasePoolSplitCodeFactory.sol";
+- import "@balancer-labs/v2-pool-utils/contracts/factories/FactoryWidePauseWindow.sol";
+  
+  import "./UnbuttonAaveLinearPool.sol";
+  
+--- 15,24 ----
+  pragma solidity ^0.7.0;
+  pragma experimental ABIEncoderV2;
+  
++ import "../../interfaces/contracts/vault/IVault.sol";
+  
++ import "../../pool-utils/contracts/factories/BasePoolSplitCodeFactory.sol";
++ import "../../pool-utils/contracts/factories/FactoryWidePauseWindow.sol";
+  
+  import "./UnbuttonAaveLinearPool.sol";
+  
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts pool-linear/contracts/erc4626/ERC4626LinearPool.sol pool-linear/contracts/erc4626/ERC4626LinearPool.sol
--- pool-linear/contracts/erc4626/ERC4626LinearPool.sol	2022-10-03 09:35:45.000000000 +0200
+++ pool-linear/contracts/erc4626/ERC4626LinearPool.sol	2022-10-28 09:58:16.000000000 +0200
@@ -15,10 +15,10 @@
 pragma solidity ^0.7.0;
 pragma experimental ABIEncoderV2;
 
-import "@balancer-labs/v2-interfaces/contracts/solidity-utils/misc/IERC4626.sol";
+import "../../interfaces/contracts/solidity-utils/misc/IERC4626.sol";
 
-import "@balancer-labs/v2-solidity-utils/contracts/openzeppelin/ERC20.sol";
-import "@balancer-labs/v2-solidity-utils/contracts/math/Math.sol";
+import "../../solidity-utils/contracts/openzeppelin/ERC20.sol";
+import "../../solidity-utils/contracts/math/Math.sol";
 
 import "../LinearPool.sol";
 
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts pool-linear/contracts/erc4626/ERC4626LinearPoolFactory.sol.orig pool-linear/contracts/erc4626/ERC4626LinearPoolFactory.sol.orig
--- pool-linear/contracts/erc4626/ERC4626LinearPoolFactory.sol.orig	1970-01-01 01:00:00.000000000 +0100
+++ pool-linear/contracts/erc4626/ERC4626LinearPoolFactory.sol.orig	2022-10-28 09:58:13.000000000 +0200
@@ -0,0 +1,69 @@
+// SPDX-License-Identifier: GPL-3.0-or-later
+// This program is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation, either version 3 of the License, or
+// (at your option) any later version.
+
+// This program is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License
+// along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+pragma solidity ^0.7.0;
+pragma experimental ABIEncoderV2;
+
+import "@balancer-labs/v2-interfaces/contracts/vault/IVault.sol";
+
+import "@balancer-labs/v2-pool-utils/contracts/factories/BasePoolFactory.sol";
+import "@balancer-labs/v2-pool-utils/contracts/factories/FactoryWidePauseWindow.sol";
+
+import "./ERC4626LinearPool.sol";
+
+contract ERC4626LinearPoolFactory is BasePoolFactory, FactoryWidePauseWindow {
+    constructor(IVault vault, IProtocolFeePercentagesProvider protocolFeeProvider)
+        BasePoolFactory(vault, protocolFeeProvider, type(ERC4626LinearPool).creationCode)
+    {
+        // solhint-disable-previous-line no-empty-blocks
+    }
+
+    /**
+     * @dev Deploys a new `ERC4626LinearPool`.
+     */
+    function create(
+        string memory name,
+        string memory symbol,
+        IERC20 mainToken,
+        IERC4626 wrappedToken,
+        uint256 upperTarget,
+        uint256 swapFeePercentage,
+        address owner
+    ) external returns (LinearPool) {
+        (uint256 pauseWindowDuration, uint256 bufferPeriodDuration) = getPauseConfiguration();
+
+        LinearPool pool = ERC4626LinearPool(
+            _create(
+                abi.encode(
+                    getVault(),
+                    name,
+                    symbol,
+                    mainToken,
+                    wrappedToken,
+                    upperTarget,
+                    swapFeePercentage,
+                    pauseWindowDuration,
+                    bufferPeriodDuration,
+                    owner
+                )
+            )
+        );
+
+        // LinearPools have a separate post-construction initialization step: we perform it here to
+        // ensure deployment and initialization are atomic.
+        pool.initialize();
+
+        return pool;
+    }
+}
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts pool-linear/contracts/erc4626/ERC4626LinearPoolFactory.sol.rej pool-linear/contracts/erc4626/ERC4626LinearPoolFactory.sol.rej
--- pool-linear/contracts/erc4626/ERC4626LinearPoolFactory.sol.rej	1970-01-01 01:00:00.000000000 +0100
+++ pool-linear/contracts/erc4626/ERC4626LinearPoolFactory.sol.rej	2022-10-28 09:58:16.000000000 +0200
@@ -0,0 +1,23 @@
+***************
+*** 15,24 ****
+  pragma solidity ^0.7.0;
+  pragma experimental ABIEncoderV2;
+  
+- import "@balancer-labs/v2-interfaces/contracts/vault/IVault.sol";
+  
+- import "@balancer-labs/v2-pool-utils/contracts/factories/BasePoolSplitCodeFactory.sol";
+- import "@balancer-labs/v2-pool-utils/contracts/factories/FactoryWidePauseWindow.sol";
+  
+  import "./ERC4626LinearPool.sol";
+  
+--- 15,24 ----
+  pragma solidity ^0.7.0;
+  pragma experimental ABIEncoderV2;
+  
++ import "../../interfaces/contracts/vault/IVault.sol";
+  
++ import "../../pool-utils/contracts/factories/BasePoolSplitCodeFactory.sol";
++ import "../../pool-utils/contracts/factories/FactoryWidePauseWindow.sol";
+  
+  import "./ERC4626LinearPool.sol";
+  
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts pool-linear/contracts/test/MockAaveAMPLToken.sol pool-linear/contracts/test/MockAaveAMPLToken.sol
--- pool-linear/contracts/test/MockAaveAMPLToken.sol	2022-10-03 09:35:45.000000000 +0200
+++ pool-linear/contracts/test/MockAaveAMPLToken.sol	2022-10-28 09:58:16.000000000 +0200
@@ -16,7 +16,7 @@
 
 pragma solidity ^0.7.0;
 
-import "@balancer-labs/v2-interfaces/contracts/pool-linear/IAToken.sol";
+import "../../interfaces/contracts/pool-linear/IAToken.sol";
 
 import "./MockUnbuttonERC20.sol";
 
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts pool-linear/contracts/test/MockERC4626Token.sol pool-linear/contracts/test/MockERC4626Token.sol
--- pool-linear/contracts/test/MockERC4626Token.sol	2022-10-03 09:35:45.000000000 +0200
+++ pool-linear/contracts/test/MockERC4626Token.sol	2022-10-28 09:58:16.000000000 +0200
@@ -14,11 +14,11 @@
 
 pragma solidity ^0.7.0;
 
-import "@balancer-labs/v2-interfaces/contracts/solidity-utils/misc/IERC4626.sol";
+import "../../interfaces/contracts/solidity-utils/misc/IERC4626.sol";
 
-import "@balancer-labs/v2-solidity-utils/contracts/math/FixedPoint.sol";
-import "@balancer-labs/v2-solidity-utils/contracts/test/TestToken.sol";
-import "@balancer-labs/v2-solidity-utils/contracts/math/Math.sol";
+import "../../solidity-utils/contracts/math/FixedPoint.sol";
+import "../../solidity-utils/contracts/test/TestToken.sol";
+import "../../solidity-utils/contracts/math/Math.sol";
 
 contract MockERC4626Token is TestToken, IERC4626 {
     using FixedPoint for uint256;
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts pool-linear/contracts/test/MockStaticAToken.sol pool-linear/contracts/test/MockStaticAToken.sol
--- pool-linear/contracts/test/MockStaticAToken.sol	2022-10-03 09:35:45.000000000 +0200
+++ pool-linear/contracts/test/MockStaticAToken.sol	2022-10-28 09:58:16.000000000 +0200
@@ -14,9 +14,9 @@
 
 pragma solidity ^0.7.0;
 
-import "@balancer-labs/v2-interfaces/contracts/pool-linear/IStaticAToken.sol";
+import "../../interfaces/contracts/pool-linear/IStaticAToken.sol";
 
-import "@balancer-labs/v2-solidity-utils/contracts/test/TestToken.sol";
+import "../../solidity-utils/contracts/test/TestToken.sol";
 
 contract MockStaticAToken is TestToken, IStaticAToken, ILendingPool {
     uint256 private _rate = 1e27;
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts pool-linear/contracts/test/MockUnbuttonERC20.sol pool-linear/contracts/test/MockUnbuttonERC20.sol
--- pool-linear/contracts/test/MockUnbuttonERC20.sol	2022-10-03 09:35:45.000000000 +0200
+++ pool-linear/contracts/test/MockUnbuttonERC20.sol	2022-10-28 09:58:16.000000000 +0200
@@ -16,10 +16,10 @@
 
 pragma solidity ^0.7.0;
 
-import "@balancer-labs/v2-interfaces/contracts/pool-linear/IButtonWrapper.sol";
+import "../../interfaces/contracts/pool-linear/IButtonWrapper.sol";
 
-import "@balancer-labs/v2-solidity-utils/contracts/openzeppelin/ERC20.sol";
-import "@balancer-labs/v2-solidity-utils/contracts/openzeppelin/SafeERC20.sol";
+import "../../solidity-utils/contracts/openzeppelin/ERC20.sol";
+import "../../solidity-utils/contracts/openzeppelin/SafeERC20.sol";
 
 contract MockUnbuttonERC20 is ERC20, IButtonWrapper {
     using SafeERC20 for IERC20;
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts pool-utils/contracts/BalancerPoolToken.sol pool-utils/contracts/BalancerPoolToken.sol
--- pool-utils/contracts/BalancerPoolToken.sol	2022-10-03 09:35:45.000000000 +0200
+++ pool-utils/contracts/BalancerPoolToken.sol	2022-10-28 09:58:55.000000000 +0200
@@ -14,9 +14,9 @@
 
 pragma solidity ^0.7.0;
 
-import "@balancer-labs/v2-interfaces/contracts/vault/IVault.sol";
+import "../../interfaces/contracts/vault/IVault.sol";
 
-import "@balancer-labs/v2-solidity-utils/contracts/openzeppelin/ERC20Permit.sol";
+import "../../solidity-utils/contracts/openzeppelin/ERC20Permit.sol";
 
 /**
  * @title Highly opinionated token implementation
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts pool-utils/contracts/BaseGeneralPool.sol pool-utils/contracts/BaseGeneralPool.sol
--- pool-utils/contracts/BaseGeneralPool.sol	2022-10-28 09:21:26.000000000 +0200
+++ pool-utils/contracts/BaseGeneralPool.sol	2022-10-28 09:58:55.000000000 +0200
@@ -15,7 +15,7 @@
 pragma solidity ^0.7.0;
 pragma experimental ABIEncoderV2;
 
-import "@balancer-labs/v2-interfaces/contracts/vault/IGeneralPool.sol";
+import "../../interfaces/contracts/vault/IGeneralPool.sol";
 
 import "./BasePool.sol";
 
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts pool-utils/contracts/BaseMinimalSwapInfoPool.sol pool-utils/contracts/BaseMinimalSwapInfoPool.sol
--- pool-utils/contracts/BaseMinimalSwapInfoPool.sol	2022-10-28 09:21:26.000000000 +0200
+++ pool-utils/contracts/BaseMinimalSwapInfoPool.sol	2022-10-28 09:58:55.000000000 +0200
@@ -15,7 +15,7 @@
 pragma solidity ^0.7.0;
 pragma experimental ABIEncoderV2;
 
-import "@balancer-labs/v2-interfaces/contracts/vault/IMinimalSwapInfoPool.sol";
+import "../../interfaces/contracts/vault/IMinimalSwapInfoPool.sol";
 
 import "./BasePool.sol";
 
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts pool-utils/contracts/BasePool.sol.orig pool-utils/contracts/BasePool.sol.orig
--- pool-utils/contracts/BasePool.sol.orig	1970-01-01 01:00:00.000000000 +0100
+++ pool-utils/contracts/BasePool.sol.orig	2022-10-28 09:58:14.000000000 +0200
@@ -0,0 +1,786 @@
+// SPDX-License-Identifier: GPL-3.0-or-later
+// This program is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation, either version 3 of the License, or
+// (at your option) any later version.
+
+// This program is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License
+// along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+pragma solidity ^0.7.0;
+pragma experimental ABIEncoderV2;
+
+import "@balancer-labs/v2-interfaces/contracts/pool-utils/IControlledPool.sol";
+import "@balancer-labs/v2-interfaces/contracts/vault/IVault.sol";
+import "@balancer-labs/v2-interfaces/contracts/vault/IBasePool.sol";
+
+import "@balancer-labs/v2-solidity-utils/contracts/helpers/InputHelpers.sol";
+import "@balancer-labs/v2-solidity-utils/contracts/helpers/WordCodec.sol";
+import "@balancer-labs/v2-solidity-utils/contracts/helpers/ScalingHelpers.sol";
+import "@balancer-labs/v2-solidity-utils/contracts/helpers/TemporarilyPausable.sol";
+import "@balancer-labs/v2-solidity-utils/contracts/openzeppelin/ERC20.sol";
+import "@balancer-labs/v2-solidity-utils/contracts/math/FixedPoint.sol";
+import "@balancer-labs/v2-solidity-utils/contracts/math/Math.sol";
+
+import "./lib/PoolRegistrationLib.sol";
+
+import "./BalancerPoolToken.sol";
+import "./BasePoolAuthorization.sol";
+import "./RecoveryMode.sol";
+
+// solhint-disable max-states-count
+
+/**
+ * @notice Reference implementation for the base layer of a Pool contract.
+ * @dev Reference implementation for the base layer of a Pool contract that manages a single Pool with optional
+ * Asset Managers, an admin-controlled swap fee percentage, and an emergency pause mechanism.
+ *
+ * This Pool pays protocol fees by minting BPT directly to the ProtocolFeeCollector instead of using the
+ * `dueProtocolFees` return value. This results in the underlying tokens continuing to provide liquidity
+ * for traders, while still keeping gas usage to a minimum since only a single token (the BPT) is transferred.
+ *
+ * Note that neither swap fees nor the pause mechanism are used by this contract. They are passed through so that
+ * derived contracts can use them via the `_addSwapFeeAmount` and `_subtractSwapFeeAmount` functions, and the
+ * `whenNotPaused` modifier.
+ *
+ * No admin permissions are checked here: instead, this contract delegates that to the Vault's own Authorizer.
+ *
+ * Because this contract doesn't implement the swap hooks, derived contracts should generally inherit from
+ * BaseGeneralPool or BaseMinimalSwapInfoPool. Otherwise, subclasses must inherit from the corresponding interfaces
+ * and implement the swap callbacks themselves.
+ */
+abstract contract BasePool is
+    IBasePool,
+    IControlledPool,
+    BasePoolAuthorization,
+    BalancerPoolToken,
+    TemporarilyPausable,
+    RecoveryMode
+{
+    using WordCodec for bytes32;
+    using FixedPoint for uint256;
+    using BasePoolUserData for bytes;
+
+    uint256 private constant _MIN_TOKENS = 2;
+
+    uint256 private constant _DEFAULT_MINIMUM_BPT = 1e6;
+
+    // 1e18 corresponds to 1.0, or a 100% fee
+    uint256 private constant _MIN_SWAP_FEE_PERCENTAGE = 1e12; // 0.0001%
+    uint256 private constant _MAX_SWAP_FEE_PERCENTAGE = 1e17; // 10% - this fits in 64 bits
+
+    // `_miscData` is a storage slot that can be used to store unrelated pieces of information. All pools store the
+    // recovery mode flag and swap fee percentage, but `miscData` can be extended to store more pieces of information.
+    // The most signficant bit is reserved for the recovery mode flag, and the swap fee percentage is stored in
+    // the next most significant 63 bits, leaving the remaining 192 bits free to store any other information derived
+    // pools might need.
+    //
+    // This slot is preferred for gas-sensitive operations as it is read in all joins, swaps and exits,
+    // and therefore warm.
+
+    // [ recovery | swap  fee | available ]
+    // [   1 bit  |  63 bits  |  192 bits ]
+    // [ MSB                          LSB ]
+    bytes32 private _miscData;
+
+    uint256 private constant _SWAP_FEE_PERCENTAGE_OFFSET = 192;
+    uint256 private constant _RECOVERY_MODE_BIT_OFFSET = 255;
+
+    // A fee can never be larger than FixedPoint.ONE, which fits in 60 bits, so 63 is more than enough.
+    uint256 private constant _SWAP_FEE_PERCENTAGE_BIT_LENGTH = 63;
+
+    bytes32 private immutable _poolId;
+
+    // Note that this value is immutable in the Vault, so we can make it immutable here and save gas
+    IProtocolFeesCollector private immutable _protocolFeesCollector;
+
+    event SwapFeePercentageChanged(uint256 swapFeePercentage);
+
+    constructor(
+        IVault vault,
+        IVault.PoolSpecialization specialization,
+        string memory name,
+        string memory symbol,
+        IERC20[] memory tokens,
+        address[] memory assetManagers,
+        uint256 swapFeePercentage,
+        uint256 pauseWindowDuration,
+        uint256 bufferPeriodDuration,
+        address owner
+    )
+        // Base Pools are expected to be deployed using factories. By using the factory address as the action
+        // disambiguator, we make all Pools deployed by the same factory share action identifiers. This allows for
+        // simpler management of permissions (such as being able to manage granting the 'set fee percentage' action in
+        // any Pool created by the same factory), while still making action identifiers unique among different factories
+        // if the selectors match, preventing accidental errors.
+        Authentication(bytes32(uint256(msg.sender)))
+        BalancerPoolToken(name, symbol, vault)
+        BasePoolAuthorization(owner)
+        TemporarilyPausable(pauseWindowDuration, bufferPeriodDuration)
+    {
+        _require(tokens.length >= _MIN_TOKENS, Errors.MIN_TOKENS);
+        _require(tokens.length <= _getMaxTokens(), Errors.MAX_TOKENS);
+
+        _setSwapFeePercentage(swapFeePercentage);
+
+        bytes32 poolId = PoolRegistrationLib.registerPoolWithAssetManagers(
+            vault,
+            specialization,
+            tokens,
+            assetManagers
+        );
+
+        // Set immutable state variables - these cannot be read from during construction
+        _poolId = poolId;
+        _protocolFeesCollector = vault.getProtocolFeesCollector();
+    }
+
+    // Getters / Setters
+
+    /**
+     * @notice Return the pool id.
+     */
+    function getPoolId() public view override returns (bytes32) {
+        return _poolId;
+    }
+
+    function _getTotalTokens() internal view virtual returns (uint256);
+
+    function _getMaxTokens() internal pure virtual returns (uint256);
+
+    /**
+     * @dev Returns the minimum BPT supply. This amount is minted to the zero address during initialization, effectively
+     * locking it.
+     *
+     * This is useful to make sure Pool initialization happens only once, but derived Pools can change this value (even
+     * to zero) by overriding this function.
+     */
+    function _getMinimumBpt() internal pure virtual returns (uint256) {
+        return _DEFAULT_MINIMUM_BPT;
+    }
+
+    /**
+     * @notice Return the current value of the swap fee percentage.
+     * @dev This is stored in `_miscData`.
+     */
+    function getSwapFeePercentage() public view virtual override returns (uint256) {
+        return _miscData.decodeUint(_SWAP_FEE_PERCENTAGE_OFFSET, _SWAP_FEE_PERCENTAGE_BIT_LENGTH);
+    }
+
+    /**
+     * @notice Return the ProtocolFeesCollector contract.
+     * @dev This is immutable, and retrieved from the Vault on construction. (It is also immutable in the Vault.)
+     */
+    function getProtocolFeesCollector() public view returns (IProtocolFeesCollector) {
+        return _protocolFeesCollector;
+    }
+
+    /**
+     * @notice Set the swap fee percentage.
+     * @dev This is a permissioned function, and disabled if the pool is paused. The swap fee must be within the
+     * bounds set by MIN_SWAP_FEE_PERCENTAGE/MAX_SWAP_FEE_PERCENTAGE. Emits the SwapFeePercentageChanged event.
+     */
+    function setSwapFeePercentage(uint256 swapFeePercentage) public virtual override authenticate whenNotPaused {
+        _setSwapFeePercentage(swapFeePercentage);
+    }
+
+    function _setSwapFeePercentage(uint256 swapFeePercentage) internal virtual {
+        _require(swapFeePercentage >= _getMinSwapFeePercentage(), Errors.MIN_SWAP_FEE_PERCENTAGE);
+        _require(swapFeePercentage <= _getMaxSwapFeePercentage(), Errors.MAX_SWAP_FEE_PERCENTAGE);
+
+        _miscData = _miscData.insertUint(
+            swapFeePercentage,
+            _SWAP_FEE_PERCENTAGE_OFFSET,
+            _SWAP_FEE_PERCENTAGE_BIT_LENGTH
+        );
+
+        emit SwapFeePercentageChanged(swapFeePercentage);
+    }
+
+    function _getMinSwapFeePercentage() internal pure virtual returns (uint256) {
+        return _MIN_SWAP_FEE_PERCENTAGE;
+    }
+
+    function _getMaxSwapFeePercentage() internal pure virtual returns (uint256) {
+        return _MAX_SWAP_FEE_PERCENTAGE;
+    }
+
+    /**
+     * @notice Returns whether the pool is in Recovery Mode.
+     */
+    function inRecoveryMode() public view override returns (bool) {
+        return _miscData.decodeBool(_RECOVERY_MODE_BIT_OFFSET);
+    }
+
+    /**
+     * @dev Sets the recoveryMode state, and emits the corresponding event.
+     */
+    function _setRecoveryMode(bool enabled) internal virtual override {
+        _miscData = _miscData.insertBool(enabled, _RECOVERY_MODE_BIT_OFFSET);
+
+        emit RecoveryModeStateChanged(enabled);
+
+        // Some pools need to update their state when leaving recovery mode to ensure proper functioning of the Pool.
+        // We do not allow an `_onEnableRecoveryMode()` hook as this may jeopardize the ability to enable Recovery mode.
+        if (!enabled) _onDisableRecoveryMode();
+    }
+
+    /**
+     * @dev Performs any necessary actions on the disabling of Recovery Mode.
+     * This is usually to reset any fee collection mechanisms to ensure that they operate correctly going forward.
+     */
+    function _onDisableRecoveryMode() internal virtual {
+        // solhint-disable-previous-line no-empty-blocks
+    }
+
+    /**
+     * @notice Pause the pool: an emergency action which disables all pool functions.
+     * @dev This is a permissioned function that will only work during the Pause Window set during pool factory
+     * deployment (see `TemporarilyPausable`).
+     */
+    function pause() external authenticate {
+        _setPaused(true);
+    }
+
+    /**
+     * @notice Reverse a `pause` operation, and restore a pool to normal functionality.
+     * @dev This is a permissioned function that will only work on a paused pool within the Buffer Period set during
+     * pool factory deployment (see `TemporarilyPausable`). Note that any paused pools will automatically unpause
+     * after the Buffer Period expires.
+     */
+    function unpause() external authenticate {
+        _setPaused(false);
+    }
+
+    function _isOwnerOnlyAction(bytes32 actionId) internal view virtual override returns (bool) {
+        return (actionId == getActionId(this.setSwapFeePercentage.selector)) || super._isOwnerOnlyAction(actionId);
+    }
+
+    function _getMiscData() internal view returns (bytes32) {
+        return _miscData;
+    }
+
+    /**
+     * @dev Inserts data into the least-significant 192 bits of the misc data storage slot.
+     * Note that the remaining 64 bits are used for the swap fee percentage and cannot be overloaded.
+     */
+    function _setMiscData(bytes32 newData) internal {
+        _miscData = _miscData.insertBits192(newData, 0);
+    }
+
+    // Join / Exit Hooks
+
+    modifier onlyVault(bytes32 poolId) {
+        _require(msg.sender == address(getVault()), Errors.CALLER_NOT_VAULT);
+        _require(poolId == getPoolId(), Errors.INVALID_POOL_ID);
+        _;
+    }
+
+    /**
+     * @notice Vault hook for adding liquidity to a pool (including the first time, "initializing" the pool).
+     * @dev This function can only be called from the Vault, from `joinPool`.
+     */
+    function onJoinPool(
+        bytes32 poolId,
+        address sender,
+        address recipient,
+        uint256[] memory balances,
+        uint256 lastChangeBlock,
+        uint256 protocolSwapFeePercentage,
+        bytes memory userData
+    ) external override onlyVault(poolId) returns (uint256[] memory, uint256[] memory) {
+        _beforeSwapJoinExit();
+
+        uint256[] memory scalingFactors = _scalingFactors();
+
+        if (totalSupply() == 0) {
+            (uint256 bptAmountOut, uint256[] memory amountsIn) = _onInitializePool(
+                poolId,
+                sender,
+                recipient,
+                scalingFactors,
+                userData
+            );
+
+            // On initialization, we lock _getMinimumBpt() by minting it for the zero address. This BPT acts as a
+            // minimum as it will never be burned, which reduces potential issues with rounding, and also prevents the
+            // Pool from ever being fully drained.
+            _require(bptAmountOut >= _getMinimumBpt(), Errors.MINIMUM_BPT);
+            _mintPoolTokens(address(0), _getMinimumBpt());
+            _mintPoolTokens(recipient, bptAmountOut - _getMinimumBpt());
+
+            // amountsIn are amounts entering the Pool, so we round up.
+            _downscaleUpArray(amountsIn, scalingFactors);
+
+            return (amountsIn, new uint256[](balances.length));
+        } else {
+            _upscaleArray(balances, scalingFactors);
+            (uint256 bptAmountOut, uint256[] memory amountsIn) = _onJoinPool(
+                poolId,
+                sender,
+                recipient,
+                balances,
+                lastChangeBlock,
+                inRecoveryMode() ? 0 : protocolSwapFeePercentage, // Protocol fees are disabled while in recovery mode
+                scalingFactors,
+                userData
+            );
+
+            // Note we no longer use `balances` after calling `_onJoinPool`, which may mutate it.
+
+            _mintPoolTokens(recipient, bptAmountOut);
+
+            // amountsIn are amounts entering the Pool, so we round up.
+            _downscaleUpArray(amountsIn, scalingFactors);
+
+            // This Pool ignores the `dueProtocolFees` return value, so we simply return a zeroed-out array.
+            return (amountsIn, new uint256[](balances.length));
+        }
+    }
+
+    /**
+     * @notice Vault hook for removing liquidity from a pool.
+     * @dev This function can only be called from the Vault, from `exitPool`.
+     */
+    function onExitPool(
+        bytes32 poolId,
+        address sender,
+        address recipient,
+        uint256[] memory balances,
+        uint256 lastChangeBlock,
+        uint256 protocolSwapFeePercentage,
+        bytes memory userData
+    ) external override onlyVault(poolId) returns (uint256[] memory, uint256[] memory) {
+        uint256[] memory amountsOut;
+        uint256 bptAmountIn;
+
+        // When a user calls `exitPool`, this is the first point of entry from the Vault.
+        // We first check whether this is a Recovery Mode exit - if so, we proceed using this special lightweight exit
+        // mechanism which avoids computing any complex values, interacting with external contracts, etc., and generally
+        // should always work, even if the Pool's mathematics or a dependency break down.
+        if (userData.isRecoveryModeExitKind()) {
+            // This exit kind is only available in Recovery Mode.
+            _ensureInRecoveryMode();
+
+            // Note that we don't upscale balances nor downscale amountsOut - we don't care about scaling factors during
+            // a recovery mode exit.
+            (bptAmountIn, amountsOut) = _doRecoveryModeExit(balances, totalSupply(), userData);
+        } else {
+            // Note that we only call this if we're not in a recovery mode exit.
+            _beforeSwapJoinExit();
+
+            uint256[] memory scalingFactors = _scalingFactors();
+            _upscaleArray(balances, scalingFactors);
+
+            (bptAmountIn, amountsOut) = _onExitPool(
+                poolId,
+                sender,
+                recipient,
+                balances,
+                lastChangeBlock,
+                inRecoveryMode() ? 0 : protocolSwapFeePercentage, // Protocol fees are disabled while in recovery mode
+                scalingFactors,
+                userData
+            );
+
+            // amountsOut are amounts exiting the Pool, so we round down.
+            _downscaleDownArray(amountsOut, scalingFactors);
+        }
+
+        // Note we no longer use `balances` after calling `_onExitPool`, which may mutate it.
+
+        _burnPoolTokens(sender, bptAmountIn);
+
+        // This Pool ignores the `dueProtocolFees` return value, so we simply return a zeroed-out array.
+        return (amountsOut, new uint256[](balances.length));
+    }
+
+    // Query functions
+
+    /**
+     * @notice "Dry run" `onJoinPool`.
+     * @dev Returns the amount of BPT that would be granted to `recipient` if the `onJoinPool` hook were called by the
+     * Vault with the same arguments, along with the number of tokens `sender` would have to supply.
+     *
+     * This function is not meant to be called directly, but rather from a helper contract that fetches current Vault
+     * data, such as the protocol swap fee percentage and Pool balances.
+     *
+     * Like `IVault.queryBatchSwap`, this function is not view due to internal implementation details: the caller must
+     * explicitly use eth_call instead of eth_sendTransaction.
+     */
+    function queryJoin(
+        bytes32 poolId,
+        address sender,
+        address recipient,
+        uint256[] memory balances,
+        uint256 lastChangeBlock,
+        uint256 protocolSwapFeePercentage,
+        bytes memory userData
+    ) external override returns (uint256 bptOut, uint256[] memory amountsIn) {
+        InputHelpers.ensureInputLengthMatch(balances.length, _getTotalTokens());
+
+        _queryAction(
+            poolId,
+            sender,
+            recipient,
+            balances,
+            lastChangeBlock,
+            protocolSwapFeePercentage,
+            userData,
+            _onJoinPool,
+            _downscaleUpArray
+        );
+
+        // The `return` opcode is executed directly inside `_queryAction`, so execution never reaches this statement,
+        // and we don't need to return anything here - it just silences compiler warnings.
+        return (bptOut, amountsIn);
+    }
+
+    /**
+     * @notice "Dry run" `onExitPool`.
+     * @dev Returns the amount of BPT that would be burned from `sender` if the `onExitPool` hook were called by the
+     * Vault with the same arguments, along with the number of tokens `recipient` would receive.
+     *
+     * This function is not meant to be called directly, but rather from a helper contract that fetches current Vault
+     * data, such as the protocol swap fee percentage and Pool balances.
+     *
+     * Like `IVault.queryBatchSwap`, this function is not view due to internal implementation details: the caller must
+     * explicitly use eth_call instead of eth_sendTransaction.
+     */
+    function queryExit(
+        bytes32 poolId,
+        address sender,
+        address recipient,
+        uint256[] memory balances,
+        uint256 lastChangeBlock,
+        uint256 protocolSwapFeePercentage,
+        bytes memory userData
+    ) external override returns (uint256 bptIn, uint256[] memory amountsOut) {
+        InputHelpers.ensureInputLengthMatch(balances.length, _getTotalTokens());
+
+        _queryAction(
+            poolId,
+            sender,
+            recipient,
+            balances,
+            lastChangeBlock,
+            protocolSwapFeePercentage,
+            userData,
+            _onExitPool,
+            _downscaleDownArray
+        );
+
+        // The `return` opcode is executed directly inside `_queryAction`, so execution never reaches this statement,
+        // and we don't need to return anything here - it just silences compiler warnings.
+        return (bptIn, amountsOut);
+    }
+
+    // Internal hooks to be overridden by derived contracts - all token amounts (except BPT) in these interfaces are
+    // upscaled.
+
+    /**
+     * @dev Called when the Pool is joined for the first time; that is, when the BPT total supply is zero.
+     *
+     * Returns the amount of BPT to mint, and the token amounts the Pool will receive in return.
+     *
+     * Minted BPT will be sent to `recipient`, except for _getMinimumBpt(), which will be deducted from this amount and
+     * sent to the zero address instead. This will cause that BPT to remain forever locked there, preventing total BTP
+     * from ever dropping below that value, and ensuring `_onInitializePool` can only be called once in the entire
+     * Pool's lifetime.
+     *
+     * The tokens granted to the Pool will be transferred from `sender`. These amounts are considered upscaled and will
+     * be downscaled (rounding up) before being returned to the Vault.
+     */
+    function _onInitializePool(
+        bytes32 poolId,
+        address sender,
+        address recipient,
+        uint256[] memory scalingFactors,
+        bytes memory userData
+    ) internal virtual returns (uint256 bptAmountOut, uint256[] memory amountsIn);
+
+    /**
+     * @dev Called whenever the Pool is joined after the first initialization join (see `_onInitializePool`).
+     *
+     * Returns the amount of BPT to mint, the token amounts that the Pool will receive in return, and the number of
+     * tokens to pay in protocol swap fees.
+     *
+     * Implementations of this function might choose to mutate the `balances` array to save gas (e.g. when
+     * performing intermediate calculations, such as subtraction of due protocol fees). This can be done safely.
+     *
+     * Minted BPT will be sent to `recipient`.
+     *
+     * The tokens granted to the Pool will be transferred from `sender`. These amounts are considered upscaled and will
+     * be downscaled (rounding up) before being returned to the Vault.
+     *
+     * Due protocol swap fees will be taken from the Pool's balance in the Vault (see `IBasePool.onJoinPool`). These
+     * amounts are considered upscaled and will be downscaled (rounding down) before being returned to the Vault.
+     */
+    function _onJoinPool(
+        bytes32 poolId,
+        address sender,
+        address recipient,
+        uint256[] memory balances,
+        uint256 lastChangeBlock,
+        uint256 protocolSwapFeePercentage,
+        uint256[] memory scalingFactors,
+        bytes memory userData
+    ) internal virtual returns (uint256 bptAmountOut, uint256[] memory amountsIn);
+
+    /**
+     * @dev Called whenever the Pool is exited.
+     *
+     * Returns the amount of BPT to burn, the token amounts for each Pool token that the Pool will grant in return, and
+     * the number of tokens to pay in protocol swap fees.
+     *
+     * Implementations of this function might choose to mutate the `balances` array to save gas (e.g. when
+     * performing intermediate calculations, such as subtraction of due protocol fees). This can be done safely.
+     *
+     * BPT will be burnt from `sender`.
+     *
+     * The Pool will grant tokens to `recipient`. These amounts are considered upscaled and will be downscaled
+     * (rounding down) before being returned to the Vault.
+     *
+     * Due protocol swap fees will be taken from the Pool's balance in the Vault (see `IBasePool.onExitPool`). These
+     * amounts are considered upscaled and will be downscaled (rounding down) before being returned to the Vault.
+     */
+    function _onExitPool(
+        bytes32 poolId,
+        address sender,
+        address recipient,
+        uint256[] memory balances,
+        uint256 lastChangeBlock,
+        uint256 protocolSwapFeePercentage,
+        uint256[] memory scalingFactors,
+        bytes memory userData
+    ) internal virtual returns (uint256 bptAmountIn, uint256[] memory amountsOut);
+
+    /**
+     * @dev Called at the very beginning of swaps, joins and exits, even before the scaling factors are read. Derived
+     * contracts can extend this implementation to perform any state-changing operations they might need (including e.g.
+     * updating the scaling factors),
+     *
+     * The only scenario in which this function is not called is during a recovery mode exit. This makes it safe to
+     * perform non-trivial computations or interact with external dependencies here, as recovery mode will not be
+     * affected.
+     *
+     * Since this contract does not implement swaps, derived contracts must also make sure this function is called on
+     * swap handlers.
+     */
+    function _beforeSwapJoinExit() internal virtual {
+        // All joins, exits and swaps are disabled (except recovery mode exits).
+        _ensureNotPaused();
+    }
+
+    // Internal functions
+
+    /**
+     * @dev Pays protocol fees by minting `bptAmount` to the Protocol Fee Collector.
+     */
+    function _payProtocolFees(uint256 bptAmount) internal {
+        if (bptAmount > 0) {
+            _mintPoolTokens(address(getProtocolFeesCollector()), bptAmount);
+        }
+    }
+
+    /**
+     * @dev Adds swap fee amount to `amount`, returning a higher value.
+     */
+    function _addSwapFeeAmount(uint256 amount) internal view returns (uint256) {
+        // This returns amount + fee amount, so we round up (favoring a higher fee amount).
+        return amount.divUp(getSwapFeePercentage().complement());
+    }
+
+    /**
+     * @dev Subtracts swap fee amount from `amount`, returning a lower value.
+     */
+    function _subtractSwapFeeAmount(uint256 amount) internal view returns (uint256) {
+        // This returns amount - fee amount, so we round up (favoring a higher fee amount).
+        uint256 feeAmount = amount.mulUp(getSwapFeePercentage());
+        return amount.sub(feeAmount);
+    }
+
+    // Scaling
+
+    /**
+     * @dev Returns a scaling factor that, when multiplied to a token amount for `token`, normalizes its balance as if
+     * it had 18 decimals.
+     */
+    function _computeScalingFactor(IERC20 token) internal view returns (uint256) {
+        if (address(token) == address(this)) {
+            return FixedPoint.ONE;
+        }
+
+        // Tokens that don't implement the `decimals` method are not supported.
+        uint256 tokenDecimals = ERC20(address(token)).decimals();
+
+        // Tokens with more than 18 decimals are not supported.
+        uint256 decimalsDifference = Math.sub(18, tokenDecimals);
+        return FixedPoint.ONE * 10**decimalsDifference;
+    }
+
+    /**
+     * @dev Returns the scaling factor for one of the Pool's tokens. Reverts if `token` is not a token registered by the
+     * Pool.
+     *
+     * All scaling factors are fixed-point values with 18 decimals, to allow for this function to be overridden by
+     * derived contracts that need to apply further scaling, making these factors potentially non-integer.
+     *
+     * The largest 'base' scaling factor (i.e. in tokens with less than 18 decimals) is 10**18, which in fixed-point is
+     * 10**36. This value can be multiplied with a 112 bit Vault balance with no overflow by a factor of ~1e7, making
+     * even relatively 'large' factors safe to use.
+     *
+     * The 1e7 figure is the result of 2**256 / (1e18 * 1e18 * 2**112).
+     */
+    function _scalingFactor(IERC20 token) internal view virtual returns (uint256);
+
+    /**
+     * @dev Same as `_scalingFactor()`, except for all registered tokens (in the same order as registered). The Vault
+     * will always pass balances in this order when calling any of the Pool hooks.
+     */
+    function _scalingFactors() internal view virtual returns (uint256[] memory);
+
+    function getScalingFactors() external view override returns (uint256[] memory) {
+        return _scalingFactors();
+    }
+
+    function _getAuthorizer() internal view override returns (IAuthorizer) {
+        // Access control management is delegated to the Vault's Authorizer. This lets Balancer Governance manage which
+        // accounts can call permissioned functions: for example, to perform emergency pauses.
+        // If the owner is delegated, then *all* permissioned functions, including `setSwapFeePercentage`, will be under
+        // Governance control.
+        return getVault().getAuthorizer();
+    }
+
+    function _queryAction(
+        bytes32 poolId,
+        address sender,
+        address recipient,
+        uint256[] memory balances,
+        uint256 lastChangeBlock,
+        uint256 protocolSwapFeePercentage,
+        bytes memory userData,
+        function(bytes32, address, address, uint256[] memory, uint256, uint256, uint256[] memory, bytes memory)
+            internal
+            returns (uint256, uint256[] memory) _action,
+        function(uint256[] memory, uint256[] memory) internal view _downscaleArray
+    ) private {
+        // This uses the same technique used by the Vault in queryBatchSwap. Refer to that function for a detailed
+        // explanation.
+
+        if (msg.sender != address(this)) {
+            // We perform an external call to ourselves, forwarding the same calldata. In this call, the else clause of
+            // the preceding if statement will be executed instead.
+
+            // solhint-disable-next-line avoid-low-level-calls
+            (bool success, ) = address(this).call(msg.data);
+
+            // solhint-disable-next-line no-inline-assembly
+            assembly {
+                // This call should always revert to decode the bpt and token amounts from the revert reason
+                switch success
+                    case 0 {
+                        // Note we are manually writing the memory slot 0. We can safely overwrite whatever is
+                        // stored there as we take full control of the execution and then immediately return.
+
+                        // We copy the first 4 bytes to check if it matches with the expected signature, otherwise
+                        // there was another revert reason and we should forward it.
+                        returndatacopy(0, 0, 0x04)
+                        let error := and(mload(0), 0xffffffff00000000000000000000000000000000000000000000000000000000)
+
+                        // If the first 4 bytes don't match with the expected signature, we forward the revert reason.
+                        if eq(eq(error, 0x43adbafb00000000000000000000000000000000000000000000000000000000), 0) {
+                            returndatacopy(0, 0, returndatasize())
+                            revert(0, returndatasize())
+                        }
+
+                        // The returndata contains the signature, followed by the raw memory representation of the
+                        // `bptAmount` and `tokenAmounts` (array: length + data). We need to return an ABI-encoded
+                        // representation of these.
+                        // An ABI-encoded response will include one additional field to indicate the starting offset of
+                        // the `tokenAmounts` array. The `bptAmount` will be laid out in the first word of the
+                        // returndata.
+                        //
+                        // In returndata:
+                        // [ signature ][ bptAmount ][ tokenAmounts length ][ tokenAmounts values ]
+                        // [  4 bytes  ][  32 bytes ][       32 bytes      ][ (32 * length) bytes ]
+                        //
+                        // We now need to return (ABI-encoded values):
+                        // [ bptAmount ][ tokeAmounts offset ][ tokenAmounts length ][ tokenAmounts values ]
+                        // [  32 bytes ][       32 bytes     ][       32 bytes      ][ (32 * length) bytes ]
+
+                        // We copy 32 bytes for the `bptAmount` from returndata into memory.
+                        // Note that we skip the first 4 bytes for the error signature
+                        returndatacopy(0, 0x04, 32)
+
+                        // The offsets are 32-bytes long, so the array of `tokenAmounts` will start after
+                        // the initial 64 bytes.
+                        mstore(0x20, 64)
+
+                        // We now copy the raw memory array for the `tokenAmounts` from returndata into memory.
+                        // Since bpt amount and offset take up 64 bytes, we start copying at address 0x40. We also
+                        // skip the first 36 bytes from returndata, which correspond to the signature plus bpt amount.
+                        returndatacopy(0x40, 0x24, sub(returndatasize(), 36))
+
+                        // We finally return the ABI-encoded uint256 and the array, which has a total length equal to
+                        // the size of returndata, plus the 32 bytes of the offset but without the 4 bytes of the
+                        // error signature.
+                        return(0, add(returndatasize(), 28))
+                    }
+                    default {
+                        // This call should always revert, but we fail nonetheless if that didn't happen
+                        invalid()
+                    }
+            }
+        } else {
+            // This imitates the relevant parts of the bodies of onJoin and onExit. Since they're not virtual, we know
+            // that their implementations will match this regardless of what derived contracts might do.
+
+            _beforeSwapJoinExit();
+
+            uint256[] memory scalingFactors = _scalingFactors();
+            _upscaleArray(balances, scalingFactors);
+
+            (uint256 bptAmount, uint256[] memory tokenAmounts) = _action(
+                poolId,
+                sender,
+                recipient,
+                balances,
+                lastChangeBlock,
+                protocolSwapFeePercentage,
+                scalingFactors,
+                userData
+            );
+
+            _downscaleArray(tokenAmounts, scalingFactors);
+
+            // solhint-disable-next-line no-inline-assembly
+            assembly {
+                // We will return a raw representation of `bptAmount` and `tokenAmounts` in memory, which is composed of
+                // a 32-byte uint256, followed by a 32-byte for the array length, and finally the 32-byte uint256 values
+                // Because revert expects a size in bytes, we multiply the array length (stored at `tokenAmounts`) by 32
+                let size := mul(mload(tokenAmounts), 32)
+
+                // We store the `bptAmount` in the previous slot to the `tokenAmounts` array. We can make sure there
+                // will be at least one available slot due to how the memory scratch space works.
+                // We can safely overwrite whatever is stored in this slot as we will revert immediately after that.
+                let start := sub(tokenAmounts, 0x20)
+                mstore(start, bptAmount)
+
+                // We send one extra value for the error signature "QueryError(uint256,uint256[])" which is 0x43adbafb
+                // We use the previous slot to `bptAmount`.
+                mstore(sub(start, 0x20), 0x0000000000000000000000000000000000000000000000000000000043adbafb)
+                start := sub(start, 0x04)
+
+                // When copying from `tokenAmounts` into returndata, we copy the additional 68 bytes to also return
+                // the `bptAmount`, the array 's length, and the error signature.
+                revert(start, add(size, 68))
+            }
+        }
+    }
+}
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts pool-utils/contracts/BasePool.sol.rej pool-utils/contracts/BasePool.sol.rej
--- pool-utils/contracts/BasePool.sol.rej	1970-01-01 01:00:00.000000000 +0100
+++ pool-utils/contracts/BasePool.sol.rej	2022-10-28 09:58:55.000000000 +0200
@@ -0,0 +1,35 @@
+***************
+*** 15,30 ****
+  pragma solidity ^0.7.0;
+  pragma experimental ABIEncoderV2;
+  
+- import "@balancer-labs/v2-interfaces/contracts/pool-utils/IAssetManager.sol";
+- import "@balancer-labs/v2-interfaces/contracts/vault/IVault.sol";
+- import "@balancer-labs/v2-interfaces/contracts/vault/IBasePool.sol";
+  
+- import "@balancer-labs/v2-solidity-utils/contracts/helpers/InputHelpers.sol";
+- import "@balancer-labs/v2-solidity-utils/contracts/helpers/WordCodec.sol";
+- import "@balancer-labs/v2-solidity-utils/contracts/helpers/TemporarilyPausable.sol";
+- import "@balancer-labs/v2-solidity-utils/contracts/openzeppelin/ERC20.sol";
+- import "@balancer-labs/v2-solidity-utils/contracts/math/FixedPoint.sol";
+- import "@balancer-labs/v2-solidity-utils/contracts/math/Math.sol";
+  
+  import "./BalancerPoolToken.sol";
+  import "./BasePoolAuthorization.sol";
+--- 15,30 ----
+  pragma solidity ^0.7.0;
+  pragma experimental ABIEncoderV2;
+  
++ import "../../interfaces/contracts/pool-utils/IAssetManager.sol";
++ import "../../interfaces/contracts/vault/IVault.sol";
++ import "../../interfaces/contracts/vault/IBasePool.sol";
+  
++ import "../../solidity-utils/contracts/helpers/InputHelpers.sol";
++ import "../../solidity-utils/contracts/helpers/WordCodec.sol";
++ import "../../solidity-utils/contracts/helpers/TemporarilyPausable.sol";
++ import "../../solidity-utils/contracts/openzeppelin/ERC20.sol";
++ import "../../solidity-utils/contracts/math/FixedPoint.sol";
++ import "../../solidity-utils/contracts/math/Math.sol";
+  
+  import "./BalancerPoolToken.sol";
+  import "./BasePoolAuthorization.sol";
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts pool-utils/contracts/BasePoolAuthorization.sol pool-utils/contracts/BasePoolAuthorization.sol
--- pool-utils/contracts/BasePoolAuthorization.sol	2022-10-28 09:21:26.000000000 +0200
+++ pool-utils/contracts/BasePoolAuthorization.sol	2022-10-28 09:58:55.000000000 +0200
@@ -14,9 +14,9 @@
 
 pragma solidity ^0.7.0;
 
-import "@balancer-labs/v2-interfaces/contracts/vault/IAuthorizer.sol";
+import "../../interfaces/contracts/vault/IAuthorizer.sol";
 
-import "@balancer-labs/v2-solidity-utils/contracts/helpers/Authentication.sol";
+import "../../solidity-utils/contracts/helpers/Authentication.sol";
 
 /**
  * @dev Base authorization layer implementation for Pools.
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts pool-utils/contracts/RecoveryMode.sol pool-utils/contracts/RecoveryMode.sol
--- pool-utils/contracts/RecoveryMode.sol	2022-10-28 09:21:26.000000000 +0200
+++ pool-utils/contracts/RecoveryMode.sol	2022-10-28 09:58:56.000000000 +0200
@@ -14,11 +14,11 @@
 
 pragma solidity ^0.7.0;
 
-import "@balancer-labs/v2-interfaces/contracts/solidity-utils/helpers/BalancerErrors.sol";
-import "@balancer-labs/v2-interfaces/contracts/pool-utils/BasePoolUserData.sol";
-import "@balancer-labs/v2-interfaces/contracts/pool-utils/IRecoveryMode.sol";
+import "../../interfaces/contracts/solidity-utils/helpers/BalancerErrors.sol";
+import "../../interfaces/contracts/pool-utils/BasePoolUserData.sol";
+import "../../interfaces/contracts/pool-utils/IRecoveryMode.sol";
 
-import "@balancer-labs/v2-solidity-utils/contracts/math/FixedPoint.sol";
+import "../../solidity-utils/contracts/math/FixedPoint.sol";
 
 import "./BasePoolAuthorization.sol";
 
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts pool-utils/contracts/controllers/BasePoolController.sol pool-utils/contracts/controllers/BasePoolController.sol
--- pool-utils/contracts/controllers/BasePoolController.sol	2022-10-28 09:21:26.000000000 +0200
+++ pool-utils/contracts/controllers/BasePoolController.sol	2022-10-28 09:58:56.000000000 +0200
@@ -15,9 +15,9 @@
 pragma solidity ^0.7.0;
 pragma experimental ABIEncoderV2;
 
-import "@balancer-labs/v2-interfaces/contracts/pool-utils/IBasePoolController.sol";
+import "../../interfaces/contracts/pool-utils/IBasePoolController.sol";
 
-import "@balancer-labs/v2-solidity-utils/contracts/helpers/WordCodec.sol";
+import "../../solidity-utils/contracts/helpers/WordCodec.sol";
 
 import "../BasePoolAuthorization.sol";
 
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts pool-utils/contracts/controllers/ManagedPoolController.sol.orig pool-utils/contracts/controllers/ManagedPoolController.sol.orig
--- pool-utils/contracts/controllers/ManagedPoolController.sol.orig	1970-01-01 01:00:00.000000000 +0100
+++ pool-utils/contracts/controllers/ManagedPoolController.sol.orig	2022-10-28 09:58:14.000000000 +0200
@@ -0,0 +1,229 @@
+// SPDX-License-Identifier: GPL-3.0-or-later
+// This program is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation, either version 3 of the License, or
+// (at your option) any later version.
+
+// This program is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License
+// along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+pragma solidity ^0.7.0;
+pragma experimental ABIEncoderV2;
+
+import "@balancer-labs/v2-solidity-utils/contracts/openzeppelin/SafeERC20.sol";
+import "@balancer-labs/v2-interfaces/contracts/pool-utils/IManagedPool.sol";
+
+import "./BasePoolController.sol";
+
+/**
+ * @dev Pool controller that serves as the "owner" of a Managed pool, and is in turn owned by
+ * an account empowered to make calls on this contract, which are forwarded to the underlyling pool.
+ *
+ * This contract can place limits on whether and how these calls can be made. For instance,
+ * imposing a minimum gradual weight change duration.
+ *
+ * While Balancer pool owners are immutable, ownership of this pool controller can be transferrable,
+ * if the corresponding permission is set.
+ */
+contract ManagedPoolController is BasePoolController {
+    using SafeERC20 for IERC20;
+    using WordCodec for bytes32;
+
+    // There are six managed pool rights: all corresponding to permissioned functions of ManagedPool.
+    struct ManagedPoolRights {
+        bool canChangeWeights;
+        bool canDisableSwaps;
+        bool canSetMustAllowlistLPs;
+        bool canSetCircuitBreakers;
+        bool canChangeTokens;
+        bool canChangeMgmtFees;
+    }
+
+    // The minimum weight change duration could be replaced with more sophisticated rate-limiting.
+    uint256 internal immutable _minWeightChangeDuration;
+
+    // Immutable controller state - the first 16 bits are reserved as a bitmap for permission flags
+    // (3 used in the base class; 6 used here), and the remaining 240 bits can be used by derived classes
+    // to store any other immutable data.
+    //
+    //               Managed Pool Controller Permissions             |   Base Controller Permissions  ]
+    // [  240 | 7 bits |   1 bit  |  1 bit |  1 bit   | 1 bit | 1 bit |  1 bit  |  1 bit   |  1 bit   |   1 bit  ]
+    // [unused|reserved| mgmt fee | tokens | breakers |  LPs  | swaps | weights | metadata | swap fee | transfer ]
+    // |MSB                                                                                                   LSB|
+
+    uint256 private constant _CHANGE_WEIGHTS_OFFSET = 3;
+    uint256 private constant _DISABLE_SWAPS_OFFSET = 4;
+    uint256 private constant _MUST_ALLOWLIST_LPS_OFFSET = 5;
+    uint256 private constant _CIRCUIT_BREAKERS_OFFSET = 6;
+    uint256 private constant _CHANGE_TOKENS_OFFSET = 7;
+    uint256 private constant _CHANGE_MGMT_FEES_OFFSET = 8;
+
+    /**
+     * @dev Pass in the `BasePoolRights` and `ManagedPoolRights` structures, to form the complete set of
+     * immutable rights. Then pass any parameters related to restrictions on those rights. For instance,
+     * a minimum duration if changing weights is enabled.
+     */
+    constructor(
+        BasePoolRights memory baseRights,
+        ManagedPoolRights memory managedRights,
+        uint256 minWeightChangeDuration,
+        address manager
+    ) BasePoolController(encodePermissions(baseRights, managedRights), manager) {
+        _minWeightChangeDuration = minWeightChangeDuration;
+    }
+
+    function encodePermissions(BasePoolRights memory baseRights, ManagedPoolRights memory managedRights)
+        public
+        pure
+        returns (bytes32)
+    {
+        bytes32 permissions = super
+            .encodePermissions(baseRights)
+            .insertBool(managedRights.canChangeWeights, _CHANGE_WEIGHTS_OFFSET)
+            .insertBool(managedRights.canDisableSwaps, _DISABLE_SWAPS_OFFSET)
+            .insertBool(managedRights.canSetMustAllowlistLPs, _MUST_ALLOWLIST_LPS_OFFSET);
+
+        // Needed to avoid "stack too deep"
+        return
+            permissions
+                .insertBool(managedRights.canChangeMgmtFees, _CHANGE_MGMT_FEES_OFFSET)
+                .insertBool(managedRights.canChangeTokens, _CHANGE_TOKENS_OFFSET)
+                .insertBool(managedRights.canSetCircuitBreakers, _CIRCUIT_BREAKERS_OFFSET);
+    }
+
+    /**
+     * @dev Getter for the canChangeWeights permission.
+     */
+    function canChangeWeights() public view returns (bool) {
+        return _controllerState.decodeBool(_CHANGE_WEIGHTS_OFFSET);
+    }
+
+    /**
+     * @dev Getter for the canDisableSwaps permission.
+     */
+    function canDisableSwaps() public view returns (bool) {
+        return _controllerState.decodeBool(_DISABLE_SWAPS_OFFSET);
+    }
+
+    /**
+     * @dev Getter for the mustAllowlistLPs permission.
+     */
+    function canSetMustAllowlistLPs() public view returns (bool) {
+        return _controllerState.decodeBool(_MUST_ALLOWLIST_LPS_OFFSET);
+    }
+
+    /**
+     * @dev Getter for the canSetCircuitBreakers permission.
+     */
+    function canSetCircuitBreakers() public view returns (bool) {
+        return _controllerState.decodeBool(_CIRCUIT_BREAKERS_OFFSET);
+    }
+
+    /**
+     * @dev Getter for the canChangeTokens permission.
+     */
+    function canChangeTokens() public view returns (bool) {
+        return _controllerState.decodeBool(_CHANGE_TOKENS_OFFSET);
+    }
+
+    /**
+     * @dev Getter for the canChangeManagementFees permission.
+     */
+    function canChangeManagementFees() public view returns (bool) {
+        return _controllerState.decodeBool(_CHANGE_MGMT_FEES_OFFSET);
+    }
+
+    /**
+     * @dev Getter for the minimum weight change duration.
+     */
+    function getMinWeightChangeDuration() external view returns (uint256) {
+        return _minWeightChangeDuration;
+    }
+
+    /**
+     * @dev Update weights linearly from the current values to the given end weights, between startTime
+     * and endTime.
+     */
+    function updateWeightsGradually(
+        uint256 startTime,
+        uint256 endTime,
+        IERC20[] calldata tokens,
+        uint256[] calldata endWeights
+    ) external virtual onlyManager withBoundPool {
+        _require(canChangeWeights(), Errors.FEATURE_DISABLED);
+        _require(
+            endTime >= startTime && endTime - startTime >= _minWeightChangeDuration,
+            Errors.WEIGHT_CHANGE_TOO_FAST
+        );
+
+        IManagedPool(pool).updateWeightsGradually(startTime, endTime, tokens, endWeights);
+    }
+
+    /**
+     * @dev Pass a call to ManagedPool's setSwapEnabled through to the underlying pool.
+     */
+    function setSwapEnabled(bool swapEnabled) external virtual onlyManager withBoundPool {
+        _require(canDisableSwaps(), Errors.FEATURE_DISABLED);
+
+        IManagedPool(pool).setSwapEnabled(swapEnabled);
+    }
+
+    /**
+     * @dev Pass a call to ManagedPool's setMustAllowlistLPs through to the underlying pool. This could
+     * be restricted in various ways. For instance, we could allow it to change state only once, or only
+     * in one direction, but there seems to be no compelling reason to do so in the reference controller.
+     *
+     * Deploying a Managed Pool with an empty allowlist could function like an LBP, or a smart treasury.
+     * Adding a set of addresses to the allowlist enables multiple seed funding sources. Disabling the
+     * allowlist, or re-enabling it after allowing public LPs, can impose or remove a "cap" on the total supply.
+     */
+    function setMustAllowlistLPs(bool mustAllowlistLPs) external virtual onlyManager withBoundPool {
+        _require(canSetMustAllowlistLPs(), Errors.FEATURE_DISABLED);
+
+        IManagedPool(pool).setMustAllowlistLPs(mustAllowlistLPs);
+    }
+
+    /**
+     * @dev Pass a call to ManagedPool's addAllowedAddress through to the underlying pool.
+     * The underlying pool handles all state/permission checks. It will revert if the LP allowlist is off.
+     */
+    function addAllowedAddress(address member) external virtual onlyManager withBoundPool {
+        IManagedPool(pool).addAllowedAddress(member);
+    }
+
+    /**
+     * @dev Pass a call to ManagedPool's removeAllowedAddress through to the underlying pool.
+     * The underlying pool handles all state/permission checks. It will revert if the address was not
+     * previouslly added to the allowlist.
+     */
+    function removeAllowedAddress(address member) external virtual onlyManager withBoundPool {
+        IManagedPool(pool).removeAllowedAddress(member);
+    }
+
+    /**
+     * @dev Transfer any BPT management fees from this contract to the recipient.
+     */
+    function withdrawCollectedManagementFees(address recipient) external virtual onlyManager withBoundPool {
+        IERC20(pool).safeTransfer(recipient, IERC20(pool).balanceOf(address(this)));
+    }
+
+    /**
+     * @dev Pass a call to ManagedPool's setManagementAumFeePercentage through to the underlying pool.
+     */
+    function setManagementAumFeePercentage(uint256 managementAumFeePercentage)
+        external
+        virtual
+        onlyManager
+        withBoundPool
+        returns (uint256)
+    {
+        _require(canChangeManagementFees(), Errors.FEATURE_DISABLED);
+
+        return IManagedPool(pool).setManagementAumFeePercentage(managementAumFeePercentage);
+    }
+}
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts pool-utils/contracts/controllers/ManagedPoolController.sol.rej pool-utils/contracts/controllers/ManagedPoolController.sol.rej
--- pool-utils/contracts/controllers/ManagedPoolController.sol.rej	1970-01-01 01:00:00.000000000 +0100
+++ pool-utils/contracts/controllers/ManagedPoolController.sol.rej	2022-10-28 09:58:56.000000000 +0200
@@ -0,0 +1,17 @@
+***************
+*** 15,21 ****
+  pragma solidity ^0.7.0;
+  pragma experimental ABIEncoderV2;
+  
+- import "@balancer-labs/v2-interfaces/contracts/pool-utils/IControlledManagedPool.sol";
+  
+  import "./BasePoolController.sol";
+  
+--- 15,21 ----
+  pragma solidity ^0.7.0;
+  pragma experimental ABIEncoderV2;
+  
++ import "../../interfaces/contracts/pool-utils/IControlledManagedPool.sol";
+  
+  import "./BasePoolController.sol";
+  
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts pool-utils/contracts/rates/PriceRateCache.sol pool-utils/contracts/rates/PriceRateCache.sol
--- pool-utils/contracts/rates/PriceRateCache.sol	2022-10-03 09:35:45.000000000 +0200
+++ pool-utils/contracts/rates/PriceRateCache.sol	2022-10-28 09:58:56.000000000 +0200
@@ -14,9 +14,9 @@
 
 pragma solidity ^0.7.0;
 
-import "@balancer-labs/v2-interfaces/contracts/solidity-utils/helpers/BalancerErrors.sol";
+import "../../interfaces/contracts/solidity-utils/helpers/BalancerErrors.sol";
 
-import "@balancer-labs/v2-solidity-utils/contracts/helpers/WordCodec.sol";
+import "../../solidity-utils/contracts/helpers/WordCodec.sol";
 
 /**
  * Price rate caches are used to avoid querying the price rate for a token every time we need to work with it. It is
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts pool-utils/contracts/test/MockBalancerPoolToken.sol pool-utils/contracts/test/MockBalancerPoolToken.sol
--- pool-utils/contracts/test/MockBalancerPoolToken.sol	2022-10-03 09:35:45.000000000 +0200
+++ pool-utils/contracts/test/MockBalancerPoolToken.sol	2022-10-28 09:58:56.000000000 +0200
@@ -14,7 +14,7 @@
 
 pragma solidity ^0.7.0;
 
-import "@balancer-labs/v2-interfaces/contracts/vault/IVault.sol";
+import "../../interfaces/contracts/vault/IVault.sol";
 
 import "../BalancerPoolToken.sol";
 
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts pool-utils/contracts/test/MockBasePool.sol pool-utils/contracts/test/MockBasePool.sol
--- pool-utils/contracts/test/MockBasePool.sol	2022-10-28 09:21:26.000000000 +0200
+++ pool-utils/contracts/test/MockBasePool.sol	2022-10-28 09:58:56.000000000 +0200
@@ -15,7 +15,7 @@
 pragma solidity ^0.7.0;
 pragma experimental ABIEncoderV2;
 
-import "@balancer-labs/v2-interfaces/contracts/pool-weighted/WeightedPoolUserData.sol";
+import "../../interfaces/contracts/pool-weighted/WeightedPoolUserData.sol";
 
 import "../BasePool.sol";
 
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts pool-utils/contracts/test/MockFailureModes.sol pool-utils/contracts/test/MockFailureModes.sol
--- pool-utils/contracts/test/MockFailureModes.sol	2022-10-03 09:35:45.000000000 +0200
+++ pool-utils/contracts/test/MockFailureModes.sol	2022-10-28 09:58:56.000000000 +0200
@@ -15,7 +15,7 @@
 pragma solidity ^0.7.0;
 pragma experimental ABIEncoderV2;
 
-import "@balancer-labs/v2-interfaces/contracts/solidity-utils/helpers/BalancerErrors.sol";
+import "../../interfaces/contracts/solidity-utils/helpers/BalancerErrors.sol";
 
 abstract contract MockFailureModes {
     enum FailureMode { INVARIANT, PRICE_RATE }
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts pool-utils/contracts/test/MockRateProvider.sol pool-utils/contracts/test/MockRateProvider.sol
--- pool-utils/contracts/test/MockRateProvider.sol	2022-10-03 09:35:45.000000000 +0200
+++ pool-utils/contracts/test/MockRateProvider.sol	2022-10-28 09:58:57.000000000 +0200
@@ -14,9 +14,9 @@
 
 pragma solidity ^0.7.0;
 
-import "@balancer-labs/v2-interfaces/contracts/pool-utils/IRateProvider.sol";
+import "../../interfaces/contracts/pool-utils/IRateProvider.sol";
 
-import "@balancer-labs/v2-solidity-utils/contracts/math/FixedPoint.sol";
+import "../../solidity-utils/contracts/math/FixedPoint.sol";
 
 contract MockRateProvider is IRateProvider {
     uint256 internal _rate;
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts pool-utils/contracts/test/MockVault.sol pool-utils/contracts/test/MockVault.sol
--- pool-utils/contracts/test/MockVault.sol	2022-10-28 09:21:26.000000000 +0200
+++ pool-utils/contracts/test/MockVault.sol	2022-10-28 09:58:57.000000000 +0200
@@ -15,15 +15,15 @@
 pragma solidity ^0.7.0;
 pragma experimental ABIEncoderV2;
 
-import "@balancer-labs/v2-interfaces/contracts/solidity-utils/openzeppelin/IERC20.sol";
+import "../../interfaces/contracts/solidity-utils/openzeppelin/IERC20.sol";
 
-import "@balancer-labs/v2-interfaces/contracts/vault/IVault.sol";
-import "@balancer-labs/v2-interfaces/contracts/vault/IBasePool.sol";
-import "@balancer-labs/v2-interfaces/contracts/vault/IGeneralPool.sol";
-import "@balancer-labs/v2-interfaces/contracts/vault/IPoolSwapStructs.sol";
-import "@balancer-labs/v2-interfaces/contracts/vault/IMinimalSwapInfoPool.sol";
+import "../../interfaces/contracts/vault/IVault.sol";
+import "../../interfaces/contracts/vault/IBasePool.sol";
+import "../../interfaces/contracts/vault/IGeneralPool.sol";
+import "../../interfaces/contracts/vault/IPoolSwapStructs.sol";
+import "../../interfaces/contracts/vault/IMinimalSwapInfoPool.sol";
 
-import "@balancer-labs/v2-vault/contracts/ProtocolFeesCollector.sol";
+import "../../vault/contracts/ProtocolFeesCollector.sol";
 
 contract MockVault is IPoolSwapStructs {
     struct Pool {
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts pool-weighted/contracts/BaseWeightedPool.sol pool-weighted/contracts/BaseWeightedPool.sol
--- pool-weighted/contracts/BaseWeightedPool.sol	2022-10-28 09:21:26.000000000 +0200
+++ pool-weighted/contracts/BaseWeightedPool.sol	2022-10-28 09:58:57.000000000 +0200
@@ -15,12 +15,12 @@
 pragma solidity ^0.7.0;
 pragma experimental ABIEncoderV2;
 
-import "@balancer-labs/v2-interfaces/contracts/pool-weighted/WeightedPoolUserData.sol";
+import "../../interfaces/contracts/pool-weighted/WeightedPoolUserData.sol";
 
-import "@balancer-labs/v2-solidity-utils/contracts/math/FixedPoint.sol";
-import "@balancer-labs/v2-solidity-utils/contracts/helpers/InputHelpers.sol";
+import "../../solidity-utils/contracts/math/FixedPoint.sol";
+import "../../solidity-utils/contracts/helpers/InputHelpers.sol";
 
-import "@balancer-labs/v2-pool-utils/contracts/BaseMinimalSwapInfoPool.sol";
+import "../../pool-utils/contracts/BaseMinimalSwapInfoPool.sol";
 
 import "./WeightedMath.sol";
 
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts pool-weighted/contracts/WeightedMath.sol pool-weighted/contracts/WeightedMath.sol
--- pool-weighted/contracts/WeightedMath.sol	2022-10-28 09:21:26.000000000 +0200
+++ pool-weighted/contracts/WeightedMath.sol	2022-10-28 09:58:57.000000000 +0200
@@ -14,9 +14,9 @@
 
 pragma solidity ^0.7.0;
 
-import "@balancer-labs/v2-solidity-utils/contracts/helpers/InputHelpers.sol";
-import "@balancer-labs/v2-solidity-utils/contracts/math/FixedPoint.sol";
-import "@balancer-labs/v2-solidity-utils/contracts/math/Math.sol";
+import "../../solidity-utils/contracts/helpers/InputHelpers.sol";
+import "../../solidity-utils/contracts/math/FixedPoint.sol";
+import "../../solidity-utils/contracts/math/Math.sol";
 
 // These functions start with an underscore, as if they were part of a contract and not a library. At some point this
 // should be fixed.
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts pool-weighted/contracts/WeightedPoolFactory.sol.orig pool-weighted/contracts/WeightedPoolFactory.sol.orig
--- pool-weighted/contracts/WeightedPoolFactory.sol.orig	1970-01-01 01:00:00.000000000 +0100
+++ pool-weighted/contracts/WeightedPoolFactory.sol.orig	2022-10-28 09:58:13.000000000 +0200
@@ -0,0 +1,66 @@
+// SPDX-License-Identifier: GPL-3.0-or-later
+// This program is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation, either version 3 of the License, or
+// (at your option) any later version.
+
+// This program is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License
+// along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+pragma solidity ^0.7.0;
+pragma experimental ABIEncoderV2;
+
+import "@balancer-labs/v2-interfaces/contracts/vault/IVault.sol";
+
+import "@balancer-labs/v2-pool-utils/contracts/factories/BasePoolFactory.sol";
+import "@balancer-labs/v2-pool-utils/contracts/factories/FactoryWidePauseWindow.sol";
+
+import "./WeightedPool.sol";
+
+contract WeightedPoolFactory is BasePoolFactory, FactoryWidePauseWindow {
+    constructor(IVault vault, IProtocolFeePercentagesProvider protocolFeeProvider)
+        BasePoolFactory(vault, protocolFeeProvider, type(WeightedPool).creationCode)
+    {
+        // solhint-disable-previous-line no-empty-blocks
+    }
+
+    /**
+     * @dev Deploys a new `WeightedPool`.
+     */
+    function create(
+        string memory name,
+        string memory symbol,
+        IERC20[] memory tokens,
+        uint256[] memory normalizedWeights,
+        IRateProvider[] memory rateProviders,
+        uint256 swapFeePercentage,
+        address owner
+    ) external returns (address) {
+        (uint256 pauseWindowDuration, uint256 bufferPeriodDuration) = getPauseConfiguration();
+
+        return
+            _create(
+                abi.encode(
+                    WeightedPool.NewPoolParams({
+                        name: name,
+                        symbol: symbol,
+                        tokens: tokens,
+                        normalizedWeights: normalizedWeights,
+                        rateProviders: rateProviders,
+                        assetManagers: new address[](tokens.length), // Don't allow asset managers,
+                        swapFeePercentage: swapFeePercentage
+                    }),
+                    getVault(),
+                    getProtocolFeePercentagesProvider(),
+                    pauseWindowDuration,
+                    bufferPeriodDuration,
+                    owner
+                )
+            );
+    }
+}
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts pool-weighted/contracts/WeightedPoolFactory.sol.rej pool-weighted/contracts/WeightedPoolFactory.sol.rej
--- pool-weighted/contracts/WeightedPoolFactory.sol.rej	1970-01-01 01:00:00.000000000 +0100
+++ pool-weighted/contracts/WeightedPoolFactory.sol.rej	2022-10-28 09:58:57.000000000 +0200
@@ -0,0 +1,23 @@
+***************
+*** 15,24 ****
+  pragma solidity ^0.7.0;
+  pragma experimental ABIEncoderV2;
+  
+- import "@balancer-labs/v2-interfaces/contracts/vault/IVault.sol";
+  
+- import "@balancer-labs/v2-pool-utils/contracts/factories/BasePoolSplitCodeFactory.sol";
+- import "@balancer-labs/v2-pool-utils/contracts/factories/FactoryWidePauseWindow.sol";
+  
+  import "./WeightedPool.sol";
+  
+--- 15,24 ----
+  pragma solidity ^0.7.0;
+  pragma experimental ABIEncoderV2;
+  
++ import "../../interfaces/contracts/vault/IVault.sol";
+  
++ import "../../pool-utils/contracts/factories/BasePoolSplitCodeFactory.sol";
++ import "../../pool-utils/contracts/factories/FactoryWidePauseWindow.sol";
+  
+  import "./WeightedPool.sol";
+  
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts pool-weighted/contracts/lib/GradualValueChange.sol pool-weighted/contracts/lib/GradualValueChange.sol
--- pool-weighted/contracts/lib/GradualValueChange.sol	2022-10-28 09:21:26.000000000 +0200
+++ pool-weighted/contracts/lib/GradualValueChange.sol	2022-10-28 09:58:57.000000000 +0200
@@ -12,8 +12,8 @@
 // You should have received a copy of the GNU General Public License
 // along with this program.  If not, see <http://www.gnu.org/licenses/>.
 
-import "@balancer-labs/v2-solidity-utils/contracts/math/FixedPoint.sol";
-import "@balancer-labs/v2-solidity-utils/contracts/math/Math.sol";
+import "../../solidity-utils/contracts/math/FixedPoint.sol";
+import "../../solidity-utils/contracts/math/Math.sol";
 
 pragma solidity ^0.7.0;
 
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts solidity-utils/contracts/helpers/Authentication.sol solidity-utils/contracts/helpers/Authentication.sol
--- solidity-utils/contracts/helpers/Authentication.sol	2022-10-03 09:35:45.000000000 +0200
+++ solidity-utils/contracts/helpers/Authentication.sol	2022-10-28 09:58:58.000000000 +0200
@@ -14,8 +14,11 @@
 
 pragma solidity ^0.7.0;
 
-import "@balancer-labs/v2-interfaces/contracts/solidity-utils/helpers/BalancerErrors.sol";
-import "@balancer-labs/v2-interfaces/contracts/solidity-utils/helpers/IAuthentication.sol";
+import "../../../interfaces/contracts/solidity-utils/helpers/BalancerErrors.sol";
+import "../../../interfaces/contracts/solidity-utils/helpers/IAuthentication.sol";
+
+// import "../../interfaces/contracts/solidity-utils/helpers/BalancerErrors.sol";
+// import "../../interfaces/contracts/solidity-utils/helpers/IAuthentication.sol";
 
 /**
  * @dev Building block for performing access control on external functions.
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts solidity-utils/contracts/helpers/CodeDeployer.sol solidity-utils/contracts/helpers/CodeDeployer.sol
--- solidity-utils/contracts/helpers/CodeDeployer.sol	2022-10-03 09:35:45.000000000 +0200
+++ solidity-utils/contracts/helpers/CodeDeployer.sol	2022-10-28 09:58:58.000000000 +0200
@@ -14,7 +14,7 @@
 
 pragma solidity ^0.7.0;
 
-import "@balancer-labs/v2-interfaces/contracts/solidity-utils/helpers/BalancerErrors.sol";
+import "../../interfaces/contracts/solidity-utils/helpers/BalancerErrors.sol";
 
 /**
  * @dev Library used to deploy contracts with specific code. This can be used for long-term storage of immutable data as
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts solidity-utils/contracts/helpers/EOASignaturesValidator.sol solidity-utils/contracts/helpers/EOASignaturesValidator.sol
--- solidity-utils/contracts/helpers/EOASignaturesValidator.sol	2022-10-28 09:21:26.000000000 +0200
+++ solidity-utils/contracts/helpers/EOASignaturesValidator.sol	2022-10-28 09:58:58.000000000 +0200
@@ -14,8 +14,8 @@
 
 pragma solidity ^0.7.0;
 
-import "@balancer-labs/v2-interfaces/contracts/solidity-utils/helpers/BalancerErrors.sol";
-import "@balancer-labs/v2-interfaces/contracts/solidity-utils/helpers/ISignaturesValidator.sol";
+import "../../interfaces/contracts/solidity-utils/helpers/BalancerErrors.sol";
+import "../../interfaces/contracts/solidity-utils/helpers/ISignaturesValidator.sol";
 
 import "../openzeppelin/EIP712.sol";
 
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts solidity-utils/contracts/helpers/ERC20Helpers.sol.orig solidity-utils/contracts/helpers/ERC20Helpers.sol.orig
--- solidity-utils/contracts/helpers/ERC20Helpers.sol.orig	1970-01-01 01:00:00.000000000 +0100
+++ solidity-utils/contracts/helpers/ERC20Helpers.sol.orig	2022-10-28 09:58:13.000000000 +0200
@@ -0,0 +1,105 @@
+// SPDX-License-Identifier: GPL-3.0-or-later
+// This program is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation, either version 3 of the License, or
+// (at your option) any later version.
+
+// This program is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License
+// along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+pragma solidity ^0.7.0;
+
+import "@balancer-labs/v2-interfaces/contracts/solidity-utils/helpers/BalancerErrors.sol";
+import "@balancer-labs/v2-interfaces/contracts/solidity-utils/openzeppelin/IERC20.sol";
+import "@balancer-labs/v2-interfaces/contracts/vault/IAsset.sol";
+
+// solhint-disable
+
+function _asIAsset(IERC20[] memory tokens) pure returns (IAsset[] memory assets) {
+    // solhint-disable-next-line no-inline-assembly
+    assembly {
+        assets := tokens
+    }
+}
+
+function _sortTokens(
+    IERC20 tokenA,
+    IERC20 tokenB,
+    IERC20 tokenC
+) pure returns (IERC20[] memory tokens) {
+    (uint256 indexTokenA, uint256 indexTokenB, uint256 indexTokenC) = _getSortedTokenIndexes(tokenA, tokenB, tokenC);
+    tokens = new IERC20[](3);
+    tokens[indexTokenA] = tokenA;
+    tokens[indexTokenB] = tokenB;
+    tokens[indexTokenC] = tokenC;
+}
+
+function _insertSorted(IERC20[] memory tokens, IERC20 token) pure returns (IERC20[] memory sorted) {
+    sorted = new IERC20[](tokens.length + 1);
+
+    if (tokens.length == 0) {
+        sorted[0] = token;
+        return sorted;
+    }
+
+    uint256 i;
+    for (i = tokens.length; i > 0 && tokens[i - 1] > token; i--) sorted[i] = tokens[i - 1];
+    for (uint256 j = 0; j < i; j++) sorted[j] = tokens[j];
+    sorted[i] = token;
+}
+
+function _findTokenIndex(IERC20[] memory tokens, IERC20 token) pure returns (uint256) {
+    // Note that while we know tokens are initially sorted, we cannot assume this will hold throughout
+    // the pool's lifetime, as pools with mutable tokens can append and remove tokens in any order.
+    uint256 tokensLength = tokens.length;
+    for (uint256 i = 0; i < tokensLength; i++) {
+        if (tokens[i] == token) {
+            return i;
+        }
+    }
+
+    _revert(Errors.INVALID_TOKEN);
+}
+
+function _getSortedTokenIndexes(
+    IERC20 tokenA,
+    IERC20 tokenB,
+    IERC20 tokenC
+)
+    pure
+    returns (
+        uint256 indexTokenA,
+        uint256 indexTokenB,
+        uint256 indexTokenC
+    )
+{
+    if (tokenA < tokenB) {
+        if (tokenB < tokenC) {
+            // (tokenA, tokenB, tokenC)
+            return (0, 1, 2);
+        } else if (tokenA < tokenC) {
+            // (tokenA, tokenC, tokenB)
+            return (0, 2, 1);
+        } else {
+            // (tokenC, tokenA, tokenB)
+            return (1, 2, 0);
+        }
+    } else {
+        // tokenB < tokenA
+        if (tokenC < tokenB) {
+            // (tokenC, tokenB, tokenA)
+            return (2, 1, 0);
+        } else if (tokenC < tokenA) {
+            // (tokenB, tokenC, tokenA)
+            return (2, 0, 1);
+        } else {
+            // (tokenB, tokenA, tokenC)
+            return (1, 0, 2);
+        }
+    }
+}
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts solidity-utils/contracts/helpers/ERC20Helpers.sol.rej solidity-utils/contracts/helpers/ERC20Helpers.sol.rej
--- solidity-utils/contracts/helpers/ERC20Helpers.sol.rej	1970-01-01 01:00:00.000000000 +0100
+++ solidity-utils/contracts/helpers/ERC20Helpers.sol.rej	2022-10-28 09:58:58.000000000 +0200
@@ -0,0 +1,19 @@
+***************
+*** 14,21 ****
+  
+  pragma solidity ^0.7.0;
+  
+- import "@balancer-labs/v2-interfaces/contracts/solidity-utils/openzeppelin/IERC20.sol";
+- import "@balancer-labs/v2-interfaces/contracts/vault/IAsset.sol";
+  
+  // solhint-disable
+  
+--- 14,21 ----
+  
+  pragma solidity ^0.7.0;
+  
++ import "../../interfaces/contracts/solidity-utils/openzeppelin/IERC20.sol";
++ import "../../interfaces/contracts/vault/IAsset.sol";
+  
+  // solhint-disable
+  
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts solidity-utils/contracts/helpers/ExtraCalldataEOASignaturesValidator.sol solidity-utils/contracts/helpers/ExtraCalldataEOASignaturesValidator.sol
--- solidity-utils/contracts/helpers/ExtraCalldataEOASignaturesValidator.sol	2022-10-03 09:35:45.000000000 +0200
+++ solidity-utils/contracts/helpers/ExtraCalldataEOASignaturesValidator.sol	2022-10-28 09:58:58.000000000 +0200
@@ -14,7 +14,7 @@
 
 pragma solidity ^0.7.0;
 
-import "@balancer-labs/v2-interfaces/contracts/solidity-utils/helpers/BalancerErrors.sol";
+import "../../interfaces/contracts/solidity-utils/helpers/BalancerErrors.sol";
 
 import "./EOASignaturesValidator.sol";
 
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts solidity-utils/contracts/helpers/InputHelpers.sol solidity-utils/contracts/helpers/InputHelpers.sol
--- solidity-utils/contracts/helpers/InputHelpers.sol	2022-10-03 09:35:45.000000000 +0200
+++ solidity-utils/contracts/helpers/InputHelpers.sol	2022-10-28 09:58:58.000000000 +0200
@@ -14,8 +14,8 @@
 
 pragma solidity ^0.7.0;
 
-import "@balancer-labs/v2-interfaces/contracts/solidity-utils/openzeppelin/IERC20.sol";
-import "@balancer-labs/v2-interfaces/contracts/solidity-utils/helpers/BalancerErrors.sol";
+import "../../../interfaces/contracts/solidity-utils/openzeppelin/IERC20.sol";
+import "../../../interfaces/contracts/solidity-utils/helpers/BalancerErrors.sol";
 
 library InputHelpers {
     function ensureInputLengthMatch(uint256 a, uint256 b) internal pure {
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts solidity-utils/contracts/helpers/OptionalOnlyCaller.sol solidity-utils/contracts/helpers/OptionalOnlyCaller.sol
--- solidity-utils/contracts/helpers/OptionalOnlyCaller.sol	2022-10-03 09:35:45.000000000 +0200
+++ solidity-utils/contracts/helpers/OptionalOnlyCaller.sol	2022-10-28 09:58:58.000000000 +0200
@@ -14,8 +14,8 @@
 
 pragma solidity ^0.7.0;
 
-import "@balancer-labs/v2-interfaces/contracts/solidity-utils/helpers/IOptionalOnlyCaller.sol";
-import "@balancer-labs/v2-interfaces/contracts/solidity-utils/helpers/BalancerErrors.sol";
+import "../../interfaces/contracts/solidity-utils/helpers/IOptionalOnlyCaller.sol";
+import "../../interfaces/contracts/solidity-utils/helpers/BalancerErrors.sol";
 
 import "./SignaturesValidator.sol";
 
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts solidity-utils/contracts/helpers/SignaturesValidator.sol solidity-utils/contracts/helpers/SignaturesValidator.sol
--- solidity-utils/contracts/helpers/SignaturesValidator.sol	2022-10-03 09:35:45.000000000 +0200
+++ solidity-utils/contracts/helpers/SignaturesValidator.sol	2022-10-28 09:58:58.000000000 +0200
@@ -14,7 +14,7 @@
 
 pragma solidity ^0.7.0;
 
-import "@balancer-labs/v2-interfaces/contracts/solidity-utils/openzeppelin/IERC1271.sol";
+import "../../interfaces/contracts/solidity-utils/openzeppelin/IERC1271.sol";
 
 import "./EOASignaturesValidator.sol";
 import "../openzeppelin/Address.sol";
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts solidity-utils/contracts/helpers/SingletonAuthentication.sol solidity-utils/contracts/helpers/SingletonAuthentication.sol
--- solidity-utils/contracts/helpers/SingletonAuthentication.sol	2022-10-03 09:35:45.000000000 +0200
+++ solidity-utils/contracts/helpers/SingletonAuthentication.sol	2022-10-28 09:58:58.000000000 +0200
@@ -14,8 +14,8 @@
 
 pragma solidity ^0.7.0;
 
-import "@balancer-labs/v2-interfaces/contracts/liquidity-mining/IAuthorizerAdaptor.sol";
-import "@balancer-labs/v2-interfaces/contracts/vault/IVault.sol";
+import "../../interfaces/contracts/liquidity-mining/IAuthorizerAdaptor.sol";
+import "../../interfaces/contracts/vault/IVault.sol";
 
 import "./Authentication.sol";
 
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts solidity-utils/contracts/helpers/TemporarilyPausable.sol solidity-utils/contracts/helpers/TemporarilyPausable.sol
--- solidity-utils/contracts/helpers/TemporarilyPausable.sol	2022-10-03 09:35:45.000000000 +0200
+++ solidity-utils/contracts/helpers/TemporarilyPausable.sol	2022-10-28 09:58:58.000000000 +0200
@@ -14,8 +14,8 @@
 
 pragma solidity ^0.7.0;
 
-import "@balancer-labs/v2-interfaces/contracts/solidity-utils/helpers/BalancerErrors.sol";
-import "@balancer-labs/v2-interfaces/contracts/solidity-utils/helpers/ITemporarilyPausable.sol";
+import "../../interfaces/contracts/solidity-utils/helpers/BalancerErrors.sol";
+import "../../interfaces/contracts/solidity-utils/helpers/ITemporarilyPausable.sol";
 
 /**
  * @dev Allows for a contract to be paused during an initial period after deployment, disabling functionality. Can be
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts solidity-utils/contracts/helpers/WordCodec.sol solidity-utils/contracts/helpers/WordCodec.sol
--- solidity-utils/contracts/helpers/WordCodec.sol	2022-10-28 09:21:26.000000000 +0200
+++ solidity-utils/contracts/helpers/WordCodec.sol	2022-10-28 09:58:58.000000000 +0200
@@ -14,7 +14,7 @@
 
 pragma solidity ^0.7.0;
 
-import "@balancer-labs/v2-interfaces/contracts/solidity-utils/helpers/BalancerErrors.sol";
+import "../../interfaces/contracts/solidity-utils/helpers/BalancerErrors.sol";
 
 import "../math/Math.sol";
 
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts solidity-utils/contracts/math/FixedPoint.sol solidity-utils/contracts/math/FixedPoint.sol
--- solidity-utils/contracts/math/FixedPoint.sol	2022-10-28 09:21:26.000000000 +0200
+++ solidity-utils/contracts/math/FixedPoint.sol	2022-10-28 09:58:58.000000000 +0200
@@ -14,7 +14,7 @@
 
 pragma solidity ^0.7.0;
 
-import "@balancer-labs/v2-interfaces/contracts/solidity-utils/helpers/BalancerErrors.sol";
+import "../../interfaces/contracts/solidity-utils/helpers/BalancerErrors.sol";
 
 import "./LogExpMath.sol";
 
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts solidity-utils/contracts/math/LogExpMath.sol solidity-utils/contracts/math/LogExpMath.sol
--- solidity-utils/contracts/math/LogExpMath.sol	2022-10-03 09:35:45.000000000 +0200
+++ solidity-utils/contracts/math/LogExpMath.sol	2022-10-28 09:58:58.000000000 +0200
@@ -14,7 +14,7 @@
 
 pragma solidity ^0.7.0;
 
-import "@balancer-labs/v2-interfaces/contracts/solidity-utils/helpers/BalancerErrors.sol";
+import "../../interfaces/contracts/solidity-utils/helpers/BalancerErrors.sol";
 
 /* solhint-disable */
 
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts solidity-utils/contracts/math/Math.sol solidity-utils/contracts/math/Math.sol
--- solidity-utils/contracts/math/Math.sol	2022-10-28 09:21:26.000000000 +0200
+++ solidity-utils/contracts/math/Math.sol	2022-10-28 09:58:58.000000000 +0200
@@ -2,7 +2,7 @@
 
 pragma solidity ^0.7.0;
 
-import "@balancer-labs/v2-interfaces/contracts/solidity-utils/helpers/BalancerErrors.sol";
+import "../../../interfaces/contracts/solidity-utils/helpers/BalancerErrors.sol";
 
 /**
  * @dev Wrappers over Solidity's arithmetic operations with added overflow checks.
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts solidity-utils/contracts/openzeppelin/Address.sol solidity-utils/contracts/openzeppelin/Address.sol
--- solidity-utils/contracts/openzeppelin/Address.sol	2022-10-03 09:35:45.000000000 +0200
+++ solidity-utils/contracts/openzeppelin/Address.sol	2022-10-28 09:58:58.000000000 +0200
@@ -5,7 +5,7 @@
 
 pragma solidity ^0.7.0;
 
-import "@balancer-labs/v2-interfaces/contracts/solidity-utils/helpers/BalancerErrors.sol";
+import "../../interfaces/contracts/solidity-utils/helpers/BalancerErrors.sol";
 
 /**
  * @dev Collection of functions related to the address type
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts solidity-utils/contracts/openzeppelin/Create2.sol solidity-utils/contracts/openzeppelin/Create2.sol
--- solidity-utils/contracts/openzeppelin/Create2.sol	2022-10-03 09:35:45.000000000 +0200
+++ solidity-utils/contracts/openzeppelin/Create2.sol	2022-10-28 09:58:58.000000000 +0200
@@ -2,7 +2,7 @@
 
 pragma solidity ^0.7.0;
 
-import "@balancer-labs/v2-interfaces/contracts/solidity-utils/helpers/BalancerErrors.sol";
+import "../../interfaces/contracts/solidity-utils/helpers/BalancerErrors.sol";
 
 /**
  * @dev Helper to make usage of the `CREATE2` EVM opcode easier and safer.
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts solidity-utils/contracts/openzeppelin/ERC20.sol solidity-utils/contracts/openzeppelin/ERC20.sol
--- solidity-utils/contracts/openzeppelin/ERC20.sol	2022-10-28 09:21:26.000000000 +0200
+++ solidity-utils/contracts/openzeppelin/ERC20.sol	2022-10-28 09:58:58.000000000 +0200
@@ -2,8 +2,8 @@
 
 pragma solidity ^0.7.0;
 
-import "@balancer-labs/v2-interfaces/contracts/solidity-utils/helpers/BalancerErrors.sol";
-import "@balancer-labs/v2-interfaces/contracts/solidity-utils/openzeppelin/IERC20.sol";
+import "../../interfaces/contracts/solidity-utils/helpers/BalancerErrors.sol";
+import "../../interfaces/contracts/solidity-utils/openzeppelin/IERC20.sol";
 
 import "./SafeMath.sol";
 
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts solidity-utils/contracts/openzeppelin/ERC20Permit.sol solidity-utils/contracts/openzeppelin/ERC20Permit.sol
--- solidity-utils/contracts/openzeppelin/ERC20Permit.sol	2022-10-03 09:35:45.000000000 +0200
+++ solidity-utils/contracts/openzeppelin/ERC20Permit.sol	2022-10-28 09:58:58.000000000 +0200
@@ -2,7 +2,7 @@
 
 pragma solidity ^0.7.0;
 
-import "@balancer-labs/v2-interfaces/contracts/solidity-utils/openzeppelin/IERC20Permit.sol";
+import "../../interfaces/contracts/solidity-utils/openzeppelin/IERC20Permit.sol";
 
 import "./ERC20.sol";
 import "../helpers/EOASignaturesValidator.sol";
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts solidity-utils/contracts/openzeppelin/EnumerableMap.sol solidity-utils/contracts/openzeppelin/EnumerableMap.sol
--- solidity-utils/contracts/openzeppelin/EnumerableMap.sol	2022-10-03 09:35:45.000000000 +0200
+++ solidity-utils/contracts/openzeppelin/EnumerableMap.sol	2022-10-28 09:58:58.000000000 +0200
@@ -11,8 +11,8 @@
 
 pragma solidity ^0.7.0;
 
-import "@balancer-labs/v2-interfaces/contracts/solidity-utils/helpers/BalancerErrors.sol";
-import "@balancer-labs/v2-interfaces/contracts/solidity-utils/openzeppelin/IERC20.sol";
+import "../../interfaces/contracts/solidity-utils/helpers/BalancerErrors.sol";
+import "../../interfaces/contracts/solidity-utils/openzeppelin/IERC20.sol";
 
 /**
  * @dev Library for managing an enumerable variant of Solidity's
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts solidity-utils/contracts/openzeppelin/EnumerableSet.sol solidity-utils/contracts/openzeppelin/EnumerableSet.sol
--- solidity-utils/contracts/openzeppelin/EnumerableSet.sol	2022-10-03 09:35:45.000000000 +0200
+++ solidity-utils/contracts/openzeppelin/EnumerableSet.sol	2022-10-28 09:58:58.000000000 +0200
@@ -7,7 +7,7 @@
 
 pragma solidity ^0.7.0;
 
-import "@balancer-labs/v2-interfaces/contracts/solidity-utils/helpers/BalancerErrors.sol";
+import "../../interfaces/contracts/solidity-utils/helpers/BalancerErrors.sol";
 
 /**
  * @dev Library for managing
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts solidity-utils/contracts/openzeppelin/Ownable.sol solidity-utils/contracts/openzeppelin/Ownable.sol
--- solidity-utils/contracts/openzeppelin/Ownable.sol	2022-10-03 09:35:45.000000000 +0200
+++ solidity-utils/contracts/openzeppelin/Ownable.sol	2022-10-28 09:58:58.000000000 +0200
@@ -5,7 +5,7 @@
 
 pragma solidity ^0.7.0;
 
-import "@balancer-labs/v2-interfaces/contracts/solidity-utils/helpers/BalancerErrors.sol";
+import "../../interfaces/contracts/solidity-utils/helpers/BalancerErrors.sol";
 
 /**
  * @dev Contract module which provides a basic access control mechanism, where
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts solidity-utils/contracts/openzeppelin/ReentrancyGuard.sol solidity-utils/contracts/openzeppelin/ReentrancyGuard.sol
--- solidity-utils/contracts/openzeppelin/ReentrancyGuard.sol	2022-10-03 09:35:45.000000000 +0200
+++ solidity-utils/contracts/openzeppelin/ReentrancyGuard.sol	2022-10-28 09:58:58.000000000 +0200
@@ -6,7 +6,7 @@
 
 pragma solidity ^0.7.0;
 
-import "@balancer-labs/v2-interfaces/contracts/solidity-utils/helpers/BalancerErrors.sol";
+import "../../../interfaces/contracts/solidity-utils/helpers/BalancerErrors.sol";
 
 /**
  * @dev Contract module that helps prevent reentrant calls to a function.
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts solidity-utils/contracts/openzeppelin/SafeCast.sol solidity-utils/contracts/openzeppelin/SafeCast.sol
--- solidity-utils/contracts/openzeppelin/SafeCast.sol	2022-10-03 09:35:45.000000000 +0200
+++ solidity-utils/contracts/openzeppelin/SafeCast.sol	2022-10-28 09:58:58.000000000 +0200
@@ -2,7 +2,7 @@
 
 pragma solidity ^0.7.0;
 
-import "@balancer-labs/v2-interfaces/contracts/solidity-utils/helpers/BalancerErrors.sol";
+import "../../interfaces/contracts/solidity-utils/helpers/BalancerErrors.sol";
 
 /**
  * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts solidity-utils/contracts/openzeppelin/SafeERC20.sol solidity-utils/contracts/openzeppelin/SafeERC20.sol
--- solidity-utils/contracts/openzeppelin/SafeERC20.sol	2022-10-28 09:21:26.000000000 +0200
+++ solidity-utils/contracts/openzeppelin/SafeERC20.sol	2022-10-28 09:58:58.000000000 +0200
@@ -6,8 +6,8 @@
 
 pragma solidity ^0.7.0;
 
-import "@balancer-labs/v2-interfaces/contracts/solidity-utils/helpers/BalancerErrors.sol";
-import "@balancer-labs/v2-interfaces/contracts/solidity-utils/openzeppelin/IERC20.sol";
+import "../../../interfaces/contracts/solidity-utils/helpers/BalancerErrors.sol";
+import "../../../interfaces/contracts/solidity-utils/openzeppelin/IERC20.sol";
 
 /**
  * @title SafeERC20
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts solidity-utils/contracts/openzeppelin/SafeMath.sol solidity-utils/contracts/openzeppelin/SafeMath.sol
--- solidity-utils/contracts/openzeppelin/SafeMath.sol	2022-10-03 09:35:45.000000000 +0200
+++ solidity-utils/contracts/openzeppelin/SafeMath.sol	2022-10-28 09:58:58.000000000 +0200
@@ -2,7 +2,7 @@
 
 pragma solidity ^0.7.0;
 
-import "@balancer-labs/v2-interfaces/contracts/solidity-utils/helpers/BalancerErrors.sol";
+import "../../interfaces/contracts/solidity-utils/helpers/BalancerErrors.sol";
 
 /**
  * @dev Wrappers over Solidity's arithmetic operations with added overflow
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts solidity-utils/contracts/test/BalancerErrorsMock.sol solidity-utils/contracts/test/BalancerErrorsMock.sol
--- solidity-utils/contracts/test/BalancerErrorsMock.sol	2022-10-28 09:21:26.000000000 +0200
+++ solidity-utils/contracts/test/BalancerErrorsMock.sol	2022-10-28 09:58:58.000000000 +0200
@@ -14,7 +14,7 @@
 
 pragma solidity ^0.7.0;
 
-import "@balancer-labs/v2-interfaces/contracts/solidity-utils/helpers/BalancerErrors.sol";
+import "../../interfaces/contracts/solidity-utils/helpers/BalancerErrors.sol";
 
 contract BalancerErrorsMock {
     function fail(uint256 code) external pure {
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts solidity-utils/contracts/test/ERC1271Mock.sol solidity-utils/contracts/test/ERC1271Mock.sol
--- solidity-utils/contracts/test/ERC1271Mock.sol	2022-10-03 09:35:45.000000000 +0200
+++ solidity-utils/contracts/test/ERC1271Mock.sol	2022-10-28 09:58:58.000000000 +0200
@@ -2,7 +2,7 @@
 
 pragma solidity ^0.7.0;
 
-import "@balancer-labs/v2-interfaces/contracts/solidity-utils/openzeppelin/IERC1271.sol";
+import "../../interfaces/contracts/solidity-utils/openzeppelin/IERC1271.sol";
 
 contract ERC1271Mock is IERC1271 {
     mapping(bytes32 => bool) private _approved;
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts solidity-utils/contracts/test/EnumerableMapMock.sol solidity-utils/contracts/test/EnumerableMapMock.sol
--- solidity-utils/contracts/test/EnumerableMapMock.sol	2022-10-03 09:35:45.000000000 +0200
+++ solidity-utils/contracts/test/EnumerableMapMock.sol	2022-10-28 09:58:58.000000000 +0200
@@ -2,7 +2,7 @@
 
 pragma solidity ^0.7.0;
 
-import "@balancer-labs/v2-interfaces/contracts/solidity-utils/openzeppelin/IERC20.sol";
+import "../../interfaces/contracts/solidity-utils/openzeppelin/IERC20.sol";
 
 import "../openzeppelin/EnumerableMap.sol";
 
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts solidity-utils/contracts/test/SingletonAuthenticationMock.sol solidity-utils/contracts/test/SingletonAuthenticationMock.sol
--- solidity-utils/contracts/test/SingletonAuthenticationMock.sol	2022-10-03 09:35:45.000000000 +0200
+++ solidity-utils/contracts/test/SingletonAuthenticationMock.sol	2022-10-28 09:58:58.000000000 +0200
@@ -14,7 +14,7 @@
 
 pragma solidity ^0.7.0;
 
-import "@balancer-labs/v2-interfaces/contracts/vault/IVault.sol";
+import "../../interfaces/contracts/vault/IVault.sol";
 
 import "../helpers/SingletonAuthentication.sol";
 
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts standalone-utils/contracts/BALTokenHolder.sol standalone-utils/contracts/BALTokenHolder.sol
--- standalone-utils/contracts/BALTokenHolder.sol	2022-10-03 09:35:45.000000000 +0200
+++ standalone-utils/contracts/BALTokenHolder.sol	2022-10-28 09:58:59.000000000 +0200
@@ -14,12 +14,12 @@
 
 pragma solidity ^0.7.0;
 
-import "@balancer-labs/v2-interfaces/contracts/liquidity-mining/IBalancerToken.sol";
-import "@balancer-labs/v2-interfaces/contracts/standalone-utils/IBALTokenHolder.sol";
-import "@balancer-labs/v2-interfaces/contracts/vault/IVault.sol";
+import "../../interfaces/contracts/liquidity-mining/IBalancerToken.sol";
+import "../../interfaces/contracts/standalone-utils/IBALTokenHolder.sol";
+import "../../interfaces/contracts/vault/IVault.sol";
 
-import "@balancer-labs/v2-solidity-utils/contracts/helpers/SingletonAuthentication.sol";
-import "@balancer-labs/v2-solidity-utils/contracts/openzeppelin/SafeERC20.sol";
+import "../../solidity-utils/contracts/helpers/SingletonAuthentication.sol";
+import "../../solidity-utils/contracts/openzeppelin/SafeERC20.sol";
 
 /**
  * @dev This contract simply holds the BAL token and delegates to Balancer Governance the permission to withdraw it. It
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts standalone-utils/contracts/BALTokenHolderFactory.sol standalone-utils/contracts/BALTokenHolderFactory.sol
--- standalone-utils/contracts/BALTokenHolderFactory.sol	2022-10-03 09:35:45.000000000 +0200
+++ standalone-utils/contracts/BALTokenHolderFactory.sol	2022-10-28 09:58:59.000000000 +0200
@@ -14,11 +14,11 @@
 
 pragma solidity ^0.7.0;
 
-import "@balancer-labs/v2-interfaces/contracts/liquidity-mining/IBalancerToken.sol";
-import "@balancer-labs/v2-interfaces/contracts/standalone-utils/IBALTokenHolderFactory.sol";
-import "@balancer-labs/v2-interfaces/contracts/vault/IVault.sol";
+import "../../interfaces/contracts/liquidity-mining/IBalancerToken.sol";
+import "../../interfaces/contracts/standalone-utils/IBALTokenHolderFactory.sol";
+import "../../interfaces/contracts/vault/IVault.sol";
 
-import "@balancer-labs/v2-solidity-utils/contracts/helpers/Authentication.sol";
+import "../../solidity-utils/contracts/helpers/Authentication.sol";
 
 import "./BALTokenHolder.sol";
 
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts standalone-utils/contracts/BalancerQueries.sol standalone-utils/contracts/BalancerQueries.sol
--- standalone-utils/contracts/BalancerQueries.sol	2022-10-03 09:35:45.000000000 +0200
+++ standalone-utils/contracts/BalancerQueries.sol	2022-10-28 09:58:59.000000000 +0200
@@ -15,16 +15,16 @@
 pragma solidity ^0.7.0;
 pragma experimental ABIEncoderV2;
 
-import "@balancer-labs/v2-interfaces/contracts/solidity-utils/helpers/BalancerErrors.sol";
-import "@balancer-labs/v2-interfaces/contracts/solidity-utils/misc/IWETH.sol";
-import "@balancer-labs/v2-interfaces/contracts/vault/IVault.sol";
-import "@balancer-labs/v2-interfaces/contracts/vault/IBasePool.sol";
+import "../../interfaces/contracts/solidity-utils/helpers/BalancerErrors.sol";
+import "../../interfaces/contracts/solidity-utils/misc/IWETH.sol";
+import "../../interfaces/contracts/vault/IVault.sol";
+import "../../interfaces/contracts/vault/IBasePool.sol";
 
-import "@balancer-labs/v2-interfaces/contracts/standalone-utils/IBalancerQueries.sol";
+import "../../interfaces/contracts/standalone-utils/IBalancerQueries.sol";
 
-import "@balancer-labs/v2-vault/contracts/AssetHelpers.sol";
+import "../../vault/contracts/AssetHelpers.sol";
 
-import "@balancer-labs/v2-solidity-utils/contracts/helpers/InputHelpers.sol";
+import "../../solidity-utils/contracts/helpers/InputHelpers.sol";
 
 /**
  * @dev This contract simply builds on top of the Balancer V2 architecture to provide useful helpers to users.
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts standalone-utils/contracts/ProtocolFeePercentagesProvider.sol standalone-utils/contracts/ProtocolFeePercentagesProvider.sol
--- standalone-utils/contracts/ProtocolFeePercentagesProvider.sol	2022-10-03 09:35:45.000000000 +0200
+++ standalone-utils/contracts/ProtocolFeePercentagesProvider.sol	2022-10-28 09:58:59.000000000 +0200
@@ -15,11 +15,11 @@
 pragma solidity ^0.7.0;
 pragma experimental ABIEncoderV2;
 
-import "@balancer-labs/v2-interfaces/contracts/vault/IProtocolFeesCollector.sol";
-import "@balancer-labs/v2-interfaces/contracts/standalone-utils/IProtocolFeePercentagesProvider.sol";
+import "../../interfaces/contracts/vault/IProtocolFeesCollector.sol";
+import "../../interfaces/contracts/standalone-utils/IProtocolFeePercentagesProvider.sol";
 
-import "@balancer-labs/v2-solidity-utils/contracts/helpers/SingletonAuthentication.sol";
-import "@balancer-labs/v2-solidity-utils/contracts/openzeppelin/SafeCast.sol";
+import "../../solidity-utils/contracts/helpers/SingletonAuthentication.sol";
+import "../../solidity-utils/contracts/openzeppelin/SafeCast.sol";
 
 contract ProtocolFeePercentagesProvider is IProtocolFeePercentagesProvider, SingletonAuthentication {
     using SafeCast for uint256;
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts standalone-utils/contracts/ProtocolFeeSplitter.sol standalone-utils/contracts/ProtocolFeeSplitter.sol
--- standalone-utils/contracts/ProtocolFeeSplitter.sol	2022-10-28 09:50:45.000000000 +0200
+++ standalone-utils/contracts/ProtocolFeeSplitter.sol	2022-10-28 09:58:59.000000000 +0200
@@ -137,7 +137,7 @@
         return _poolSettings[poolId];
     }
 
-    function _canPerform(bytes32 actionId, address account) internal view override returns (bool) {
+    function _canPerform(bytes32 actionId, address account) internal view override virtual returns (bool) {
         return _getAuthorizer().canPerform(actionId, account, address(this));
     }
 
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts standalone-utils/contracts/ProtocolFeeSplitter.sol.orig standalone-utils/contracts/ProtocolFeeSplitter.sol.orig
--- standalone-utils/contracts/ProtocolFeeSplitter.sol.orig	1970-01-01 01:00:00.000000000 +0100
+++ standalone-utils/contracts/ProtocolFeeSplitter.sol.orig	2022-10-28 09:58:14.000000000 +0200
@@ -0,0 +1,196 @@
+// SPDX-License-Identifier: GPL-3.0-or-later
+// This program is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation, either version 3 of the License, or
+// (at your option) any later version.
+
+// This program is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License
+// along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+pragma solidity >=0.7.0 <0.9.0;
+pragma experimental ABIEncoderV2;
+
+import "@balancer-labs/v2-interfaces/contracts/standalone-utils/IProtocolFeeSplitter.sol";
+import "@balancer-labs/v2-interfaces/contracts/standalone-utils/IProtocolFeesWithdrawer.sol";
+import "@balancer-labs/v2-interfaces/contracts/vault/IVault.sol";
+import "@balancer-labs/v2-solidity-utils/contracts/helpers/Authentication.sol";
+import "@balancer-labs/v2-solidity-utils/contracts/math/FixedPoint.sol";
+import "@balancer-labs/v2-interfaces/contracts/vault/IProtocolFeesCollector.sol";
+
+interface Pool {
+    function getOwner() external view returns (address);
+}
+
+/**
+ * @dev This contract is responsible for splitting the BPT profits collected
+ * by ProtocolFeeCollector between the pool's owner and Balancers DAO treasury
+ * Nothing happens for non-BPT tokens (WETH, WBTC, etc...)
+ */
+contract ProtocolFeeSplitter is IProtocolFeeSplitter, Authentication {
+    using FixedPoint for uint256;
+
+    // All fee percentages are 18-decimal fixed point numbers.
+    // Absolute maximum fee percentage (1e18 = 100%).
+    uint256 private constant _MAX_REVENUE_SHARING_FEE_PERCENTAGE = 50e16; // 50%
+
+    IProtocolFeesWithdrawer private immutable _protocolFeesWithdrawer;
+
+    // Balancer vault
+    IVault private immutable _vault;
+
+    // Balancer DAO Multisig
+    address private _treasury;
+
+    // Can be updated by BAL governance (1e18 = 100%, 1e16 = 1%).
+    uint256 private _defaultRevenueSharingFeePercentage;
+
+    // poolId => PoolSettings
+    mapping(bytes32 => RevenueShareSettings) private _poolSettings;
+
+    constructor(IProtocolFeesWithdrawer protocolFeesWithdrawer, address treasury)
+        // The ProtocolFeeSplitter is a singleton, so it simply uses its own address to disambiguate action
+        // identifiers.
+        Authentication(bytes32(uint256(address(this))))
+    {
+        _protocolFeesWithdrawer = protocolFeesWithdrawer;
+        _treasury = treasury;
+        _vault = protocolFeesWithdrawer.getProtocolFeesCollector().vault();
+    }
+
+    function setRevenueSharingFeePercentage(bytes32 poolId, uint256 newSwapFeePercentage)
+        external
+        override
+        authenticate
+    {
+        _require(newSwapFeePercentage <= _MAX_REVENUE_SHARING_FEE_PERCENTAGE, Errors.SPLITTER_FEE_PERCENTAGE_TOO_HIGH);
+        _poolSettings[poolId].revenueSharePercentageOverride = uint96(newSwapFeePercentage);
+        emit PoolRevenueShareChanged(poolId, newSwapFeePercentage);
+    }
+
+    function setDefaultRevenueSharingFeePercentage(uint256 feePercentage) external override authenticate {
+        _require(feePercentage <= _MAX_REVENUE_SHARING_FEE_PERCENTAGE, Errors.SPLITTER_FEE_PERCENTAGE_TOO_HIGH);
+        _defaultRevenueSharingFeePercentage = feePercentage;
+        emit DefaultRevenueSharingFeePercentageChanged(feePercentage);
+    }
+
+    function setTreasury(address newTreasury) external override authenticate {
+        _treasury = newTreasury;
+        emit TreasuryChanged(newTreasury);
+    }
+
+    function setPoolBeneficiary(bytes32 poolId, address newBeneficiary) external override {
+        (address pool, ) = _vault.getPool(poolId);
+        _require(msg.sender == Pool(pool).getOwner(), Errors.SENDER_NOT_ALLOWED);
+        _poolSettings[poolId].beneficiary = newBeneficiary;
+        emit PoolBeneficiaryChanged(poolId, newBeneficiary);
+    }
+
+    function collectFees(bytes32 poolId) external override returns (uint256 beneficiaryAmount, uint256 treasuryAmount) {
+        (address pool, ) = _vault.getPool(poolId);
+        IERC20 bpt = IERC20(pool);
+        address beneficiary = _poolSettings[poolId].beneficiary;
+
+        (beneficiaryAmount, treasuryAmount) = _getAmounts(bpt, poolId);
+
+        if (beneficiaryAmount != 0) {
+            _withdrawBpt(bpt, beneficiaryAmount, beneficiary);
+        }
+
+        _withdrawBpt(bpt, treasuryAmount, _treasury);
+        emit FeesCollected(poolId, beneficiary, beneficiaryAmount, _treasury, treasuryAmount);
+    }
+
+    function getAmounts(bytes32 poolId)
+        external
+        view
+        override
+        returns (uint256 beneficiaryAmount, uint256 treasuryAmount)
+    {
+        (address pool, ) = _vault.getPool(poolId);
+        IERC20 bpt = IERC20(pool);
+
+        return _getAmounts(bpt, poolId);
+    }
+
+    function getProtocolFeesWithdrawer() external view override returns (IProtocolFeesWithdrawer) {
+        return _protocolFeesWithdrawer;
+    }
+
+    function getDefaultRevenueSharingFeePercentage() external view override returns (uint256) {
+        return _defaultRevenueSharingFeePercentage;
+    }
+
+    function getVault() external view override returns (IVault) {
+        return _vault;
+    }
+
+    function getTreasury() external view override returns (address) {
+        return _treasury;
+    }
+
+    function getPoolSettings(bytes32 poolId) external view override returns (RevenueShareSettings memory) {
+        return _poolSettings[poolId];
+    }
+
+    function _canPerform(bytes32 actionId, address account) internal view override returns (bool) {
+        return _getAuthorizer().canPerform(actionId, account, address(this));
+    }
+
+    function _getAuthorizer() internal view returns (IAuthorizer) {
+        return _protocolFeesWithdrawer.getProtocolFeesCollector().getAuthorizer();
+    }
+
+    function _withdrawBpt(
+        IERC20 bpt,
+        uint256 amount,
+        address to
+    ) private {
+        IERC20[] memory tokens = new IERC20[](1);
+        uint256[] memory amounts = new uint256[](1);
+        tokens[0] = bpt;
+        amounts[0] = amount;
+        _protocolFeesWithdrawer.withdrawCollectedFees(tokens, amounts, to);
+    }
+
+    function _getAmounts(IERC20 bpt, bytes32 poolId)
+        private
+        view
+        returns (uint256 beneficiaryAmount, uint256 treasuryAmount)
+    {
+        IProtocolFeesWithdrawer protocolFeesWithdrawer = _protocolFeesWithdrawer;
+        uint256 feeCollectorBptBalance = bpt.balanceOf(address(protocolFeesWithdrawer.getProtocolFeesCollector()));
+        if (feeCollectorBptBalance == 0) {
+            return (0, 0);
+        }
+
+        address beneficiary = _poolSettings[poolId].beneficiary;
+        if (beneficiary == address(0)) {
+            return (0, feeCollectorBptBalance);
+        }
+
+        (beneficiaryAmount, treasuryAmount) = _computeAmounts(
+            feeCollectorBptBalance,
+            _getPoolBeneficiaryFeePercentage(poolId)
+        );
+    }
+
+    function _computeAmounts(uint256 feeCollectorBptBalance, uint256 feePercentage)
+        private
+        pure
+        returns (uint256 ownerAmount, uint256 treasuryAmount)
+    {
+        ownerAmount = FixedPoint.divDown(FixedPoint.mulDown(feeCollectorBptBalance, feePercentage), 1e18);
+        treasuryAmount = feeCollectorBptBalance.sub(ownerAmount);
+    }
+
+    function _getPoolBeneficiaryFeePercentage(bytes32 poolId) private view returns (uint256) {
+        uint256 poolFeeOverride = _poolSettings[poolId].revenueSharePercentageOverride;
+        uint256 feePercentage = poolFeeOverride != 0 ? poolFeeOverride : _defaultRevenueSharingFeePercentage;
+        return feePercentage;
+    }
+}
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts standalone-utils/contracts/ProtocolFeeSplitter.sol.rej standalone-utils/contracts/ProtocolFeeSplitter.sol.rej
--- standalone-utils/contracts/ProtocolFeeSplitter.sol.rej	1970-01-01 01:00:00.000000000 +0100
+++ standalone-utils/contracts/ProtocolFeeSplitter.sol.rej	2022-10-28 09:58:59.000000000 +0200
@@ -0,0 +1,53 @@
+***************
+*** 15,26 ****
+  pragma solidity ^0.7.0;
+  pragma experimental ABIEncoderV2;
+  
+- import "@balancer-labs/v2-interfaces/contracts/standalone-utils/IProtocolFeeSplitter.sol";
+- 
+- import "@balancer-labs/v2-solidity-utils/contracts/helpers/Authentication.sol";
+- import "@balancer-labs/v2-solidity-utils/contracts/helpers/VaultHelpers.sol";
+- import "@balancer-labs/v2-solidity-utils/contracts/math/Math.sol";
+- import "@balancer-labs/v2-interfaces/contracts/vault/IProtocolFeesCollector.sol";
+  
+  interface Pool {
+      function getOwner() external returns (address);
+--- 15,31 ----
+  pragma solidity ^0.7.0;
+  pragma experimental ABIEncoderV2;
+  
++ import "../../interfaces/contracts/standalone-utils/IProtocolFeeSplitter.sol";
++ import "../../solidity-utils/contracts/helpers/Authentication.sol";
++ import "../../solidity-utils/contracts/helpers/VaultHelpers.sol";
++ import "../../solidity-utils/contracts/math/Math.sol";
++ import "../../interfaces/contracts/vault/IProtocolFeesCollector.sol";
++ 
++ // import "../../interfaces/contracts/standalone-utils/IProtocolFeeSplitter.sol";
++ // import "../../../harness/VaultHelpersHarness.sol";
++ // import "../../solidity-utils/contracts/helpers/Authentication.sol";
++ // import "../../solidity-utils/contracts/math/Math.sol";
++ // import "../../interfaces/contracts/vault/IProtocolFeesCollector.sol";
+  
+  interface Pool {
+      function getOwner() external returns (address);
+***************
+*** 43,51 ****
+  
+      // All fee percentages are 18-decimal fixed point numbers.
+      // Absolute maximum fee percentages (1e18 = 100%, 1e16 = 1%).
+-     uint256 private constant _MIN_REVENUE_SHARING_FEE_PERCENTAGE = 1e16; // 1%
+-     uint256 private constant _MAX_REVENUE_SHARING_FEE_PERCENTAGE = 50e16; // 50%
+-     address private constant _DELEGATE_OWNER = 0xBA1BA1ba1BA1bA1bA1Ba1BA1ba1BA1bA1ba1ba1B;
+  
+      IProtocolFeesCollector public immutable protocolFeesCollector;
+  
+--- 48,56 ----
+  
+      // All fee percentages are 18-decimal fixed point numbers.
+      // Absolute maximum fee percentages (1e18 = 100%, 1e16 = 1%).
++     uint256 public constant _MIN_REVENUE_SHARING_FEE_PERCENTAGE = 1e16; // 1%
++     uint256 public constant _MAX_REVENUE_SHARING_FEE_PERCENTAGE = 50e16; // 50%
++     address public constant _DELEGATE_OWNER = 0xBA1BA1ba1BA1bA1bA1Ba1BA1ba1BA1bA1ba1ba1B;
+  
+      IProtocolFeesCollector public immutable protocolFeesCollector;
+  
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts standalone-utils/contracts/ProtocolFeesWithdrawer.sol standalone-utils/contracts/ProtocolFeesWithdrawer.sol
--- standalone-utils/contracts/ProtocolFeesWithdrawer.sol	2022-10-03 09:35:45.000000000 +0200
+++ standalone-utils/contracts/ProtocolFeesWithdrawer.sol	2022-10-28 09:58:59.000000000 +0200
@@ -14,11 +14,11 @@
 
 pragma solidity ^0.7.0;
 
-import "@balancer-labs/v2-interfaces/contracts/standalone-utils/IProtocolFeesWithdrawer.sol";
-import "@balancer-labs/v2-interfaces/contracts/vault/IVault.sol";
+import "../../interfaces/contracts/standalone-utils/IProtocolFeesWithdrawer.sol";
+import "../../interfaces/contracts/vault/IVault.sol";
 
-import "@balancer-labs/v2-solidity-utils/contracts/helpers/SingletonAuthentication.sol";
-import "@balancer-labs/v2-solidity-utils/contracts/openzeppelin/EnumerableSet.sol";
+import "../../solidity-utils/contracts/helpers/SingletonAuthentication.sol";
+import "../../solidity-utils/contracts/openzeppelin/EnumerableSet.sol";
 
 /**
  * @author Balancer Labs
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts standalone-utils/contracts/relayer/AaveWrapping.sol.orig standalone-utils/contracts/relayer/AaveWrapping.sol.orig
--- standalone-utils/contracts/relayer/AaveWrapping.sol.orig	1970-01-01 01:00:00.000000000 +0100
+++ standalone-utils/contracts/relayer/AaveWrapping.sol.orig	2022-10-28 09:58:14.000000000 +0200
@@ -0,0 +1,93 @@
+// SPDX-License-Identifier: GPL-3.0-or-later
+// This program is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation, either version 3 of the License, or
+// (at your option) any later version.
+
+// This program is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License
+// along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+pragma solidity ^0.7.0;
+pragma experimental ABIEncoderV2;
+
+import "@balancer-labs/v2-interfaces/contracts/standalone-utils/IStaticATokenLM.sol";
+import "@balancer-labs/v2-interfaces/contracts/vault/IVault.sol";
+
+import "@balancer-labs/v2-solidity-utils/contracts/openzeppelin/Address.sol";
+import "@balancer-labs/v2-solidity-utils/contracts/openzeppelin/SafeERC20.sol";
+
+import "./IBaseRelayerLibrary.sol";
+
+/**
+ * @title AaveWrapping
+ * @notice Allows users to wrap and unwrap Aave's aTokens into their StaticAToken wrappers
+ * @dev All functions must be payable so they can be called from a multicall involving ETH
+ */
+abstract contract AaveWrapping is IBaseRelayerLibrary {
+    using Address for address payable;
+    using SafeERC20 for IERC20;
+
+    function wrapAaveDynamicToken(
+        IStaticATokenLM staticToken,
+        address sender,
+        address recipient,
+        uint256 amount,
+        bool fromUnderlying,
+        uint256 outputReference
+    ) external payable {
+        if (_isChainedReference(amount)) {
+            amount = _getChainedReferenceValue(amount);
+        }
+
+        // Aave's StaticATokens allow wrapping either an aToken or the underlying asset.
+        // We can query which token to pull and approve from the wrapper contract.
+        IERC20 dynamicToken = fromUnderlying ? staticToken.ASSET() : staticToken.ATOKEN();
+
+        // The wrap caller is the implicit sender of tokens, so if the goal is for the tokens
+        // to be sourced from outside the relayer, we must first pull them here.
+        if (sender != address(this)) {
+            require(sender == msg.sender, "Incorrect sender");
+            _pullToken(sender, dynamicToken, amount);
+        }
+
+        dynamicToken.safeApprove(address(staticToken), amount);
+        // Use 0 for the referral code
+        uint256 result = staticToken.deposit(recipient, amount, 0, fromUnderlying);
+
+        if (_isChainedReference(outputReference)) {
+            _setChainedReferenceValue(outputReference, result);
+        }
+    }
+
+    function unwrapAaveStaticToken(
+        IStaticATokenLM staticToken,
+        address sender,
+        address recipient,
+        uint256 amount,
+        bool toUnderlying,
+        uint256 outputReference
+    ) external payable {
+        if (_isChainedReference(amount)) {
+            amount = _getChainedReferenceValue(amount);
+        }
+
+        // The unwrap caller is the implicit sender of tokens, so if the goal is for the tokens
+        // to be sourced from outside the relayer, we must first pull them here.
+        if (sender != address(this)) {
+            require(sender == msg.sender, "Incorrect sender");
+            _pullToken(sender, staticToken, amount);
+        }
+
+        // No approval is needed here, as the Static Tokens are burned directly from the relayer's account
+        (, uint256 result) = staticToken.withdraw(recipient, amount, toUnderlying);
+
+        if (_isChainedReference(outputReference)) {
+            _setChainedReferenceValue(outputReference, result);
+        }
+    }
+}
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts standalone-utils/contracts/relayer/AaveWrapping.sol.rej standalone-utils/contracts/relayer/AaveWrapping.sol.rej
--- standalone-utils/contracts/relayer/AaveWrapping.sol.rej	1970-01-01 01:00:00.000000000 +0100
+++ standalone-utils/contracts/relayer/AaveWrapping.sol.rej	2022-10-28 09:58:59.000000000 +0200
@@ -0,0 +1,23 @@
+***************
+*** 15,24 ****
+  pragma solidity ^0.7.0;
+  pragma experimental ABIEncoderV2;
+  
+- import "@balancer-labs/v2-interfaces/contracts/standalone-utils/IStaticATokenLM.sol";
+- import "@balancer-labs/v2-interfaces/contracts/vault/IVault.sol";
+  
+- import "@balancer-labs/v2-solidity-utils/contracts/openzeppelin/Address.sol";
+  
+  import "./IBaseRelayerLibrary.sol";
+  
+--- 15,24 ----
+  pragma solidity ^0.7.0;
+  pragma experimental ABIEncoderV2;
+  
++ import "../../interfaces/contracts/standalone-utils/IStaticATokenLM.sol";
++ import "../../interfaces/contracts/vault/IVault.sol";
+  
++ import "../../solidity-utils/contracts/openzeppelin/Address.sol";
+  
+  import "./IBaseRelayerLibrary.sol";
+  
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts standalone-utils/contracts/relayer/BalancerRelayer.sol standalone-utils/contracts/relayer/BalancerRelayer.sol
--- standalone-utils/contracts/relayer/BalancerRelayer.sol	2022-10-03 09:35:45.000000000 +0200
+++ standalone-utils/contracts/relayer/BalancerRelayer.sol	2022-10-28 09:58:59.000000000 +0200
@@ -15,10 +15,10 @@
 pragma solidity ^0.7.0;
 pragma experimental ABIEncoderV2;
 
-import "@balancer-labs/v2-interfaces/contracts/standalone-utils/IBalancerRelayer.sol";
+import "../../interfaces/contracts/standalone-utils/IBalancerRelayer.sol";
 
-import "@balancer-labs/v2-solidity-utils/contracts/openzeppelin/ReentrancyGuard.sol";
-import "@balancer-labs/v2-solidity-utils/contracts/openzeppelin/Address.sol";
+import "../../solidity-utils/contracts/openzeppelin/ReentrancyGuard.sol";
+import "../../solidity-utils/contracts/openzeppelin/Address.sol";
 
 /**
  * @title Balancer Relayer
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts standalone-utils/contracts/relayer/BaseRelayerLibrary.sol.orig standalone-utils/contracts/relayer/BaseRelayerLibrary.sol.orig
--- standalone-utils/contracts/relayer/BaseRelayerLibrary.sol.orig	1970-01-01 01:00:00.000000000 +0100
+++ standalone-utils/contracts/relayer/BaseRelayerLibrary.sol.orig	2022-10-28 09:58:14.000000000 +0200
@@ -0,0 +1,218 @@
+// SPDX-License-Identifier: GPL-3.0-or-later
+// This program is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation, either version 3 of the License, or
+// (at your option) any later version.
+
+// This program is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License
+// along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+pragma solidity ^0.7.0;
+pragma experimental ABIEncoderV2;
+
+import "@balancer-labs/v2-interfaces/contracts/standalone-utils/IBalancerRelayer.sol";
+import "@balancer-labs/v2-interfaces/contracts/vault/IVault.sol";
+import "@balancer-labs/v2-solidity-utils/contracts/openzeppelin/SafeERC20.sol";
+
+import "./IBaseRelayerLibrary.sol";
+import "./BalancerRelayer.sol";
+
+/**
+ * @title Base Relayer Library
+ * @notice Core functionality of a relayer. Allow users to use a signature to approve this contract
+ * to take further actions on their behalf.
+ * @dev
+ * Relayers are composed of two contracts:
+ *  - A `BalancerRelayer` contract, which acts as a single point of entry into the system through a multicall function
+ *  - A library contract such as this one, which defines the allowed behaviour of the relayer
+
+ * NOTE: Only the entrypoint contract should be allowlisted by Balancer governance as a relayer, so that the Vault
+ * will reject calls from outside the entrypoint context.
+ *
+ * This contract should neither be allowlisted as a relayer, nor called directly by the user.
+ * No guarantees can be made about fund safety when calling this contract in an improper manner.
+ */
+contract BaseRelayerLibrary is IBaseRelayerLibrary {
+    using Address for address;
+    using SafeERC20 for IERC20;
+
+    IVault private immutable _vault;
+    IBalancerRelayer private immutable _entrypoint;
+
+    constructor(IVault vault) IBaseRelayerLibrary(vault.WETH()) {
+        _vault = vault;
+        _entrypoint = new BalancerRelayer(vault, address(this));
+    }
+
+    function getVault() public view override returns (IVault) {
+        return _vault;
+    }
+
+    function getEntrypoint() public view returns (IBalancerRelayer) {
+        return _entrypoint;
+    }
+
+    /**
+     * @notice Sets whether a particular relayer is authorised to act on behalf of the user
+     */
+    function setRelayerApproval(
+        address relayer,
+        bool approved,
+        bytes calldata authorisation
+    ) external payable {
+        require(relayer == address(this) || !approved, "Relayer can only approve itself");
+        bytes memory data = abi.encodePacked(
+            abi.encodeWithSelector(_vault.setRelayerApproval.selector, msg.sender, relayer, approved),
+            authorisation
+        );
+
+        address(_vault).functionCall(data);
+    }
+
+    /**
+     * @notice Approves the Vault to use tokens held in the relayer
+     * @dev This is needed to avoid having to send intermediate tokens back to the user
+     */
+    function approveVault(IERC20 token, uint256 amount) public override {
+        if (_isChainedReference(amount)) {
+            amount = _getChainedReferenceValue(amount);
+        }
+        // TODO: gas golf this a bit
+        token.safeApprove(address(getVault()), amount);
+    }
+
+    /**
+     * @notice Returns the amount referenced by chained reference `ref`.
+     * @dev It does not alter the reference (even if it's marked as temporary).
+     */
+    function peekChainedReferenceValue(uint256 ref) public view override returns (uint256 value) {
+        (, value) = _peekChainedReferenceValue(ref);
+    }
+
+    function _pullToken(
+        address sender,
+        IERC20 token,
+        uint256 amount
+    ) internal override {
+        if (amount == 0) return;
+        IERC20[] memory tokens = new IERC20[](1);
+        tokens[0] = token;
+        uint256[] memory amounts = new uint256[](1);
+        amounts[0] = amount;
+
+        _pullTokens(sender, tokens, amounts);
+    }
+
+    function _pullTokens(
+        address sender,
+        IERC20[] memory tokens,
+        uint256[] memory amounts
+    ) internal override {
+        IVault.UserBalanceOp[] memory ops = new IVault.UserBalanceOp[](tokens.length);
+        for (uint256 i; i < tokens.length; i++) {
+            ops[i] = IVault.UserBalanceOp({
+                asset: IAsset(address(tokens[i])),
+                amount: amounts[i],
+                sender: sender,
+                recipient: payable(address(this)),
+                kind: IVault.UserBalanceOpKind.TRANSFER_EXTERNAL
+            });
+        }
+
+        getVault().manageUserBalance(ops);
+    }
+
+    /**
+     * @dev Returns true if `amount` is not actually an amount, but rather a chained reference.
+     */
+    function _isChainedReference(uint256 amount) internal pure override returns (bool) {
+        // First 3 nibbles are enough to determine if it's a chained reference.
+        return
+            (amount & 0xfff0000000000000000000000000000000000000000000000000000000000000) ==
+            0xba10000000000000000000000000000000000000000000000000000000000000;
+    }
+
+    /**
+     * @dev Returns true if `ref` is temporary reference, i.e. to be deleted after reading it.
+     */
+    function _isTemporaryChainedReference(uint256 amount) internal pure returns (bool) {
+        // First 3 nibbles determine if it's a chained reference.
+        // If the 4th nibble is 0 it is temporary; otherwise it is considered read-only.
+        // In practice, we shall use '0xba11' for read-only references.
+        return
+            (amount & 0xffff000000000000000000000000000000000000000000000000000000000000) ==
+            0xba10000000000000000000000000000000000000000000000000000000000000;
+    }
+
+    /**
+     * @dev Stores `value` as the amount referenced by chained reference `ref`.
+     */
+    function _setChainedReferenceValue(uint256 ref, uint256 value) internal override {
+        bytes32 slot = _getStorageSlot(ref);
+
+        // Since we do manual calculation of storage slots, it is easier (and cheaper) to rely on internal assembly to
+        // access it.
+        // solhint-disable-next-line no-inline-assembly
+        assembly {
+            sstore(slot, value)
+        }
+    }
+
+    /**
+     * @dev Returns the amount referenced by chained reference `ref`.
+     * If the reference is temporary, it will be cleared after reading it, so they can each only be read once.
+     * If the reference is not temporary (i.e. read-only), it will not be cleared after reading it
+     * (see `_isTemporaryChainedReference` function).
+     */
+    function _getChainedReferenceValue(uint256 ref) internal override returns (uint256) {
+        (bytes32 slot, uint256 value) = _peekChainedReferenceValue(ref);
+
+        if (_isTemporaryChainedReference(ref)) {
+            // solhint-disable-next-line no-inline-assembly
+            assembly {
+                sstore(slot, 0)
+            }
+        }
+        return value;
+    }
+
+    /**
+     * @dev Returns the storage slot for reference `ref` as well as the amount referenced by it.
+     * It does not alter the reference (even if it's marked as temporary).
+     */
+    function _peekChainedReferenceValue(uint256 ref) private view returns (bytes32 slot, uint256 value) {
+        slot = _getStorageSlot(ref);
+
+        // Since we do manual calculation of storage slots, it is easier (and cheaper) to rely on internal assembly to
+        // access it.
+        // solhint-disable-next-line no-inline-assembly
+        assembly {
+            value := sload(slot)
+        }
+    }
+
+    // solhint-disable-next-line var-name-mixedcase
+    bytes32 private immutable _TEMP_STORAGE_SUFFIX = keccak256("balancer.base-relayer-library");
+
+    function _getStorageSlot(uint256 ref) private view returns (bytes32) {
+        // This replicates the mechanism Solidity uses to allocate storage slots for mappings, but using a hash as the
+        // mapping's storage slot, and subtracting 1 at the end. This should be more than enough to prevent collisions
+        // with other state variables this or derived contracts might use.
+        // See https://docs.soliditylang.org/en/v0.8.9/internals/layout_in_storage.html
+
+        return bytes32(uint256(keccak256(abi.encodePacked(_removeReferencePrefix(ref), _TEMP_STORAGE_SUFFIX))) - 1);
+    }
+
+    /**
+     * @dev Returns a reference without its prefix.
+     * Use this function to calculate the storage slot so that it's the same for temporary and read-only references.
+     */
+    function _removeReferencePrefix(uint256 ref) private pure returns (uint256) {
+        return (ref & 0x0000ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);
+    }
+}
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts standalone-utils/contracts/relayer/BaseRelayerLibrary.sol.rej standalone-utils/contracts/relayer/BaseRelayerLibrary.sol.rej
--- standalone-utils/contracts/relayer/BaseRelayerLibrary.sol.rej	1970-01-01 01:00:00.000000000 +0100
+++ standalone-utils/contracts/relayer/BaseRelayerLibrary.sol.rej	2022-10-28 09:58:59.000000000 +0200
@@ -0,0 +1,19 @@
+***************
+*** 15,22 ****
+  pragma solidity ^0.7.0;
+  pragma experimental ABIEncoderV2;
+  
+- import "@balancer-labs/v2-interfaces/contracts/standalone-utils/IBalancerRelayer.sol";
+- import "@balancer-labs/v2-interfaces/contracts/vault/IVault.sol";
+  
+  import "./IBaseRelayerLibrary.sol";
+  import "./BalancerRelayer.sol";
+--- 15,22 ----
+  pragma solidity ^0.7.0;
+  pragma experimental ABIEncoderV2;
+  
++ import "../../interfaces/contracts/standalone-utils/IBalancerRelayer.sol";
++ import "../../interfaces/contracts/vault/IVault.sol";
+  
+  import "./IBaseRelayerLibrary.sol";
+  import "./BalancerRelayer.sol";
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts standalone-utils/contracts/relayer/ERC4626Wrapping.sol.orig standalone-utils/contracts/relayer/ERC4626Wrapping.sol.orig
--- standalone-utils/contracts/relayer/ERC4626Wrapping.sol.orig	1970-01-01 01:00:00.000000000 +0100
+++ standalone-utils/contracts/relayer/ERC4626Wrapping.sol.orig	2022-10-28 09:58:14.000000000 +0200
@@ -0,0 +1,87 @@
+// SPDX-License-Identifier: GPL-3.0-or-later
+// This program is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation, either version 3 of the License, or
+// (at your option) any later version.
+
+// This program is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License
+// along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+pragma solidity ^0.7.0;
+pragma experimental ABIEncoderV2;
+
+import "@balancer-labs/v2-interfaces/contracts/solidity-utils/misc/IERC4626.sol";
+import "@balancer-labs/v2-interfaces/contracts/vault/IVault.sol";
+
+import "@balancer-labs/v2-solidity-utils/contracts/openzeppelin/Address.sol";
+import "@balancer-labs/v2-solidity-utils/contracts/openzeppelin/SafeERC20.sol";
+
+import "./IBaseRelayerLibrary.sol";
+
+/**
+ * @title ERC4626Wrapping
+ * @notice Allows users to wrap and unwrap ERC4626 tokens
+ * @dev All functions must be payable so they can be called from a multicall involving ETH
+ */
+abstract contract ERC4626Wrapping is IBaseRelayerLibrary {
+    using Address for address payable;
+    using SafeERC20 for IERC20;
+
+    function wrapERC4626(
+        IERC4626 wrappedToken,
+        address sender,
+        address recipient,
+        uint256 amount,
+        uint256 outputReference
+    ) external payable {
+        if (_isChainedReference(amount)) {
+            amount = _getChainedReferenceValue(amount);
+        }
+
+        IERC20 underlying = IERC20(wrappedToken.asset());
+
+        // The wrap caller is the implicit sender of tokens, so if the goal is for the tokens
+        // to be sourced from outside the relayer, we must first pull them here.
+        if (sender != address(this)) {
+            require(sender == msg.sender, "Incorrect sender");
+            _pullToken(sender, underlying, amount);
+        }
+
+        underlying.safeApprove(address(wrappedToken), amount);
+        uint256 result = wrappedToken.deposit(amount, recipient);
+
+        if (_isChainedReference(outputReference)) {
+            _setChainedReferenceValue(outputReference, result);
+        }
+    }
+
+    function unwrapERC4626(
+        IERC4626 wrappedToken,
+        address sender,
+        address recipient,
+        uint256 amount,
+        uint256 outputReference
+    ) external payable {
+        if (_isChainedReference(amount)) {
+            amount = _getChainedReferenceValue(amount);
+        }
+
+        // The unwrap caller is the implicit sender of tokens, so if the goal is for the tokens
+        // to be sourced from outside the relayer, we must first pull them here.
+        if (sender != address(this)) {
+            require(sender == msg.sender, "Incorrect sender");
+            _pullToken(sender, wrappedToken, amount);
+        }
+
+        uint256 result = wrappedToken.redeem(amount, recipient, address(this));
+
+        if (_isChainedReference(outputReference)) {
+            _setChainedReferenceValue(outputReference, result);
+        }
+    }
+}
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts standalone-utils/contracts/relayer/ERC4626Wrapping.sol.rej standalone-utils/contracts/relayer/ERC4626Wrapping.sol.rej
--- standalone-utils/contracts/relayer/ERC4626Wrapping.sol.rej	1970-01-01 01:00:00.000000000 +0100
+++ standalone-utils/contracts/relayer/ERC4626Wrapping.sol.rej	2022-10-28 09:58:59.000000000 +0200
@@ -0,0 +1,23 @@
+***************
+*** 15,24 ****
+  pragma solidity ^0.7.0;
+  pragma experimental ABIEncoderV2;
+  
+- import "@balancer-labs/v2-interfaces/contracts/solidity-utils/misc/IERC4626.sol";
+- import "@balancer-labs/v2-interfaces/contracts/vault/IVault.sol";
+  
+- import "@balancer-labs/v2-solidity-utils/contracts/openzeppelin/Address.sol";
+  
+  import "./IBaseRelayerLibrary.sol";
+  
+--- 15,24 ----
+  pragma solidity ^0.7.0;
+  pragma experimental ABIEncoderV2;
+  
++ import "../../interfaces/contracts/solidity-utils/misc/IERC4626.sol";
++ import "../../interfaces/contracts/vault/IVault.sol";
+  
++ import "../../solidity-utils/contracts/openzeppelin/Address.sol";
+  
+  import "./IBaseRelayerLibrary.sol";
+  
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts standalone-utils/contracts/relayer/GaugeActions.sol.orig standalone-utils/contracts/relayer/GaugeActions.sol.orig
--- standalone-utils/contracts/relayer/GaugeActions.sol.orig	1970-01-01 01:00:00.000000000 +0100
+++ standalone-utils/contracts/relayer/GaugeActions.sol.orig	2022-10-28 09:58:14.000000000 +0200
@@ -0,0 +1,123 @@
+// SPDX-License-Identifier: GPL-3.0-or-later
+// This program is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation, either version 3 of the License, or
+// (at your option) any later version.
+
+// This program is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License
+// along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+pragma solidity ^0.7.0;
+pragma experimental ABIEncoderV2;
+
+import "@balancer-labs/v2-interfaces/contracts/liquidity-mining/IBalancerMinter.sol";
+import "@balancer-labs/v2-interfaces/contracts/liquidity-mining/IStakingLiquidityGauge.sol";
+import "@balancer-labs/v2-interfaces/contracts/vault/IVault.sol";
+
+import "@balancer-labs/v2-solidity-utils/contracts/openzeppelin/Address.sol";
+import "@balancer-labs/v2-solidity-utils/contracts/openzeppelin/SafeERC20.sol";
+
+import "./IBaseRelayerLibrary.sol";
+
+/**
+ * @title GaugeActions
+ * @dev All functions must be payable so they can be called from a multicall involving ETH
+ */
+abstract contract GaugeActions is IBaseRelayerLibrary {
+    using Address for address payable;
+    using SafeERC20 for IERC20;
+
+    IBalancerMinter private immutable _balancerMinter;
+
+    /**
+     * @dev The zero address may be passed as balancerMinter to safely disable features
+     *      which only exist on mainnet
+     */
+    constructor(IBalancerMinter balancerMinter) {
+        _balancerMinter = balancerMinter;
+    }
+
+    function gaugeDeposit(
+        IStakingLiquidityGauge gauge,
+        address sender,
+        address recipient,
+        uint256 amount
+    ) external payable {
+        if (_isChainedReference(amount)) {
+            amount = _getChainedReferenceValue(amount);
+        }
+
+        // We can query which token to pull and approve from the wrapper contract.
+        IERC20 bptToken = gauge.lp_token();
+
+        // The deposit caller is the implicit sender of tokens, so if the goal is for the tokens
+        // to be sourced from outside the relayer, we must first pull them here.
+        if (sender != address(this)) {
+            require(sender == msg.sender, "Incorrect sender");
+            _pullToken(sender, bptToken, amount);
+        }
+
+        bptToken.safeApprove(address(gauge), amount);
+        gauge.deposit(amount, recipient);
+    }
+
+    function gaugeWithdraw(
+        IStakingLiquidityGauge gauge,
+        address sender,
+        address recipient,
+        uint256 amount
+    ) external payable {
+        if (_isChainedReference(amount)) {
+            amount = _getChainedReferenceValue(amount);
+        }
+
+        // The unwrap caller is the implicit sender of tokens, so if the goal is for the tokens
+        // to be sourced from outside the relayer, we must first pull them here.
+        if (sender != address(this)) {
+            require(sender == msg.sender, "Incorrect sender");
+            _pullToken(sender, IERC20(gauge), amount);
+        }
+
+        // No approval is needed here, as the gauge Tokens are burned directly from the relayer's account.
+        gauge.withdraw(amount);
+
+        // Gauge does not support withdrawing BPT to another address atomically.
+        // If intended recipient is not the relayer then forward the withdrawn BPT on to the recipient.
+        if (recipient != address(this)) {
+            IERC20 bptToken = gauge.lp_token();
+
+            bptToken.safeTransfer(recipient, amount);
+        }
+    }
+
+    function gaugeMint(address[] calldata gauges, uint256 outputReference) external payable {
+        uint256 balMinted = _balancerMinter.mintManyFor(gauges, msg.sender);
+
+        if (_isChainedReference(outputReference)) {
+            _setChainedReferenceValue(outputReference, balMinted);
+        }
+    }
+
+    function gaugeSetMinterApproval(
+        bool approval,
+        address user,
+        uint256 deadline,
+        uint8 v,
+        bytes32 r,
+        bytes32 s
+    ) external payable {
+        _balancerMinter.setMinterApprovalWithSignature(address(this), approval, user, deadline, v, r, s);
+    }
+
+    function gaugeClaimRewards(IStakingLiquidityGauge[] calldata gauges) external payable {
+        uint256 numGauges = gauges.length;
+        for (uint256 i; i < numGauges; ++i) {
+            gauges[i].claim_rewards(msg.sender);
+        }
+    }
+}
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts standalone-utils/contracts/relayer/GaugeActions.sol.rej standalone-utils/contracts/relayer/GaugeActions.sol.rej
--- standalone-utils/contracts/relayer/GaugeActions.sol.rej	1970-01-01 01:00:00.000000000 +0100
+++ standalone-utils/contracts/relayer/GaugeActions.sol.rej	2022-10-28 09:58:59.000000000 +0200
@@ -0,0 +1,25 @@
+***************
+*** 15,25 ****
+  pragma solidity ^0.7.0;
+  pragma experimental ABIEncoderV2;
+  
+- import "@balancer-labs/v2-interfaces/contracts/liquidity-mining/IBalancerMinter.sol";
+- import "@balancer-labs/v2-interfaces/contracts/liquidity-mining/IStakingLiquidityGauge.sol";
+- import "@balancer-labs/v2-interfaces/contracts/vault/IVault.sol";
+  
+- import "@balancer-labs/v2-solidity-utils/contracts/openzeppelin/Address.sol";
+  
+  import "./IBaseRelayerLibrary.sol";
+  
+--- 15,25 ----
+  pragma solidity ^0.7.0;
+  pragma experimental ABIEncoderV2;
+  
++ import "../../interfaces/contracts/liquidity-mining/IBalancerMinter.sol";
++ import "../../interfaces/contracts/liquidity-mining/IStakingLiquidityGauge.sol";
++ import "../../interfaces/contracts/vault/IVault.sol";
+  
++ import "../../solidity-utils/contracts/openzeppelin/Address.sol";
+  
+  import "./IBaseRelayerLibrary.sol";
+  
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts standalone-utils/contracts/relayer/IBaseRelayerLibrary.sol standalone-utils/contracts/relayer/IBaseRelayerLibrary.sol
--- standalone-utils/contracts/relayer/IBaseRelayerLibrary.sol	2022-10-28 09:21:26.000000000 +0200
+++ standalone-utils/contracts/relayer/IBaseRelayerLibrary.sol	2022-10-28 09:58:59.000000000 +0200
@@ -15,9 +15,9 @@
 pragma solidity ^0.7.0;
 pragma experimental ABIEncoderV2;
 
-import "@balancer-labs/v2-interfaces/contracts/vault/IVault.sol";
+import "../../interfaces/contracts/vault/IVault.sol";
 
-import "@balancer-labs/v2-vault/contracts/AssetHelpers.sol";
+import "../../vault/contracts/AssetHelpers.sol";
 
 /**
  * @title IBaseRelayerLibrary
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts standalone-utils/contracts/relayer/LidoWrapping.sol.orig standalone-utils/contracts/relayer/LidoWrapping.sol.orig
--- standalone-utils/contracts/relayer/LidoWrapping.sol.orig	1970-01-01 01:00:00.000000000 +0100
+++ standalone-utils/contracts/relayer/LidoWrapping.sol.orig	2022-10-28 09:58:14.000000000 +0200
@@ -0,0 +1,154 @@
+// SPDX-License-Identifier: GPL-3.0-or-later
+// This program is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation, either version 3 of the License, or
+// (at your option) any later version.
+
+// This program is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License
+// along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+pragma solidity ^0.7.0;
+pragma experimental ABIEncoderV2;
+
+import "@balancer-labs/v2-interfaces/contracts/standalone-utils/IstETH.sol";
+import "@balancer-labs/v2-interfaces/contracts/standalone-utils/IwstETH.sol";
+import "@balancer-labs/v2-interfaces/contracts/vault/IVault.sol";
+
+import "@balancer-labs/v2-solidity-utils/contracts/openzeppelin/Address.sol";
+import "@balancer-labs/v2-solidity-utils/contracts/openzeppelin/SafeERC20.sol";
+
+import "./IBaseRelayerLibrary.sol";
+
+/**
+ * @title LidoWrapping
+ * @notice Allows users to wrap and unwrap stETH
+ * @dev All functions must be payable so they can be called from a multicall involving ETH
+ */
+abstract contract LidoWrapping is IBaseRelayerLibrary {
+    using Address for address payable;
+    using SafeERC20 for IERC20;
+
+    IstETH private immutable _stETH;
+    IwstETH private immutable _wstETH;
+
+    /**
+     * @dev The zero address may be passed as wstETH to safely disable this module
+     * @param wstETH - the address of Lido's wrapped stETH contract
+     */
+    constructor(IERC20 wstETH) {
+        // Safely disable stETH wrapping if no address has been passed for wstETH
+        _stETH = wstETH != IERC20(0) ? IwstETH(address(wstETH)).stETH() : IstETH(0);
+        _wstETH = IwstETH(address(wstETH));
+    }
+
+    function wrapStETH(
+        address sender,
+        address recipient,
+        uint256 amount,
+        uint256 outputReference
+    ) external payable {
+        if (_isChainedReference(amount)) {
+            amount = _getChainedReferenceValue(amount);
+        }
+
+        // The wrap caller is the implicit token sender, so if the goal is for the tokens
+        // to be sourced from outside the relayer, we must first pull them here.
+        if (sender != address(this)) {
+            require(sender == msg.sender, "Incorrect sender");
+            _pullToken(sender, _stETH, amount);
+        }
+
+        IERC20(_stETH).safeApprove(address(_wstETH), amount);
+        uint256 result = IwstETH(_wstETH).wrap(amount);
+
+        if (recipient != address(this)) {
+            IERC20(_wstETH).safeTransfer(recipient, result);
+        }
+
+        if (_isChainedReference(outputReference)) {
+            _setChainedReferenceValue(outputReference, result);
+        }
+    }
+
+    function unwrapWstETH(
+        address sender,
+        address recipient,
+        uint256 amount,
+        uint256 outputReference
+    ) external payable {
+        if (_isChainedReference(amount)) {
+            amount = _getChainedReferenceValue(amount);
+        }
+
+        // The unwrap caller is the implicit token sender, so if the goal is for the tokens
+        // to be sourced from outside the relayer, we must first pull them here.
+        if (sender != address(this)) {
+            require(sender == msg.sender, "Incorrect sender");
+            _pullToken(sender, _wstETH, amount);
+        }
+
+        // No approval is needed here, as wstETH is burned directly from the relayer's account
+        uint256 result = _wstETH.unwrap(amount);
+
+        if (recipient != address(this)) {
+            IERC20(_stETH).safeTransfer(recipient, result);
+        }
+
+        if (_isChainedReference(outputReference)) {
+            _setChainedReferenceValue(outputReference, result);
+        }
+    }
+
+    function stakeETH(
+        address recipient,
+        uint256 amount,
+        uint256 outputReference
+    ) external payable {
+        if (_isChainedReference(amount)) {
+            amount = _getChainedReferenceValue(amount);
+        }
+
+        uint256 result = _stETH.submit{ value: amount }(address(this));
+
+        if (recipient != address(this)) {
+            IERC20(_stETH).safeTransfer(recipient, result);
+        }
+
+        if (_isChainedReference(outputReference)) {
+            _setChainedReferenceValue(outputReference, result);
+        }
+    }
+
+    function stakeETHAndWrap(
+        address recipient,
+        uint256 amount,
+        uint256 outputReference
+    ) external payable {
+        if (_isChainedReference(amount)) {
+            amount = _getChainedReferenceValue(amount);
+        }
+
+        // We must query this separately, since the wstETH contract doesn't return how much wstETH is minted.
+        uint256 result = _wstETH.getWstETHByStETH(amount);
+
+        // The fallback function on the wstETH contract automatically stakes and wraps any ETH sent to it.
+        // We can then send the ETH safely, and only have to ensure that the call doesn't revert.
+        //
+        // This would be dangerous if `_wstETH` were set to the zero address. However, in this scenario,
+        // this function would have already reverted during the call to `getWstETHByStETH`, preventing loss of funds.
+        payable(address(_wstETH)).sendValue(amount);
+
+        if (recipient != address(this)) {
+            IERC20(_wstETH).safeTransfer(recipient, result);
+        }
+
+        if (_isChainedReference(outputReference)) {
+            _setChainedReferenceValue(outputReference, result);
+        }
+    }
+}
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts standalone-utils/contracts/relayer/LidoWrapping.sol.rej standalone-utils/contracts/relayer/LidoWrapping.sol.rej
--- standalone-utils/contracts/relayer/LidoWrapping.sol.rej	1970-01-01 01:00:00.000000000 +0100
+++ standalone-utils/contracts/relayer/LidoWrapping.sol.rej	2022-10-28 09:58:59.000000000 +0200
@@ -0,0 +1,25 @@
+***************
+*** 15,25 ****
+  pragma solidity ^0.7.0;
+  pragma experimental ABIEncoderV2;
+  
+- import "@balancer-labs/v2-interfaces/contracts/standalone-utils/IstETH.sol";
+- import "@balancer-labs/v2-interfaces/contracts/standalone-utils/IwstETH.sol";
+- import "@balancer-labs/v2-interfaces/contracts/vault/IVault.sol";
+  
+- import "@balancer-labs/v2-solidity-utils/contracts/openzeppelin/Address.sol";
+  
+  import "./IBaseRelayerLibrary.sol";
+  
+--- 15,25 ----
+  pragma solidity ^0.7.0;
+  pragma experimental ABIEncoderV2;
+  
++ import "../../interfaces/contracts/standalone-utils/IstETH.sol";
++ import "../../interfaces/contracts/standalone-utils/IwstETH.sol";
++ import "../../interfaces/contracts/vault/IVault.sol";
+  
++ import "../../solidity-utils/contracts/openzeppelin/Address.sol";
+  
+  import "./IBaseRelayerLibrary.sol";
+  
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts standalone-utils/contracts/relayer/UnbuttonWrapping.sol.orig standalone-utils/contracts/relayer/UnbuttonWrapping.sol.orig
--- standalone-utils/contracts/relayer/UnbuttonWrapping.sol.orig	1970-01-01 01:00:00.000000000 +0100
+++ standalone-utils/contracts/relayer/UnbuttonWrapping.sol.orig	2022-10-28 09:58:14.000000000 +0200
@@ -0,0 +1,102 @@
+// SPDX-License-Identifier: GPL-3.0-or-later
+// This program is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation, either version 3 of the License, or
+// (at your option) any later version.
+
+// This program is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License
+// along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+pragma solidity ^0.7.0;
+pragma experimental ABIEncoderV2;
+
+import "@balancer-labs/v2-interfaces/contracts/solidity-utils/openzeppelin/IERC20.sol";
+import "@balancer-labs/v2-interfaces/contracts/pool-linear/IUnbuttonToken.sol";
+
+import "@balancer-labs/v2-solidity-utils/contracts/openzeppelin/Address.sol";
+import "@balancer-labs/v2-solidity-utils/contracts/openzeppelin/SafeERC20.sol";
+
+import "./IBaseRelayerLibrary.sol";
+
+/**
+ * @title UnbuttonWrapping
+ * @author @aalavandhan1984 (eng@fragments.org)
+ * @notice Allows users to wrap and unwrap any rebasing elastic balance token into a
+ *         a non-rebasing static balance version using the Unbutton wrapper.
+ * @dev All functions must be payable so that it can be called as part of a multicall involving ETH.
+ *      The rebasing token to be wrapped is called the "underlying" token.
+ *      The wrapped non-rebasing token is called the "wrapped" token.
+ *      Learn more: https://github.com/buttonwood-protocol/button-wrappers/blob/main/contracts/UnbuttonToken.sol
+ */
+abstract contract UnbuttonWrapping is IBaseRelayerLibrary {
+    using Address for address payable;
+    using SafeERC20 for IERC20;
+
+    /// @param wrapperToken The address of the wrapper.
+    /// @param sender The address of sender.
+    /// @param sender The address of recepient.
+    /// @param uAmount The underling token amount to be deposited into the wrapper.
+    /// @param outputReference Chained output reference.
+    function wrapUnbuttonToken(
+        IUnbuttonToken wrapperToken,
+        address sender,
+        address recipient,
+        uint256 uAmount,
+        uint256 outputReference
+    ) external payable {
+        if (_isChainedReference(uAmount)) {
+            uAmount = _getChainedReferenceValue(uAmount);
+        }
+
+        IERC20 underlyingToken = IERC20(wrapperToken.underlying());
+
+        // The wrap caller is the implicit sender of tokens, so if the goal is for the tokens
+        // to be sourced from outside the relayer, we must first pull them here.
+        if (sender != address(this)) {
+            require(sender == msg.sender, "Incorrect sender");
+            _pullToken(sender, underlyingToken, uAmount);
+        }
+
+        underlyingToken.safeApprove(address(wrapperToken), uAmount);
+        uint256 mintAmount = wrapperToken.depositFor(recipient, uAmount);
+
+        if (_isChainedReference(outputReference)) {
+            _setChainedReferenceValue(outputReference, mintAmount);
+        }
+    }
+
+    /// @param wrapperToken The address of the wrapper.
+    /// @param sender The address of sender.
+    /// @param sender The address of recepient.
+    /// @param amount The amount of wrapped tokens to be burnt for underlying tokens.
+    /// @param outputReference Chained output reference.
+    function unwrapUnbuttonToken(
+        IUnbuttonToken wrapperToken,
+        address sender,
+        address recipient,
+        uint256 amount,
+        uint256 outputReference
+    ) external payable {
+        if (_isChainedReference(amount)) {
+            amount = _getChainedReferenceValue(amount);
+        }
+
+        // The wrap caller is the implicit sender of tokens, so if the goal is for the tokens
+        // to be sourced from outside the relayer, we must first them pull them here.
+        if (sender != address(this)) {
+            require(sender == msg.sender, "Incorrect sender");
+            _pullToken(sender, wrapperToken, amount);
+        }
+
+        uint256 withdrawnUAmount = wrapperToken.burnTo(recipient, amount);
+
+        if (_isChainedReference(outputReference)) {
+            _setChainedReferenceValue(outputReference, withdrawnUAmount);
+        }
+    }
+}
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts standalone-utils/contracts/relayer/UnbuttonWrapping.sol.rej standalone-utils/contracts/relayer/UnbuttonWrapping.sol.rej
--- standalone-utils/contracts/relayer/UnbuttonWrapping.sol.rej	1970-01-01 01:00:00.000000000 +0100
+++ standalone-utils/contracts/relayer/UnbuttonWrapping.sol.rej	2022-10-28 09:58:59.000000000 +0200
@@ -0,0 +1,23 @@
+***************
+*** 15,24 ****
+  pragma solidity ^0.7.0;
+  pragma experimental ABIEncoderV2;
+  
+- import "@balancer-labs/v2-interfaces/contracts/solidity-utils/openzeppelin/IERC20.sol";
+- import "@balancer-labs/v2-interfaces/contracts/pool-linear/IUnbuttonToken.sol";
+  
+- import "@balancer-labs/v2-solidity-utils/contracts/openzeppelin/Address.sol";
+  
+  import "./IBaseRelayerLibrary.sol";
+  
+--- 15,24 ----
+  pragma solidity ^0.7.0;
+  pragma experimental ABIEncoderV2;
+  
++ import "../../interfaces/contracts/solidity-utils/openzeppelin/IERC20.sol";
++ import "../../interfaces/contracts/pool-linear/IUnbuttonToken.sol";
+  
++ import "../../solidity-utils/contracts/openzeppelin/Address.sol";
+  
+  import "./IBaseRelayerLibrary.sol";
+  
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts standalone-utils/contracts/relayer/VaultActions.sol standalone-utils/contracts/relayer/VaultActions.sol
--- standalone-utils/contracts/relayer/VaultActions.sol	2022-10-28 09:21:26.000000000 +0200
+++ standalone-utils/contracts/relayer/VaultActions.sol	2022-10-28 09:58:59.000000000 +0200
@@ -15,12 +15,12 @@
 pragma solidity ^0.7.0;
 pragma experimental ABIEncoderV2;
 
-import "@balancer-labs/v2-interfaces/contracts/vault/IVault.sol";
-import "@balancer-labs/v2-interfaces/contracts/pool-weighted/WeightedPoolUserData.sol";
+import "../../interfaces/contracts/vault/IVault.sol";
+import "../../interfaces/contracts/pool-weighted/WeightedPoolUserData.sol";
 
-import "@balancer-labs/v2-solidity-utils/contracts/helpers/InputHelpers.sol";
-import "@balancer-labs/v2-solidity-utils/contracts/helpers/VaultHelpers.sol";
-import "@balancer-labs/v2-solidity-utils/contracts/math/Math.sol";
+import "../../solidity-utils/contracts/helpers/InputHelpers.sol";
+import "../../solidity-utils/contracts/helpers/VaultHelpers.sol";
+import "../../solidity-utils/contracts/math/Math.sol";
 
 import "./IBaseRelayerLibrary.sol";
 
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts standalone-utils/contracts/relayer/VaultPermit.sol standalone-utils/contracts/relayer/VaultPermit.sol
--- standalone-utils/contracts/relayer/VaultPermit.sol	2022-10-03 09:35:45.000000000 +0200
+++ standalone-utils/contracts/relayer/VaultPermit.sol	2022-10-28 09:58:59.000000000 +0200
@@ -15,9 +15,9 @@
 pragma solidity ^0.7.0;
 pragma experimental ABIEncoderV2;
 
-import "@balancer-labs/v2-interfaces/contracts/solidity-utils/openzeppelin/IERC20Permit.sol";
-import "@balancer-labs/v2-interfaces/contracts/solidity-utils/openzeppelin/IERC20PermitDAI.sol";
-import "@balancer-labs/v2-interfaces/contracts/vault/IVault.sol";
+import "../../interfaces/contracts/solidity-utils/openzeppelin/IERC20Permit.sol";
+import "../../interfaces/contracts/solidity-utils/openzeppelin/IERC20PermitDAI.sol";
+import "../../interfaces/contracts/vault/IVault.sol";
 
 import "./IBaseRelayerLibrary.sol";
 
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts standalone-utils/contracts/relayer/special/DoubleEntrypointFixRelayer.sol standalone-utils/contracts/relayer/special/DoubleEntrypointFixRelayer.sol
--- standalone-utils/contracts/relayer/special/DoubleEntrypointFixRelayer.sol	2022-10-28 09:21:26.000000000 +0200
+++ standalone-utils/contracts/relayer/special/DoubleEntrypointFixRelayer.sol	2022-10-28 09:58:59.000000000 +0200
@@ -15,13 +15,13 @@
 pragma solidity ^0.7.0;
 pragma experimental ABIEncoderV2;
 
-import "@balancer-labs/v2-interfaces/contracts/pool-stable/StablePoolUserData.sol";
-import "@balancer-labs/v2-interfaces/contracts/pool-weighted/WeightedPoolUserData.sol";
-import "@balancer-labs/v2-interfaces/contracts/vault/IVault.sol";
-import "@balancer-labs/v2-interfaces/contracts/vault/IFlashLoanRecipient.sol";
+import "../../interfaces/contracts/pool-stable/StablePoolUserData.sol";
+import "../../interfaces/contracts/pool-weighted/WeightedPoolUserData.sol";
+import "../../interfaces/contracts/vault/IVault.sol";
+import "../../interfaces/contracts/vault/IFlashLoanRecipient.sol";
 
-import "@balancer-labs/v2-solidity-utils/contracts/helpers/ERC20Helpers.sol";
-import "@balancer-labs/v2-solidity-utils/contracts/openzeppelin/SafeERC20.sol";
+import "../../solidity-utils/contracts/helpers/ERC20Helpers.sol";
+import "../../solidity-utils/contracts/openzeppelin/SafeERC20.sol";
 
 /**
  * @title DoubleEntrypointFixRelayer
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts standalone-utils/contracts/relayer/special/DoubleEntrypointFixRelayer.sol.orig standalone-utils/contracts/relayer/special/DoubleEntrypointFixRelayer.sol.orig
--- standalone-utils/contracts/relayer/special/DoubleEntrypointFixRelayer.sol.orig	1970-01-01 01:00:00.000000000 +0100
+++ standalone-utils/contracts/relayer/special/DoubleEntrypointFixRelayer.sol.orig	2022-10-28 09:58:14.000000000 +0200
@@ -0,0 +1,181 @@
+// SPDX-License-Identifier: GPL-3.0-or-later
+// This program is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation, either version 3 of the License, or
+// (at your option) any later version.
+
+// This program is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License
+// along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+pragma solidity ^0.7.0;
+pragma experimental ABIEncoderV2;
+
+import "@balancer-labs/v2-interfaces/contracts/pool-stable/StablePoolUserData.sol";
+import "@balancer-labs/v2-interfaces/contracts/pool-weighted/WeightedPoolUserData.sol";
+import "@balancer-labs/v2-interfaces/contracts/vault/IVault.sol";
+import "@balancer-labs/v2-interfaces/contracts/vault/IFlashLoanRecipient.sol";
+
+import "@balancer-labs/v2-solidity-utils/contracts/helpers/ERC20Helpers.sol";
+import "@balancer-labs/v2-solidity-utils/contracts/openzeppelin/SafeERC20.sol";
+
+/**
+ * @title DoubleEntrypointFixRelayer
+ * @notice This contract performs mitigations to safeguard funds affected by double-entrypoint tokens (mostly Synthetix
+ * tokens). It doesn't use the standard relayer architecture to simplify the code.
+ */
+contract DoubleEntrypointFixRelayer is IFlashLoanRecipient {
+    using SafeERC20 for IERC20;
+
+    // solhint-disable const-name-snakecase
+    IERC20 public constant BTC_STABLE_POOL_ADDRESS = IERC20(0xFeadd389a5c427952D8fdb8057D6C8ba1156cC56);
+    bytes32 public constant BTC_STABLE_POOL_ID = 0xfeadd389a5c427952d8fdb8057d6c8ba1156cc56000000000000000000000066;
+
+    // solhint-disable const-name-snakecase
+    IERC20 public constant wBTC = IERC20(0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599);
+    IERC20 public constant renBTC = IERC20(0xEB4C2781e4ebA804CE9a9803C67d0893436bB27D);
+    IERC20 public constant sBTC = IERC20(0xfE18be6b3Bd88A2D2A7f928d00292E7a9963CfC6);
+    IERC20 public constant sBTC_IMPLEMENTATION = IERC20(0x18FcC34bdEaaF9E3b69D2500343527c0c995b1d6);
+
+    IERC20 public constant SNX_WEIGHTED_POOL_ADDRESS = IERC20(0x072f14B85ADd63488DDaD88f855Fda4A99d6aC9B);
+    bytes32 public constant SNX_WEIGHTED_POOL_ID = 0x072f14b85add63488ddad88f855fda4a99d6ac9b000200000000000000000027;
+    IERC20 public constant SNX = IERC20(0xC011a73ee8576Fb46F5E1c5751cA3B9Fe0af2a6F);
+    IERC20 public constant WETH = IERC20(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);
+    IERC20 public constant SNX_IMPLEMENTATION = IERC20(0x639032d3900875a4cf4960aD6b9ee441657aA93C);
+    // solhint-enable const-name-snakecase
+
+    // This was removed from the StablePoolEncoder along with StablePool.
+    uint256 private constant _STABLE_POOL_EXIT_KIND_EXACT_BPT_IN_FOR_TOKENS_OUT = 1;
+
+    IVault private immutable _vault;
+    IProtocolFeesCollector private immutable _protocolFeeCollector;
+
+    constructor(IVault vault) {
+        _vault = vault;
+        _protocolFeeCollector = vault.getProtocolFeesCollector();
+    }
+
+    function getVault() public view returns (IVault) {
+        return _vault;
+    }
+
+    /**
+     * @notice Fully exit the BTC Stable Pool into its three components (wBTC, renBTC and sBTC), with no price impact
+     * nor swap fees. This relayer must have been previously approved by the caller, and proper permissions granted by
+     * Balancer Governance.
+     */
+    function exitBTCStablePool() external {
+        IERC20[] memory tokens = new IERC20[](3);
+        tokens[0] = wBTC;
+        tokens[1] = renBTC;
+        tokens[2] = sBTC;
+        uint256 bptAmountIn = BTC_STABLE_POOL_ADDRESS.balanceOf(msg.sender);
+
+        // Pull sBTC out from the Protocol Fee Collector and send it to the Vault ready for the exit. Computing the
+        // exact amount of sBTC required is a complicated task, as it involves due protocol fees, so we simply send all
+        // of it.
+        _withdrawFromProtocolFeeCollector(sBTC, sBTC.balanceOf(address(_protocolFeeCollector)));
+
+        // Perform the exit.
+        bytes memory userData = abi.encode(_STABLE_POOL_EXIT_KIND_EXACT_BPT_IN_FOR_TOKENS_OUT, bptAmountIn);
+        IVault.ExitPoolRequest memory request = IVault.ExitPoolRequest(
+            _asIAsset(tokens),
+            new uint256[](tokens.length),
+            userData,
+            false
+        );
+        getVault().exitPool(BTC_STABLE_POOL_ID, msg.sender, msg.sender, request);
+
+        // Sweep any remaining sBTC back into the Protocol Fee Collector.
+        IERC20[] memory sBTCEntrypoints = new IERC20[](2);
+        sBTCEntrypoints[0] = sBTC_IMPLEMENTATION;
+        sBTCEntrypoints[1] = IERC20(address(sBTC));
+        sweepDoubleEntrypointToken(sBTCEntrypoints);
+    }
+
+    /**
+     * @notice Fully exit the SNX Weighted Pool into its two components (SNX and WETH), with no price impact nor swap
+     * fees. This relayer must have been previously approved by the caller, and proper permissions granted by
+     * Balancer Governance.
+     */
+    function exitSNXWeightedPool() external {
+        IERC20[] memory tokens = new IERC20[](2);
+        tokens[0] = SNX;
+        tokens[1] = WETH;
+        uint256 bptAmountIn = SNX_WEIGHTED_POOL_ADDRESS.balanceOf(msg.sender);
+
+        // Pull SNX out from the Protocol Fee Collector and send it to the Vault ready for the exit. Computing the
+        // exact amount of SNX required is a complicated task, as it involves due protocol fees, so we simply send all
+        // of it.
+        _withdrawFromProtocolFeeCollector(SNX, SNX.balanceOf(address(_protocolFeeCollector)));
+
+        // Perform the exit.
+        bytes memory userData = abi.encode(WeightedPoolUserData.ExitKind.EXACT_BPT_IN_FOR_TOKENS_OUT, bptAmountIn);
+        IVault.ExitPoolRequest memory request = IVault.ExitPoolRequest(
+            _asIAsset(tokens),
+            new uint256[](tokens.length),
+            userData,
+            false
+        );
+        getVault().exitPool(SNX_WEIGHTED_POOL_ID, msg.sender, msg.sender, request);
+
+        // Sweep any remaining SNX back into the Protocol Fee Collector.
+        IERC20[] memory snxEntrypoints = new IERC20[](2);
+        snxEntrypoints[0] = SNX_IMPLEMENTATION;
+        snxEntrypoints[1] = IERC20(address(SNX));
+        sweepDoubleEntrypointToken(snxEntrypoints);
+    }
+
+    function _withdrawFromProtocolFeeCollector(IERC20 token, uint256 amount) internal {
+        IERC20[] memory tokens = new IERC20[](1);
+        tokens[0] = token;
+        uint256[] memory amounts = new uint256[](1);
+        amounts[0] = amount;
+
+        _protocolFeeCollector.withdrawCollectedFees(tokens, amounts, address(_vault));
+    }
+
+    /**
+     * @notice Sweep all SNX and sBTC from the Vault into the Protocol Fee Collector.
+     */
+    function sweepSNXsBTC() public {
+        IERC20[] memory snxEntrypoints = new IERC20[](2);
+        snxEntrypoints[0] = SNX_IMPLEMENTATION;
+        snxEntrypoints[1] = IERC20(address(SNX));
+
+        sweepDoubleEntrypointToken(snxEntrypoints);
+
+        IERC20[] memory sBTCEntrypoints = new IERC20[](2);
+        sBTCEntrypoints[0] = sBTC_IMPLEMENTATION;
+        sBTCEntrypoints[1] = IERC20(address(sBTC));
+        sweepDoubleEntrypointToken(sBTCEntrypoints);
+    }
+
+    /**
+     * @notice Sweep a double-entrypoint token into the Protocol Fee Collector by passing all entrypoints of a given
+     * token.
+     */
+    function sweepDoubleEntrypointToken(IERC20[] memory tokens) public {
+        uint256[] memory amounts = new uint256[](tokens.length);
+        amounts[0] = tokens[0].balanceOf(address(_vault));
+        _vault.flashLoan(this, tokens, amounts, "0x");
+    }
+
+    /**
+     * @dev Flash loan callback. Assumes that it receives a flashloan of multiple assets (all entrypoints of a Synthetix
+     * synth). We only need to repay the first loan as that will automatically all other loans.
+     */
+    function receiveFlashLoan(
+        IERC20[] memory tokens,
+        uint256[] memory amounts,
+        uint256[] memory,
+        bytes memory
+    ) external override {
+        _require(msg.sender == address(_vault), Errors.CALLER_NOT_VAULT);
+        tokens[0].safeTransfer(address(_vault), amounts[0]);
+    }
+}
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts standalone-utils/contracts/test/MockBaseRelayerLibrary.sol standalone-utils/contracts/test/MockBaseRelayerLibrary.sol
--- standalone-utils/contracts/test/MockBaseRelayerLibrary.sol	2022-10-28 09:21:26.000000000 +0200
+++ standalone-utils/contracts/test/MockBaseRelayerLibrary.sol	2022-10-28 09:58:59.000000000 +0200
@@ -17,7 +17,7 @@
 pragma solidity ^0.7.0;
 pragma experimental ABIEncoderV2;
 
-//import "@balancer-labs/v2-interfaces/contracts/standalone-utils/IBaseRelayerLibrary.sol";
+//import "../../interfaces/contracts/standalone-utils/IBaseRelayerLibrary.sol";
 
 import "../relayer/BaseRelayerLibrary.sol";
 
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts standalone-utils/contracts/test/MockBaseRelayerLibrary.sol.orig standalone-utils/contracts/test/MockBaseRelayerLibrary.sol.orig
--- standalone-utils/contracts/test/MockBaseRelayerLibrary.sol.orig	1970-01-01 01:00:00.000000000 +0100
+++ standalone-utils/contracts/test/MockBaseRelayerLibrary.sol.orig	2022-10-28 09:58:14.000000000 +0200
@@ -0,0 +1,44 @@
+// SPDX-License-Identifier: GPL-3.0-or-later
+// Copyright (C) 2015, 2016, 2017 Dapphub
+
+// This program is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation, either version 3 of the License, or
+// (at your option) any later version.
+
+// This program is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License
+// along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+pragma solidity ^0.7.0;
+pragma experimental ABIEncoderV2;
+
+//import "@balancer-labs/v2-interfaces/contracts/standalone-utils/IBaseRelayerLibrary.sol";
+
+import "../relayer/BaseRelayerLibrary.sol";
+
+contract MockBaseRelayerLibrary is BaseRelayerLibrary {
+    event ChainedReferenceValueRead(uint256 value);
+
+    constructor(IVault vault) BaseRelayerLibrary(vault) {}
+
+    function isChainedReference(uint256 amount) public pure returns (bool) {
+        return _isChainedReference(amount);
+    }
+
+    function setChainedReferenceValue(uint256 ref, uint256 value) public {
+        _setChainedReferenceValue(ref, value);
+    }
+
+    function getChainedReferenceValue(uint256 ref) public {
+        emit ChainedReferenceValueRead(_getChainedReferenceValue(ref));
+    }
+
+    function bytesTunnel(bytes memory input) public pure returns (bytes memory) {
+        return input;
+    }
+}
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts standalone-utils/contracts/test/MockStETH.sol standalone-utils/contracts/test/MockStETH.sol
--- standalone-utils/contracts/test/MockStETH.sol	2022-10-03 09:35:45.000000000 +0200
+++ standalone-utils/contracts/test/MockStETH.sol	2022-10-28 09:58:59.000000000 +0200
@@ -16,10 +16,10 @@
 
 pragma solidity ^0.7.0;
 
-import "@balancer-labs/v2-interfaces/contracts/standalone-utils/IstETH.sol";
+import "../../interfaces/contracts/standalone-utils/IstETH.sol";
 
-import "@balancer-labs/v2-solidity-utils/contracts/math/FixedPoint.sol";
-import "@balancer-labs/v2-solidity-utils/contracts/test/TestToken.sol";
+import "../../solidity-utils/contracts/math/FixedPoint.sol";
+import "../../solidity-utils/contracts/test/TestToken.sol";
 
 contract MockStETH is TestToken, IstETH {
     constructor(
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts standalone-utils/contracts/test/MockWstETH.sol.orig standalone-utils/contracts/test/MockWstETH.sol.orig
--- standalone-utils/contracts/test/MockWstETH.sol.orig	1970-01-01 01:00:00.000000000 +0100
+++ standalone-utils/contracts/test/MockWstETH.sol.orig	2022-10-28 09:58:14.000000000 +0200
@@ -0,0 +1,71 @@
+// SPDX-License-Identifier: GPL-3.0-or-later
+// Copyright (C) 2015, 2016, 2017 Dapphub
+
+// This program is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation, either version 3 of the License, or
+// (at your option) any later version.
+
+// This program is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License
+// along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+pragma solidity ^0.7.0;
+
+import "@balancer-labs/v2-interfaces/contracts/standalone-utils/IstETH.sol";
+import "@balancer-labs/v2-interfaces/contracts/standalone-utils/IwstETH.sol";
+
+import "@balancer-labs/v2-solidity-utils/contracts/math/FixedPoint.sol";
+import "@balancer-labs/v2-solidity-utils/contracts/openzeppelin/ERC20.sol";
+import "@balancer-labs/v2-solidity-utils/contracts/openzeppelin/SafeERC20.sol";
+
+contract MockWstETH is ERC20, IwstETH {
+    using FixedPoint for uint256;
+    using SafeERC20 for IERC20;
+
+    IstETH public override stETH;
+    uint256 public rate = 1.5e18;
+
+    constructor(IstETH token) ERC20("Wrapped Staked Ether", "wstETH") {
+        stETH = token;
+    }
+
+    function wrap(uint256 _stETHAmount) external override returns (uint256) {
+        IERC20(stETH).safeTransferFrom(msg.sender, address(this), _stETHAmount);
+        uint256 wstETHAmount = getWstETHByStETH(_stETHAmount);
+        _mint(msg.sender, wstETHAmount);
+        return wstETHAmount;
+    }
+
+    function unwrap(uint256 _wstETHAmount) external override returns (uint256) {
+        _burn(msg.sender, _wstETHAmount);
+        uint256 stETHAmount = getStETHByWstETH(_wstETHAmount);
+        IERC20(stETH).safeTransfer(msg.sender, stETHAmount);
+        return stETHAmount;
+    }
+
+    receive() external payable {
+        stETH.submit{ value: msg.value }(address(this));
+        _mint(msg.sender, getWstETHByStETH(msg.value));
+    }
+
+    function getWstETHByStETH(uint256 _stETHAmount) public view override returns (uint256) {
+        return _stETHAmount.divDown(rate);
+    }
+
+    function getStETHByWstETH(uint256 _wstETHAmount) public view override returns (uint256) {
+        return _wstETHAmount.mulDown(rate);
+    }
+
+    function stEthPerToken() external view override returns (uint256) {
+        return getStETHByWstETH(1 ether);
+    }
+
+    function tokensPerStEth() external view override returns (uint256) {
+        return getWstETHByStETH(1 ether);
+    }
+}
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts standalone-utils/contracts/test/MockWstETH.sol.rej standalone-utils/contracts/test/MockWstETH.sol.rej
--- standalone-utils/contracts/test/MockWstETH.sol.rej	1970-01-01 01:00:00.000000000 +0100
+++ standalone-utils/contracts/test/MockWstETH.sol.rej	2022-10-28 09:58:59.000000000 +0200
@@ -0,0 +1,25 @@
+***************
+*** 16,26 ****
+  
+  pragma solidity ^0.7.0;
+  
+- import "@balancer-labs/v2-interfaces/contracts/standalone-utils/IstETH.sol";
+- import "@balancer-labs/v2-interfaces/contracts/standalone-utils/IwstETH.sol";
+  
+- import "@balancer-labs/v2-solidity-utils/contracts/math/FixedPoint.sol";
+- import "@balancer-labs/v2-solidity-utils/contracts/openzeppelin/ERC20.sol";
+  
+  contract MockWstETH is ERC20, IwstETH {
+      using FixedPoint for uint256;
+--- 16,26 ----
+  
+  pragma solidity ^0.7.0;
+  
++ import "../../interfaces/contracts/standalone-utils/IstETH.sol";
++ import "../../interfaces/contracts/standalone-utils/IwstETH.sol";
+  
++ import "../../solidity-utils/contracts/math/FixedPoint.sol";
++ import "../../solidity-utils/contracts/openzeppelin/ERC20.sol";
+  
+  contract MockWstETH is ERC20, IwstETH {
+      using FixedPoint for uint256;
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts standalone-utils/contracts/test/TestWETH.sol standalone-utils/contracts/test/TestWETH.sol
--- standalone-utils/contracts/test/TestWETH.sol	2022-10-03 09:35:45.000000000 +0200
+++ standalone-utils/contracts/test/TestWETH.sol	2022-10-28 09:58:59.000000000 +0200
@@ -16,7 +16,7 @@
 
 pragma solidity ^0.7.0;
 
-import "@balancer-labs/v2-interfaces/contracts/solidity-utils/misc/IWETH.sol";
+import "../../interfaces/contracts/solidity-utils/misc/IWETH.sol";
 
 contract TestWETH is IWETH {
     string public name = "Wrapped Ether";
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts vault/contracts/AssetHelpers.sol vault/contracts/AssetHelpers.sol
--- vault/contracts/AssetHelpers.sol	2022-10-03 09:35:45.000000000 +0200
+++ vault/contracts/AssetHelpers.sol	2022-10-28 09:58:59.000000000 +0200
@@ -14,9 +14,9 @@
 
 pragma solidity ^0.7.0;
 
-import "@balancer-labs/v2-interfaces/contracts/solidity-utils/openzeppelin/IERC20.sol";
-import "@balancer-labs/v2-interfaces/contracts/solidity-utils/misc/IWETH.sol";
-import "@balancer-labs/v2-interfaces/contracts/vault/IAsset.sol";
+import "../../interfaces/contracts/solidity-utils/openzeppelin/IERC20.sol";
+import "../../interfaces/contracts/solidity-utils/misc/IWETH.sol";
+import "../../interfaces/contracts/vault/IAsset.sol";
 
 abstract contract AssetHelpers {
     // solhint-disable-next-line var-name-mixedcase
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts vault/contracts/AssetManagers.sol vault/contracts/AssetManagers.sol
--- vault/contracts/AssetManagers.sol	2022-10-03 09:35:45.000000000 +0200
+++ vault/contracts/AssetManagers.sol	2022-10-28 09:58:59.000000000 +0200
@@ -15,13 +15,13 @@
 pragma solidity ^0.7.0;
 pragma experimental ABIEncoderV2;
 
-import "@balancer-labs/v2-interfaces/contracts/solidity-utils/helpers/BalancerErrors.sol";
-import "@balancer-labs/v2-interfaces/contracts/solidity-utils/openzeppelin/IERC20.sol";
+import "../../interfaces/contracts/solidity-utils/helpers/BalancerErrors.sol";
+import "../../interfaces/contracts/solidity-utils/openzeppelin/IERC20.sol";
 
-import "@balancer-labs/v2-solidity-utils/contracts/openzeppelin/ReentrancyGuard.sol";
-import "@balancer-labs/v2-solidity-utils/contracts/openzeppelin/SafeERC20.sol";
-import "@balancer-labs/v2-solidity-utils/contracts/helpers/InputHelpers.sol";
-import "@balancer-labs/v2-solidity-utils/contracts/math/Math.sol";
+import "../../solidity-utils/contracts/openzeppelin/ReentrancyGuard.sol";
+import "../../solidity-utils/contracts/openzeppelin/SafeERC20.sol";
+import "../../solidity-utils/contracts/helpers/InputHelpers.sol";
+import "../../solidity-utils/contracts/math/Math.sol";
 
 import "./UserBalance.sol";
 import "./balances/BalanceAllocation.sol";
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts vault/contracts/AssetTransfersHandler.sol vault/contracts/AssetTransfersHandler.sol
--- vault/contracts/AssetTransfersHandler.sol	2022-10-03 09:35:45.000000000 +0200
+++ vault/contracts/AssetTransfersHandler.sol	2022-10-28 09:58:59.000000000 +0200
@@ -15,15 +15,15 @@
 pragma solidity ^0.7.0;
 pragma experimental ABIEncoderV2;
 
-import "@balancer-labs/v2-interfaces/contracts/solidity-utils/helpers/BalancerErrors.sol";
-import "@balancer-labs/v2-interfaces/contracts/solidity-utils/openzeppelin/IERC20.sol";
-import "@balancer-labs/v2-interfaces/contracts/solidity-utils/misc/IWETH.sol";
-import "@balancer-labs/v2-interfaces/contracts/vault/IAsset.sol";
-import "@balancer-labs/v2-interfaces/contracts/vault/IVault.sol";
-
-import "@balancer-labs/v2-solidity-utils/contracts/openzeppelin/SafeERC20.sol";
-import "@balancer-labs/v2-solidity-utils/contracts/openzeppelin/Address.sol";
-import "@balancer-labs/v2-solidity-utils/contracts/math/Math.sol";
+import "../../interfaces/contracts/solidity-utils/helpers/BalancerErrors.sol";
+import "../../interfaces/contracts/solidity-utils/openzeppelin/IERC20.sol";
+import "../../interfaces/contracts/solidity-utils/misc/IWETH.sol";
+import "../../interfaces/contracts/vault/IAsset.sol";
+import "../../interfaces/contracts/vault/IVault.sol";
+
+import "../../solidity-utils/contracts/openzeppelin/SafeERC20.sol";
+import "../../solidity-utils/contracts/openzeppelin/Address.sol";
+import "../../solidity-utils/contracts/math/Math.sol";
 
 import "./AssetHelpers.sol";
 
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts vault/contracts/Fees.sol vault/contracts/Fees.sol
--- vault/contracts/Fees.sol	2022-10-03 09:35:45.000000000 +0200
+++ vault/contracts/Fees.sol	2022-10-28 09:58:59.000000000 +0200
@@ -15,13 +15,13 @@
 pragma solidity ^0.7.0;
 pragma experimental ABIEncoderV2;
 
-import "@balancer-labs/v2-interfaces/contracts/solidity-utils/helpers/BalancerErrors.sol";
-import "@balancer-labs/v2-interfaces/contracts/solidity-utils/openzeppelin/IERC20.sol";
-import "@balancer-labs/v2-interfaces/contracts/vault/IVault.sol";
-
-import "@balancer-labs/v2-solidity-utils/contracts/openzeppelin/ReentrancyGuard.sol";
-import "@balancer-labs/v2-solidity-utils/contracts/math/FixedPoint.sol";
-import "@balancer-labs/v2-solidity-utils/contracts/openzeppelin/SafeERC20.sol";
+import "../../interfaces/contracts/solidity-utils/helpers/BalancerErrors.sol";
+import "../../interfaces/contracts/solidity-utils/openzeppelin/IERC20.sol";
+import "../../interfaces/contracts/vault/IVault.sol";
+
+import "../../solidity-utils/contracts/openzeppelin/ReentrancyGuard.sol";
+import "../../solidity-utils/contracts/math/FixedPoint.sol";
+import "../../solidity-utils/contracts/openzeppelin/SafeERC20.sol";
 
 import "./ProtocolFeesCollector.sol";
 import "./VaultAuthorization.sol";
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts vault/contracts/FlashLoans.sol vault/contracts/FlashLoans.sol
--- vault/contracts/FlashLoans.sol	2022-10-03 09:35:45.000000000 +0200
+++ vault/contracts/FlashLoans.sol	2022-10-28 09:58:59.000000000 +0200
@@ -19,12 +19,12 @@
 pragma solidity ^0.7.0;
 pragma experimental ABIEncoderV2;
 
-import "@balancer-labs/v2-interfaces/contracts/solidity-utils/helpers/BalancerErrors.sol";
-import "@balancer-labs/v2-interfaces/contracts/solidity-utils/openzeppelin/IERC20.sol";
-import "@balancer-labs/v2-interfaces/contracts/vault/IFlashLoanRecipient.sol";
+import "../../interfaces/contracts/solidity-utils/helpers/BalancerErrors.sol";
+import "../../interfaces/contracts/solidity-utils/openzeppelin/IERC20.sol";
+import "../../interfaces/contracts/vault/IFlashLoanRecipient.sol";
 
-import "@balancer-labs/v2-solidity-utils/contracts/openzeppelin/ReentrancyGuard.sol";
-import "@balancer-labs/v2-solidity-utils/contracts/openzeppelin/SafeERC20.sol";
+import "../../solidity-utils/contracts/openzeppelin/ReentrancyGuard.sol";
+import "../../solidity-utils/contracts/openzeppelin/SafeERC20.sol";
 
 import "./Fees.sol";
 
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts vault/contracts/PoolBalances.sol vault/contracts/PoolBalances.sol
--- vault/contracts/PoolBalances.sol	2022-10-03 09:35:45.000000000 +0200
+++ vault/contracts/PoolBalances.sol	2022-10-28 09:58:59.000000000 +0200
@@ -15,14 +15,14 @@
 pragma solidity ^0.7.0;
 pragma experimental ABIEncoderV2;
 
-import "@balancer-labs/v2-interfaces/contracts/solidity-utils/helpers/BalancerErrors.sol";
-import "@balancer-labs/v2-interfaces/contracts/solidity-utils/openzeppelin/IERC20.sol";
-import "@balancer-labs/v2-interfaces/contracts/vault/IBasePool.sol";
-
-import "@balancer-labs/v2-solidity-utils/contracts/openzeppelin/ReentrancyGuard.sol";
-import "@balancer-labs/v2-solidity-utils/contracts/helpers/InputHelpers.sol";
-import "@balancer-labs/v2-solidity-utils/contracts/openzeppelin/SafeERC20.sol";
-import "@balancer-labs/v2-solidity-utils/contracts/math/Math.sol";
+import "../../interfaces/contracts/solidity-utils/helpers/BalancerErrors.sol";
+import "../../interfaces/contracts/solidity-utils/openzeppelin/IERC20.sol";
+import "../../interfaces/contracts/vault/IBasePool.sol";
+
+import "../../solidity-utils/contracts/openzeppelin/ReentrancyGuard.sol";
+import "../../solidity-utils/contracts/helpers/InputHelpers.sol";
+import "../../solidity-utils/contracts/openzeppelin/SafeERC20.sol";
+import "../../solidity-utils/contracts/math/Math.sol";
 
 import "./Fees.sol";
 import "./PoolTokens.sol";
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts vault/contracts/PoolRegistry.sol vault/contracts/PoolRegistry.sol
--- vault/contracts/PoolRegistry.sol	2022-10-03 09:35:45.000000000 +0200
+++ vault/contracts/PoolRegistry.sol	2022-10-28 09:58:59.000000000 +0200
@@ -15,9 +15,9 @@
 pragma solidity ^0.7.0;
 pragma experimental ABIEncoderV2;
 
-import "@balancer-labs/v2-interfaces/contracts/solidity-utils/helpers/BalancerErrors.sol";
+import "../../interfaces/contracts/solidity-utils/helpers/BalancerErrors.sol";
 
-import "@balancer-labs/v2-solidity-utils/contracts/openzeppelin/ReentrancyGuard.sol";
+import "../../solidity-utils/contracts/openzeppelin/ReentrancyGuard.sol";
 
 import "./VaultAuthorization.sol";
 
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts vault/contracts/PoolTokens.sol vault/contracts/PoolTokens.sol
--- vault/contracts/PoolTokens.sol	2022-10-03 09:35:45.000000000 +0200
+++ vault/contracts/PoolTokens.sol	2022-10-28 09:58:59.000000000 +0200
@@ -15,9 +15,9 @@
 pragma solidity ^0.7.0;
 pragma experimental ABIEncoderV2;
 
-import "@balancer-labs/v2-interfaces/contracts/solidity-utils/helpers/BalancerErrors.sol";
+import "../../interfaces/contracts/solidity-utils/helpers/BalancerErrors.sol";
 
-import "@balancer-labs/v2-solidity-utils/contracts/openzeppelin/ReentrancyGuard.sol";
+import "../../solidity-utils/contracts/openzeppelin/ReentrancyGuard.sol";
 
 import "./AssetManagers.sol";
 import "./PoolRegistry.sol";
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts vault/contracts/ProtocolFeesCollector.sol vault/contracts/ProtocolFeesCollector.sol
--- vault/contracts/ProtocolFeesCollector.sol	2022-10-03 09:35:45.000000000 +0200
+++ vault/contracts/ProtocolFeesCollector.sol	2022-10-28 09:58:59.000000000 +0200
@@ -15,12 +15,12 @@
 pragma solidity ^0.7.0;
 pragma experimental ABIEncoderV2;
 
-import "@balancer-labs/v2-interfaces/contracts/vault/IProtocolFeesCollector.sol";
+import "../../interfaces/contracts/vault/IProtocolFeesCollector.sol";
 
-import "@balancer-labs/v2-solidity-utils/contracts/openzeppelin/ReentrancyGuard.sol";
-import "@balancer-labs/v2-solidity-utils/contracts/helpers/InputHelpers.sol";
-import "@balancer-labs/v2-solidity-utils/contracts/helpers/Authentication.sol";
-import "@balancer-labs/v2-solidity-utils/contracts/openzeppelin/SafeERC20.sol";
+import "../../solidity-utils/contracts/openzeppelin/ReentrancyGuard.sol";
+import "../../solidity-utils/contracts/helpers/InputHelpers.sol";
+import "../../solidity-utils/contracts/helpers/Authentication.sol";
+import "../../solidity-utils/contracts/openzeppelin/SafeERC20.sol";
 
 /**
  * @dev This an auxiliary contract to the Vault, deployed by it during construction. It offloads some of the tasks the
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts vault/contracts/Swaps.sol vault/contracts/Swaps.sol
--- vault/contracts/Swaps.sol	2022-10-03 09:35:45.000000000 +0200
+++ vault/contracts/Swaps.sol	2022-10-28 09:58:59.000000000 +0200
@@ -15,20 +15,20 @@
 pragma solidity ^0.7.0;
 pragma experimental ABIEncoderV2;
 
-import "@balancer-labs/v2-interfaces/contracts/solidity-utils/helpers/BalancerErrors.sol";
-import "@balancer-labs/v2-interfaces/contracts/solidity-utils/openzeppelin/IERC20.sol";
+import "../../interfaces/contracts/solidity-utils/helpers/BalancerErrors.sol";
+import "../../interfaces/contracts/solidity-utils/openzeppelin/IERC20.sol";
 
-import "@balancer-labs/v2-interfaces/contracts/vault/IPoolSwapStructs.sol";
-import "@balancer-labs/v2-interfaces/contracts/vault/IGeneralPool.sol";
-import "@balancer-labs/v2-interfaces/contracts/vault/IMinimalSwapInfoPool.sol";
-
-import "@balancer-labs/v2-solidity-utils/contracts/openzeppelin/EnumerableSet.sol";
-import "@balancer-labs/v2-solidity-utils/contracts/openzeppelin/ReentrancyGuard.sol";
-import "@balancer-labs/v2-solidity-utils/contracts/openzeppelin/EnumerableMap.sol";
-import "@balancer-labs/v2-solidity-utils/contracts/openzeppelin/SafeCast.sol";
-import "@balancer-labs/v2-solidity-utils/contracts/openzeppelin/SafeERC20.sol";
-import "@balancer-labs/v2-solidity-utils/contracts/helpers/InputHelpers.sol";
-import "@balancer-labs/v2-solidity-utils/contracts/math/Math.sol";
+import "../../interfaces/contracts/vault/IPoolSwapStructs.sol";
+import "../../interfaces/contracts/vault/IGeneralPool.sol";
+import "../../interfaces/contracts/vault/IMinimalSwapInfoPool.sol";
+
+import "../../solidity-utils/contracts/openzeppelin/EnumerableSet.sol";
+import "../../solidity-utils/contracts/openzeppelin/ReentrancyGuard.sol";
+import "../../solidity-utils/contracts/openzeppelin/EnumerableMap.sol";
+import "../../solidity-utils/contracts/openzeppelin/SafeCast.sol";
+import "../../solidity-utils/contracts/openzeppelin/SafeERC20.sol";
+import "../../solidity-utils/contracts/helpers/InputHelpers.sol";
+import "../../solidity-utils/contracts/math/Math.sol";
 
 import "./PoolBalances.sol";
 import "./balances/BalanceAllocation.sol";
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts vault/contracts/UserBalance.sol vault/contracts/UserBalance.sol
--- vault/contracts/UserBalance.sol	2022-10-03 09:35:45.000000000 +0200
+++ vault/contracts/UserBalance.sol	2022-10-28 09:58:59.000000000 +0200
@@ -15,13 +15,13 @@
 pragma solidity ^0.7.0;
 pragma experimental ABIEncoderV2;
 
-import "@balancer-labs/v2-interfaces/contracts/solidity-utils/helpers/BalancerErrors.sol";
-import "@balancer-labs/v2-interfaces/contracts/solidity-utils/openzeppelin/IERC20.sol";
+import "../../interfaces/contracts/solidity-utils/helpers/BalancerErrors.sol";
+import "../../interfaces/contracts/solidity-utils/openzeppelin/IERC20.sol";
 
-import "@balancer-labs/v2-solidity-utils/contracts/openzeppelin/ReentrancyGuard.sol";
-import "@balancer-labs/v2-solidity-utils/contracts/openzeppelin/SafeCast.sol";
-import "@balancer-labs/v2-solidity-utils/contracts/openzeppelin/SafeERC20.sol";
-import "@balancer-labs/v2-solidity-utils/contracts/math/Math.sol";
+import "../../solidity-utils/contracts/openzeppelin/ReentrancyGuard.sol";
+import "../../solidity-utils/contracts/openzeppelin/SafeCast.sol";
+import "../../solidity-utils/contracts/openzeppelin/SafeERC20.sol";
+import "../../solidity-utils/contracts/math/Math.sol";
 
 import "./AssetTransfersHandler.sol";
 import "./VaultAuthorization.sol";
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts vault/contracts/Vault.sol vault/contracts/Vault.sol
--- vault/contracts/Vault.sol	2022-10-03 09:35:45.000000000 +0200
+++ vault/contracts/Vault.sol	2022-10-28 09:58:59.000000000 +0200
@@ -15,8 +15,8 @@
 pragma solidity ^0.7.0;
 pragma experimental ABIEncoderV2;
 
-import "@balancer-labs/v2-interfaces/contracts/solidity-utils/misc/IWETH.sol";
-import "@balancer-labs/v2-interfaces/contracts/vault/IAuthorizer.sol";
+import "../../interfaces/contracts/solidity-utils/misc/IWETH.sol";
+import "../../interfaces/contracts/vault/IAuthorizer.sol";
 
 import "./VaultAuthorization.sol";
 import "./FlashLoans.sol";
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts vault/contracts/VaultAuthorization.sol vault/contracts/VaultAuthorization.sol
--- vault/contracts/VaultAuthorization.sol	2022-10-03 09:35:45.000000000 +0200
+++ vault/contracts/VaultAuthorization.sol	2022-10-28 09:58:59.000000000 +0200
@@ -15,14 +15,14 @@
 pragma solidity ^0.7.0;
 pragma experimental ABIEncoderV2;
 
-import "@balancer-labs/v2-interfaces/contracts/solidity-utils/helpers/BalancerErrors.sol";
-import "@balancer-labs/v2-interfaces/contracts/vault/IVault.sol";
-import "@balancer-labs/v2-interfaces/contracts/vault/IAuthorizer.sol";
-
-import "@balancer-labs/v2-solidity-utils/contracts/helpers/Authentication.sol";
-import "@balancer-labs/v2-solidity-utils/contracts/helpers/ExtraCalldataEOASignaturesValidator.sol";
-import "@balancer-labs/v2-solidity-utils/contracts/helpers/TemporarilyPausable.sol";
-import "@balancer-labs/v2-solidity-utils/contracts/openzeppelin/ReentrancyGuard.sol";
+import "../../interfaces/contracts/solidity-utils/helpers/BalancerErrors.sol";
+import "../../interfaces/contracts/vault/IVault.sol";
+import "../../interfaces/contracts/vault/IAuthorizer.sol";
+
+import "../../solidity-utils/contracts/helpers/Authentication.sol";
+import "../../solidity-utils/contracts/helpers/ExtraCalldataEOASignaturesValidator.sol";
+import "../../solidity-utils/contracts/helpers/TemporarilyPausable.sol";
+import "../../solidity-utils/contracts/openzeppelin/ReentrancyGuard.sol";
 
 /**
  * @dev Manages access control of Vault permissioned functions by relying on the Authorizer and signature validation.
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts vault/contracts/authorizer/TimelockAuthorizer.sol vault/contracts/authorizer/TimelockAuthorizer.sol
--- vault/contracts/authorizer/TimelockAuthorizer.sol	2022-10-28 09:21:26.000000000 +0200
+++ vault/contracts/authorizer/TimelockAuthorizer.sol	2022-10-28 09:58:59.000000000 +0200
@@ -15,15 +15,15 @@
 pragma solidity ^0.7.0;
 pragma experimental ABIEncoderV2;
 
-import "@balancer-labs/v2-interfaces/contracts/solidity-utils/helpers/BalancerErrors.sol";
-import "@balancer-labs/v2-interfaces/contracts/solidity-utils/helpers/IAuthentication.sol";
-import "@balancer-labs/v2-interfaces/contracts/vault/IVault.sol";
-import "@balancer-labs/v2-interfaces/contracts/vault/IAuthorizer.sol";
-
-import "@balancer-labs/v2-solidity-utils/contracts/helpers/InputHelpers.sol";
-import "@balancer-labs/v2-solidity-utils/contracts/math/Math.sol";
-import "@balancer-labs/v2-solidity-utils/contracts/openzeppelin/Address.sol";
-import "@balancer-labs/v2-solidity-utils/contracts/openzeppelin/ReentrancyGuard.sol";
+import "../../interfaces/contracts/solidity-utils/helpers/BalancerErrors.sol";
+import "../../interfaces/contracts/solidity-utils/helpers/IAuthentication.sol";
+import "../../interfaces/contracts/vault/IVault.sol";
+import "../../interfaces/contracts/vault/IAuthorizer.sol";
+
+import "../../solidity-utils/contracts/helpers/InputHelpers.sol";
+import "../../solidity-utils/contracts/math/Math.sol";
+import "../../solidity-utils/contracts/openzeppelin/Address.sol";
+import "../../solidity-utils/contracts/openzeppelin/ReentrancyGuard.sol";
 import "./TimelockExecutor.sol";
 
 /**
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts vault/contracts/authorizer/TimelockExecutor.sol vault/contracts/authorizer/TimelockExecutor.sol
--- vault/contracts/authorizer/TimelockExecutor.sol	2022-10-03 09:35:45.000000000 +0200
+++ vault/contracts/authorizer/TimelockExecutor.sol	2022-10-28 09:58:59.000000000 +0200
@@ -14,8 +14,8 @@
 
 pragma solidity ^0.7.0;
 
-import "@balancer-labs/v2-solidity-utils/contracts/openzeppelin/Address.sol";
-import "@balancer-labs/v2-solidity-utils/contracts/openzeppelin/ReentrancyGuard.sol";
+import "../../solidity-utils/contracts/openzeppelin/Address.sol";
+import "../../solidity-utils/contracts/openzeppelin/ReentrancyGuard.sol";
 
 import "./TimelockAuthorizer.sol";
 
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts vault/contracts/balances/BalanceAllocation.sol vault/contracts/balances/BalanceAllocation.sol
--- vault/contracts/balances/BalanceAllocation.sol	2022-10-03 09:35:45.000000000 +0200
+++ vault/contracts/balances/BalanceAllocation.sol	2022-10-28 09:58:59.000000000 +0200
@@ -14,7 +14,7 @@
 
 pragma solidity ^0.7.0;
 
-import "@balancer-labs/v2-solidity-utils/contracts/math/Math.sol";
+import "../../solidity-utils/contracts/math/Math.sol";
 
 // This library is used to create a data structure that represents a token's balance for a Pool. 'cash' is how many
 // tokens the Pool has sitting inside of the Vault. 'managed' is how many tokens were withdrawn from the Vault by the
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts vault/contracts/balances/GeneralPoolsBalance.sol vault/contracts/balances/GeneralPoolsBalance.sol
--- vault/contracts/balances/GeneralPoolsBalance.sol	2022-10-03 09:35:45.000000000 +0200
+++ vault/contracts/balances/GeneralPoolsBalance.sol	2022-10-28 09:58:59.000000000 +0200
@@ -14,10 +14,10 @@
 
 pragma solidity ^0.7.0;
 
-import "@balancer-labs/v2-interfaces/contracts/solidity-utils/helpers/BalancerErrors.sol";
-import "@balancer-labs/v2-interfaces/contracts/solidity-utils/openzeppelin/IERC20.sol";
+import "../../interfaces/contracts/solidity-utils/helpers/BalancerErrors.sol";
+import "../../interfaces/contracts/solidity-utils/openzeppelin/IERC20.sol";
 
-import "@balancer-labs/v2-solidity-utils/contracts/openzeppelin/EnumerableMap.sol";
+import "../../solidity-utils/contracts/openzeppelin/EnumerableMap.sol";
 
 import "./BalanceAllocation.sol";
 
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts vault/contracts/balances/MinimalSwapInfoPoolsBalance.sol vault/contracts/balances/MinimalSwapInfoPoolsBalance.sol
--- vault/contracts/balances/MinimalSwapInfoPoolsBalance.sol	2022-10-03 09:35:45.000000000 +0200
+++ vault/contracts/balances/MinimalSwapInfoPoolsBalance.sol	2022-10-28 09:58:59.000000000 +0200
@@ -15,10 +15,10 @@
 pragma solidity ^0.7.0;
 pragma experimental ABIEncoderV2;
 
-import "@balancer-labs/v2-interfaces/contracts/solidity-utils/helpers/BalancerErrors.sol";
-import "@balancer-labs/v2-interfaces/contracts/solidity-utils/openzeppelin/IERC20.sol";
+import "../../interfaces/contracts/solidity-utils/helpers/BalancerErrors.sol";
+import "../../interfaces/contracts/solidity-utils/openzeppelin/IERC20.sol";
 
-import "@balancer-labs/v2-solidity-utils/contracts/openzeppelin/EnumerableSet.sol";
+import "../../solidity-utils/contracts/openzeppelin/EnumerableSet.sol";
 
 import "./BalanceAllocation.sol";
 import "../PoolRegistry.sol";
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts vault/contracts/balances/TwoTokenPoolsBalance.sol vault/contracts/balances/TwoTokenPoolsBalance.sol
--- vault/contracts/balances/TwoTokenPoolsBalance.sol	2022-10-03 09:35:45.000000000 +0200
+++ vault/contracts/balances/TwoTokenPoolsBalance.sol	2022-10-28 09:58:59.000000000 +0200
@@ -15,8 +15,8 @@
 pragma solidity ^0.7.0;
 pragma experimental ABIEncoderV2;
 
-import "@balancer-labs/v2-interfaces/contracts/solidity-utils/helpers/BalancerErrors.sol";
-import "@balancer-labs/v2-interfaces/contracts/solidity-utils/openzeppelin/IERC20.sol";
+import "../../interfaces/contracts/solidity-utils/helpers/BalancerErrors.sol";
+import "../../interfaces/contracts/solidity-utils/openzeppelin/IERC20.sol";
 
 import "./BalanceAllocation.sol";
 import "../PoolRegistry.sol";
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts vault/contracts/test/MockAssetTransfersHandler.sol vault/contracts/test/MockAssetTransfersHandler.sol
--- vault/contracts/test/MockAssetTransfersHandler.sol	2022-10-03 09:35:45.000000000 +0200
+++ vault/contracts/test/MockAssetTransfersHandler.sol	2022-10-28 09:58:59.000000000 +0200
@@ -15,9 +15,9 @@
 pragma solidity ^0.7.0;
 pragma experimental ABIEncoderV2;
 
-import "@balancer-labs/v2-solidity-utils/contracts/openzeppelin/SafeERC20.sol";
-import "@balancer-labs/v2-solidity-utils/contracts/math/FixedPoint.sol";
-import "@balancer-labs/v2-solidity-utils/contracts/math/Math.sol";
+import "../../solidity-utils/contracts/openzeppelin/SafeERC20.sol";
+import "../../solidity-utils/contracts/math/FixedPoint.sol";
+import "../../solidity-utils/contracts/math/Math.sol";
 
 import "../AssetTransfersHandler.sol";
 
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts vault/contracts/test/MockAuthenticatedContract.sol vault/contracts/test/MockAuthenticatedContract.sol
--- vault/contracts/test/MockAuthenticatedContract.sol	2022-10-03 09:35:45.000000000 +0200
+++ vault/contracts/test/MockAuthenticatedContract.sol	2022-10-28 09:58:59.000000000 +0200
@@ -15,7 +15,7 @@
 pragma solidity ^0.7.0;
 pragma experimental ABIEncoderV2;
 
-import "@balancer-labs/v2-solidity-utils/contracts/helpers/SingletonAuthentication.sol";
+import "../../solidity-utils/contracts/helpers/SingletonAuthentication.sol";
 
 /*
  * @author Balancer Labs
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts vault/contracts/test/MockBasicAuthorizer.sol vault/contracts/test/MockBasicAuthorizer.sol
--- vault/contracts/test/MockBasicAuthorizer.sol	2022-10-03 09:35:45.000000000 +0200
+++ vault/contracts/test/MockBasicAuthorizer.sol	2022-10-28 09:58:59.000000000 +0200
@@ -15,11 +15,11 @@
 pragma solidity ^0.7.0;
 pragma experimental ABIEncoderV2;
 
-import "@balancer-labs/v2-interfaces/contracts/solidity-utils/helpers/BalancerErrors.sol";
-import "@balancer-labs/v2-interfaces/contracts/vault/IBasicAuthorizer.sol";
+import "../../interfaces/contracts/solidity-utils/helpers/BalancerErrors.sol";
+import "../../interfaces/contracts/vault/IBasicAuthorizer.sol";
 
-import "@balancer-labs/v2-solidity-utils/contracts/openzeppelin/EnumerableSet.sol";
-import "@balancer-labs/v2-solidity-utils/contracts/helpers/InputHelpers.sol";
+import "../../solidity-utils/contracts/openzeppelin/EnumerableSet.sol";
+import "../../solidity-utils/contracts/helpers/InputHelpers.sol";
 
 contract MockBasicAuthorizer is IBasicAuthorizer {
     using EnumerableSet for EnumerableSet.AddressSet;
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts vault/contracts/test/MockFlashLoanRecipient.sol vault/contracts/test/MockFlashLoanRecipient.sol
--- vault/contracts/test/MockFlashLoanRecipient.sol	2022-10-03 09:35:45.000000000 +0200
+++ vault/contracts/test/MockFlashLoanRecipient.sol	2022-10-28 09:58:59.000000000 +0200
@@ -14,13 +14,13 @@
 
 pragma solidity ^0.7.0;
 
-import "@balancer-labs/v2-interfaces/contracts/solidity-utils/openzeppelin/IERC20.sol";
-import "@balancer-labs/v2-interfaces/contracts/vault/IFlashLoanRecipient.sol";
-import "@balancer-labs/v2-interfaces/contracts/vault/IVault.sol";
-
-import "@balancer-labs/v2-solidity-utils/contracts/openzeppelin/SafeERC20.sol";
-import "@balancer-labs/v2-solidity-utils/contracts/test/TestToken.sol";
-import "@balancer-labs/v2-solidity-utils/contracts/math/Math.sol";
+import "../../interfaces/contracts/solidity-utils/openzeppelin/IERC20.sol";
+import "../../interfaces/contracts/vault/IFlashLoanRecipient.sol";
+import "../../interfaces/contracts/vault/IVault.sol";
+
+import "../../solidity-utils/contracts/openzeppelin/SafeERC20.sol";
+import "../../solidity-utils/contracts/test/TestToken.sol";
+import "../../solidity-utils/contracts/math/Math.sol";
 
 contract MockFlashLoanRecipient is IFlashLoanRecipient {
     using Math for uint256;
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts vault/contracts/test/MockInternalBalanceRelayer.sol vault/contracts/test/MockInternalBalanceRelayer.sol
--- vault/contracts/test/MockInternalBalanceRelayer.sol	2022-10-03 09:35:45.000000000 +0200
+++ vault/contracts/test/MockInternalBalanceRelayer.sol	2022-10-28 09:58:59.000000000 +0200
@@ -15,10 +15,10 @@
 pragma solidity ^0.7.0;
 pragma experimental ABIEncoderV2;
 
-import "@balancer-labs/v2-interfaces/contracts/solidity-utils/openzeppelin/IERC20.sol";
-import "@balancer-labs/v2-interfaces/contracts/vault/IVault.sol";
+import "../../interfaces/contracts/solidity-utils/openzeppelin/IERC20.sol";
+import "../../interfaces/contracts/vault/IVault.sol";
 
-import "@balancer-labs/v2-solidity-utils/contracts/helpers/InputHelpers.sol";
+import "../../solidity-utils/contracts/helpers/InputHelpers.sol";
 
 contract MockInternalBalanceRelayer {
     IVault public vault;
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts vault/contracts/test/MockPool.sol vault/contracts/test/MockPool.sol
--- vault/contracts/test/MockPool.sol	2022-10-03 09:35:45.000000000 +0200
+++ vault/contracts/test/MockPool.sol	2022-10-28 09:58:59.000000000 +0200
@@ -15,12 +15,12 @@
 pragma solidity ^0.7.0;
 pragma experimental ABIEncoderV2;
 
-import "@balancer-labs/v2-interfaces/contracts/solidity-utils/openzeppelin/IERC20.sol";
-import "@balancer-labs/v2-interfaces/contracts/vault/IVault.sol";
-import "@balancer-labs/v2-interfaces/contracts/vault/IGeneralPool.sol";
-import "@balancer-labs/v2-interfaces/contracts/vault/IMinimalSwapInfoPool.sol";
+import "../../interfaces/contracts/solidity-utils/openzeppelin/IERC20.sol";
+import "../../interfaces/contracts/vault/IVault.sol";
+import "../../interfaces/contracts/vault/IGeneralPool.sol";
+import "../../interfaces/contracts/vault/IMinimalSwapInfoPool.sol";
 
-import "@balancer-labs/v2-solidity-utils/contracts/math/FixedPoint.sol";
+import "../../solidity-utils/contracts/math/FixedPoint.sol";
 
 contract MockPool is IGeneralPool, IMinimalSwapInfoPool {
     using FixedPoint for uint256;
